ca65 V2.19 - Git d3cd668
Main file   : Forth.txt
Current file: Forth.txt

000000r 1               ; Subroutine threaded version of FIG FORTH for Centurion CPU6.
000000r 1               ;	CPU6 is a follow-on from "Eldorado ee200"
000000r 1               ; https://github.com/Nakazoto/CenturionComputer/
000000r 1               ; See also: "Starting FORTH" https://www.forth.com/starting-forth/
000000r 1               ; See also: https://forth-standard.org
000000r 1               ; See also: http://uefi.org
000000r 1               
000000r 1               ; by Lee Pivonka
000000r 1               
000000r 1               ; Based on FIG FORTH 6502 from http://6502.org/source/ .
000000r 1               
000000r 1               ;			 Through the courtesy of
000000r 1               ;
000000r 1               ;			  FORTH INTEREST GROUP
000000r 1               ;			     P.O. BOX  2154
000000r 1               ;			  OAKLAND, CALIFORNIA
000000r 1               ;				 94621
000000r 1               ;
000000r 1               ;
000000r 1               ;			      Release 1.1
000000r 1               ;
000000r 1               ;			 with compiler security
000000r 1               ;				   and
000000r 1               ;			 variable length names
000000r 1               ;
000000r 1               ;    Further distribution must include the above notice.
000000r 1               ;    The FIG installation Manual is required as it contains
000000r 1               ;    the model of FORTH and glossary of the system.
000000r 1               ;    Available from FIG at the above address for **.** postpaid.
000000r 1               ;
000000r 1               ;    Translated from the FIG model by W.F. Ragsdale with input-
000000r 1               ;    output given for the Rockwell System-65. Transportation to
000000r 1               ;    other systems requires only the alteration of :
000000r 1               ;		  EmitA KeyA QTerminalA RSlashW Mon
000000r 1               
000000r 1               ; This version has 2 major modifications from the FIG version:
000000r 1               ; * Subroutine threaded code.  There is no DoCol or other colon routines - it's all CPU6 code.
000000r 1               ;	There is no PFA or CFA - words start with CPU6 code.
000000r 1               ;	Words that use the CFA PFA model start with a JSR to the code, followed by the parameters.
000000r 1               ; * Word headers are remodeled.  There are no NFA PFA CFA versions - there is a single pointer to the
000000r 1               ;	CPU6 code, & header fields are at negative offsets from that.
000000r 1               
000000r 1               ; This file includes machine code definitions of all of the core words.
000000r 1               ; When this code is running, additional definitions can be typed in or compiled from disk.
000000r 1               
000000r 1               ; Standard CPU6 register usage:
000000r 1               ; A	scratch
000000r 1               ; B	scratch
000000r 1               ; X	CPU6, scratch
000000r 1               ; Y	scratch
000000r 1               ; Z	FORTH parameter stack pointer
000000r 1               ; S	CPU6, FORTH return stack pointer
000000r 1               ; C	CPU6
000000r 1               ; P	CPU6
000000r 1               
000000r 1               ; Compile with ca65 from cc65 - https://cc65.github.io/
000000r 1               
000000r 1               	.list on
000000r 1               	.listbytes unlimited ;include all object bytes in listing (since we load the listing file)
000000r 1               	.feature loose_string_term ; used to put quotes in strings
000000r 1               
000000r 1               	.include "0instructions.txt"  ; define Centurion CPU6 instructions
000000r 2               ; https://github.com/Nakazoto/CenturionComputer/wiki/Instructions
000000r 2               
000000r 2               
000000r 2               ; Instructions
000000r 2               ; This is a list of the available registers, OpCodes / Instructions, and what they mean.
000000r 2               ; These were all reverse engineered by just looking at existing code and recognizing patterns.
000000r 2               ; As such, this list may be incomplete or full of errors.
000000r 2               ; Any resemblance to the mnemonics or syntax used by other processors, such as the 8086, is simply because we borrowed existing syntax where it seemed fit.
000000r 2               ; The processor itself shares no design or architecture with any other documented existing processors we're aware of.
000000r 2               ; It is based upon the CPU4 and CPU5 earlier Warrex designs, and apparently the CD 200 before that, but we have no documentation for those either.
000000r 2               ; See ee 200.
000000r 2               
000000r 2               ; Registers
000000r 2               ; There are eight registers available.
000000r 2               ;	 Name	Usage			Notes
000000r 2               AW = $0 ; A	Primary Accumulator	Primary register, commonly used in implicit operations
000000r 2               AH = $0
000000r 2               AL = $1
000000r 2               BW = $2 ; B	Secondary Accumulator	Primary register, commonly used in implicit operations
000000r 2               BH = $2
000000r 2               BL = $3
000000r 2               XW = $4 ; X	Primary Index		Can only do word operations (Not true for CPU6?)
000000r 2               YW = $6 ; Y	Index or Working	Index registers or working storage registers
000000r 2               YH = $6
000000r 2               YL = $7
000000r 2               ZW = $8 ; Z	Index or Working	Index registers or working storage registers
000000r 2               ZH = $8
000000r 2               ZL = $9
000000r 2               SW = $a ; S	Stack pointer		Global among all interrupt levels
000000r 2               SH = $a
000000r 2               SL = $b
000000r 2               CW = $c ; C	Context			Contains the status condition indicators (fault, link, minus, and value) and preceding interrupt level
000000r 2               PW = $e ; P	Program Counter Base	Contains initial program counter value to be used when starting up or returning from interrupt
000000r 2               
000000r 2               ; Contexts
000000r 2               ; Each register and the flags appears to exist in 16 contexts and these contexts are mapped between 0x0000 and 0x00FF
000000r 2               ; 16 bytes per context starting with context 0 and working upwards.
000000r 2               ; The registers are stored in the memory in the order given above. Writing to the memory of another context updates the registers for that context.
000000r 2               ; Writing to the memory for your own context appears to change the register value except for PC and the unknown extra register.
000000r 2               ; Possibly PC is cached/reloaded on a context switch.
000000r 2               
000000r 2               ; The processor starts in context 0.
000000r 2               ; Context 15 is used by what appears to be a syscall instruction.
000000r 2               ; context 6 is used by the MUX interrupt test.
000000r 2               ; context 1 is used programatically during MMU testing.
000000r 2               
000000r 2               ; Interrupts are processed by a hardware triggered context switch, the execution of code in the new context,
000000r 2               ; and then an RI or RIM instruction.
000000r 2               
000000r 2               ; Instruction Organization
000000r 2               ; Instructions are constructed a nibble at a time, like a Build a Bear. The high nibble of the high byte determines what kind of operation is being executed. It should be noted that the lowest bit of the high nibble determines whether we are doing a byte operation or a word operation (excluding Control, Branch, X register and Jump operations). For example, 0x8 is 1000 in binary and is a byte operation. 0x9 is 1001 in binary and is a word operation. Both operation load the A register, but the low bit being either "0" or "1" is what determines whether we are loading a byte or word.
000000r 2               
000000r 2               ; High nibble	Operation type
000000r 2               ; 0x0	Control instructions
000000r 2               ; 0x1	Conditional branch instructions
000000r 2               ; 0x2	Single Register byte operations
000000r 2               ; 0x3	Single register word operations
000000r 2               ; 0x4	Double register byte operations
000000r 2               ; 0x5	Double register word operations
000000r 2               ; 0x6	X register memory reference operations
000000r 2               ; 0x7	Jump operations
000000r 2               ; 0x8	A register load byte operations
000000r 2               ; 0x9	A register load word operations
000000r 2               ; 0xA	A register store byte operations
000000r 2               ; 0xB	A register store word operations
000000r 2               ; 0xC	B register load byte operations
000000r 2               ; 0xD	B register load word operations
000000r 2               ; 0xE	B register store byte operations
000000r 2               ; 0xF	B register store word operations
000000r 2               
000000r 2               ; Addressing Modes
000000r 2               ; Instructions can be either 1-byte, 2-byte or 3-byte depending on the type of instruction.
000000r 2               ; The second or third byte (if present) are related to addressing, or directing the instruction as to which location in memory to act upon.
000000r 2               ; Addressing can be either implicit or explicit.
000000r 2               ; Implicit means that no addressing is specified, and that specific instruction operates on only one specific location.
000000r 2               ; Explicit means the programmer must state which location they will perform the operation on.
000000r 2               
000000r 2               ; In the chart below, the addressing mode and what is expected at each nibble of each operation is shown.
000000r 2               
000000r 2               ; HB = High Byte; MB = Mid Byte; LB = Low Byte
000000r 2               
000000r 2               ; HN = High Nibble; LN = Low Nibble
000000r 2               
000000r 2               ; HB_HN      	HB_LN      	MB_HN  	MB_LN  	LB_HN  	LB_LN  	Note
000000r 2               ; 0	Op (0-F)					Control Operations
000000r 2               ; 1	Op (0-F)	Displace	Displace			Branch Operations
000000r 2               ; 2	Op (0-7)	Source Reg.				Single Register Explicit Byte Operation
000000r 2               ; 2	Op (8-F)					Single Register Implicit Byte Operation
000000r 2               ; 3	Op (0-7)	Source Reg.				Single Register Explicit Word Operation
000000r 2               ; 3	Op (8-F)					Single Register Implicit Word Operation
000000r 2               ; 4	Op (0-7)	Source Reg.	Dest. Reg.			Double Register Explicit Byte Operation
000000r 2               ; 4	Op (8-F)					Double Register Implicit Byte Operation
000000r 2               ; 5	Op (0-7)	Source Reg.	Dest. Reg.			Double Register Explicit Word Operation
000000r 2               ; 5	Op (8-F)					Double Register Implicit Word Operation
000000r 2               ; Op (6-F)	0	Literal	Literal			Literal Memory Address Byte Operation
000000r 2               ; Op (6-F)	0	Literal	Literal	Literal	Literal	Literal Memory Address Word Operation
000000r 2               ; Op (6-F)	1	Direct	Direct	Direct	Direct	Direct Memory Address Operation
000000r 2               ; Op (6-F)	2	Indirect	Indirect	Indirect	Indirect	Indirect Memory Address Operation
000000r 2               ; Op (6-F)	3	Displace	Displace			Relative to Current Location Memory Address Operation
000000r 2               ; Op (6-F)	4	Displace	Displace			Indirect Relative to Current Location Memory Address Operation
000000r 2               ; Op (6-F)	5	Register	Modifier	Displace	Displace	Indexed Addressing (Modifier Table Below)
000000r 2               ; Op (6-F)	8-F					Implicit Indexing (8 - F => A - P Reg.)
000000r 2               
000000r 2               ; Modifier	Note
000000r 2               ModBRB    =  0 ; (r)	Index
000000r 2               ModBRPB   =  1 ; (r+)	Index; Index returned, incremented by ^
000000r 2               ModBMRB   =  2 ; (-r)	Decrement and Index
000000r 2               ModABRB   =  4 ; @(r)	Index indirect
000000r 2               ModABRPB  =  5 ; @(r+)	Index indirect; Index returned, incremented by ^
000000r 2               ModABMRB  =  6 ; @(-r)	Decrement and index indirect
000000r 2               ModNBRB   =  8 ; n(r)	Index with displacement
000000r 2               ModNBRPB  =  9 ; n(r+)	Index with displacement; Index returned, incremented by ^
000000r 2               ModNBMRB  = $A ; n(-r)	Decrement and index with displacement
000000r 2               ModANBRB  = $C ; @n(r)	Index with displacement indirect
000000r 2               ModANBRPB = $D ; @n(r+)	Index with displacement indirect, Index returned, incremented by ^
000000r 2               ModANBMRB = $E ; @n(-r)	Decrement and index with displacement indirect
000000r 2               
000000r 2                 .macro ModBytes WReg,Mod,Offset
000000r 2               	.if (WReg&$fff1)<>0
000000r 2               	  .error "WReg must be a word register"
000000r 2               	 .endif
000000r 2               	.if (Mod=ModBRB) | (Mod=ModBRPB) | (Mod=ModBMRB) | (Mod=ModABRB) | (Mod=ModABRPB) | (Mod=ModABMRB)
000000r 2               	  .byte (WReg<<4)|Mod
000000r 2               	 .else
000000r 2               	  .if (Mod=ModNBRB) | (Mod=ModNBRPB) | (Mod=ModNBMRB) | (Mod=ModANBRB) | (Mod=ModANBRPB) | (Mod=ModANBMRB)
000000r 2               	    .byte (WReg<<4)|Mod,Offset ; is offset signed or unsigned???
000000r 2                          .else
000000r 2               	    .error "Unknown Mod"
000000r 2               	   .endif
000000r 2               	 .endif
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro HLT ; Wait for Interrupt (Halt)
000000r 2               	.byte $00
000000r 2               	.endmacro
000000r 2                 .macro NOPC ; No Operation
000000r 2               	.byte $01
000000r 2               	.endmacro
000000r 2                 .macro SF ; Set Fault flag
000000r 2               	.byte $02
000000r 2               	.endmacro
000000r 2                 .macro RF ; Reset Fault flag
000000r 2               	.byte $03
000000r 2               	.endmacro
000000r 2                 .macro EI ; Enable the Interrupt System (allow interrupts)
000000r 2               	.byte $04
000000r 2               	.endmacro
000000r 2                 .macro DI ; Disable the Interrupt System (disable interrupts)
000000r 2               	.byte $05
000000r 2               	.endmacro
000000r 2                 .macro SL ; Set the Link (carry) Flag
000000r 2               	.byte $06
000000r 2               	.endmacro
000000r 2                 .macro RL ; Reset the Link (carry) Flag
000000r 2               	.byte $07
000000r 2               	.endmacro
000000r 2                 .macro CL ; Complement Link flag
000000r 2               	.byte $08
000000r 2               	.endmacro
000000r 2                 .macro RSR ; Return from subroutine
000000r 2               	.byte $09
000000r 2               	.endmacro
000000r 2                 .macro RI ; Return from interrupt
000000r 2               	.byte $0A
000000r 2               	.endmacro
000000r 2                 .macro RIM ; Return from Interrupt Modified
000000r 2               	.byte $0B
000000r 2               	.endmacro
000000r 2                 .macro ELO ; Enable Link Out - teletype_tx=Link
000000r 2               	.byte $0C
000000r 2               	.endmacro
000000r 2                 .macro PCX ; Transfer PC to X - X=address of next instruction
000000r 2               	.byte $0D
000000r 2               	.endmacro
000000r 2                 .macro DLY ; Delay 4.55 ms - for TTY bit timing
000000r 2               	.byte $0E
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; Return from Syscall or similar (pops a byte, then the new value of rt, then a byte, then the new ipl)
000000r 2               ;	.byte $0F
000000r 2               ;	.endmacro
000000r 2               
000000r 2                 .macro BRel op,adr ; Build branch offset byte
000000r 2               ;	.local @L1
000000r 2               ;@L1	= adr-*		; PC+N
000000r 2               ;	.if L1<-$82 || L1>=$82  ; this chokes on fwd refs, so we can't check the range
000000r 2               ;	  .error "Branch out of range"
000000r 2               ;	 .endif
000000r 2               	.byte op,.lobyte(adr-*-1)
000000r 2               	.endmacro
000000r 2                 .macro BRel3 op,adr ; Build branch offset byte
000000r 2               	bne adr
000000r 2               	.org *-2  ; this doesn't show up right in the listing (that we load!)
000000r 2               	.byte op
000000r 2               	.org *+1
000000r 2               	.endmacro
000000r 2                 .macro BL adr ; Branch if Link (Carry) Set
000000r 2               	BRel $10,adr
000000r 2               	.endmacro
000000r 2                 .macro BNL adr ; Branch if Link (Carry) not Set
000000r 2               	BRel $11,adr
000000r 2               	.endmacro
000000r 2                 .macro BF adr ; Branch if Fault Set
000000r 2               	BRel $12,adr
000000r 2               	.endmacro
000000r 2                 .macro BNF adr ; Branch if Fault not Set
000000r 2               	BRel $13,adr
000000r 2               	.endmacro
000000r 2                 .macro BZ adr ; Branch if V (Z) flag set
000000r 2               	BRel $14,adr
000000r 2               	.endmacro
000000r 2                 .macro BNZ adr ; Branch if V (Z) flag clear
000000r 2               	BRel $15,adr
000000r 2               	.endmacro
000000r 2                 .macro BM adr ; Branch if Minus flag set
000000r 2               	BRel $16,adr
000000r 2               	.endmacro
000000r 2                 .macro BP adr ; Branch on Positive (Minus flag clear)
000000r 2               	BRel $17,adr
000000r 2               	.endmacro
000000r 2                 .macro BGZ adr ; Branch if Greater Than 0 (!V && !Minus)
000000r 2               	BRel $18,adr
000000r 2               	.endmacro
000000r 2                 .macro BLE adr ; Branch if Less Than or Equal to 0 (V | Minus)
000000r 2               	BRel $19,adr
000000r 2               	.endmacro
000000r 2                 .macro BS1 adr ; Branch if Sense Switch 1 Set
000000r 2               	BRel $1a,adr
000000r 2               	.endmacro
000000r 2                 .macro BS2 adr ; Branch if Sense Switch 2 Set
000000r 2               	BRel $1b,adr
000000r 2               	.endmacro
000000r 2                 .macro BS3 adr ; Branch if Sense Switch 3 Set
000000r 2               	BRel $1c,adr
000000r 2               	.endmacro
000000r 2                 .macro BS4 adr ; Branch if Sense Switch 4 Set
000000r 2               	BRel $1d,adr
000000r 2               	.endmacro
000000r 2                 .macro BTM Rel ; Branch on TTY Mark (Changed for CPU6?)
000000r 2               	BRel $1e,Rel
000000r 2               	.endmacro
000000r 2                 .macro BEP Rel ; Branch on Even Parity (Changed for CPU6?)
000000r 2               	BRel $1f,adr
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro RegW OpWord,Reg,Const
000000r 2               ;	.if (Reg&$fff0)=$40  ; word register?
000000r 2               	  .byte OpWord,((Reg&$f)<<4)+(Const&$f)
000000r 2               ;	 .else
000000r 2               ;	  .error "Strange register"
000000r 2               ;	 .endif
000000r 2               	.endmacro
000000r 2                 .macro RegB OpByte,Reg
000000r 2               ;	.if (Reg&$fff0)=$60  ; byte register?
000000r 2               	  .byte OpByte,(Reg&$f)<<4
000000r 2               ;	 .else
000000r 2               ;	  .error "Strange register"
000000r 2               ;	 .endif
000000r 2               	.endmacro
000000r 2                 .macro INR WReg,Const	; increment register word
000000r 2               	RegW $30,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro INRB BReg	; increment register upper byte or lower byte
000000r 2               	RegB $20,BReg
000000r 2               	.endmacro
000000r 2                 .macro INAB		; Increment AL register
000000r 2               	.byte $28
000000r 2               	.endmacro
000000r 2                 .macro INA		; Increment AW register
000000r 2               	.byte $38
000000r 2               	.endmacro
000000r 2                 .macro DCR WReg,Const	; decrement register word
000000r 2               	RegW $31,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro DCRB BReg	; decrement register upper byte or lower byte
000000r 2               	RegB $21,BReg
000000r 2               	.endmacro
000000r 2                 .macro DCAB		; Decrement AL register
000000r 2               	.byte $29
000000r 2               	.endmacro
000000r 2                 .macro DCA		; Decrement AW register
000000r 2               	.byte $39
000000r 2               	.endmacro
000000r 2                 .macro CLR WReg,Const	; clear register word
000000r 2               	RegW $32,WReg,Const
000000r 2               	.endmacro
000000r 2                 .macro CLRB BReg	; clear register upper byte or lower byte
000000r 2               	RegB $22,BReg
000000r 2               	.endmacro
000000r 2                 .macro CLAB		; Clear AL register
000000r 2               	.byte $2A
000000r 2               	.endmacro
000000r 2                 .macro CLA		; Clear AW register
000000r 2               	.byte $3A
000000r 2               	.endmacro
000000r 2                 .macro IVR WReg,Const	; invert register word
000000r 2               	RegW $33,WReg,Const
000000r 2               	.endmacro
000000r 2                 .macro IVRB BReg	; invert register byte
000000r 2               	RegB $23,BReg
000000r 2               	.endmacro
000000r 2                 .macro IVAB		; Invert AL register
000000r 2               	.byte $2B
000000r 2               	.endmacro
000000r 2                 .macro IVA		; Invert AW register
000000r 2               	.byte $3B
000000r 2               	.endmacro
000000r 2                 .macro SRR WReg,Const	; shift register right (sign extend)
000000r 2               	RegW $34,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro SRRB BReg	; shift register byte right (sign extend)
000000r 2               	RegB $24,BReg
000000r 2               	.endmacro
000000r 2                 .macro SRAB		; Shift AL register right (sign extend)
000000r 2               	.byte $2C
000000r 2               	.endmacro
000000r 2                 .macro SRA		; Shift AW register right (sign extend)
000000r 2               	.byte $3C
000000r 2               	.endmacro
000000r 2                 .macro SLR WReg,Const	; shift register left (0 shifted in)
000000r 2               	RegW $35,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro SLRB BReg	; shift register byte left (0 shifted in)
000000r 2               	RegBW $25,BReg
000000r 2               	.endmacro
000000r 2                 .macro SLAB		; Shift AL register left (0 shifted in)
000000r 2               	.byte $2D
000000r 2               	.endmacro
000000r 2                 .macro SLA		; Shift AW register left (0 shifted in)
000000r 2               	.byte $3D
000000r 2               	.endmacro
000000r 2                 .macro RRR WReg,Const	; rotate register right (thru link flag)
000000r 2               	RegW $36,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro RRRB BReg	; rotate register byte right (thru link flag)
000000r 2               	RegB $26,BReg
000000r 2               	.endmacro
000000r 2                 .macro RLR WReg,Const	; rotate register left (thru link flag)
000000r 2               	RegW $37,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro RLRB BReg
000000r 2               	RegBW $27,BReg
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; Memory mapping?
000000r 2               ;	.byte $2E
000000r 2               ;	.endmacro
000000r 2               ;  .macro ?? ; DMA?
000000r 2               ;	.byte $2F
000000r 2               ;	.endmacro
000000r 2               
000000r 2                 .macro INXC		; Increment XW register
000000r 2               	.byte $3E
000000r 2               	.endmacro
000000r 2                 .macro DCX		; Decrement XW register
000000r 2               	.byte $3F
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ADD DestReg,SrcReg ; Add word Src to Dest
000000r 2               	.byte $50,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro ADDB DestReg,SrcReg ; Add byte Src to Dest
000000r 2               	.byte $40,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro AABB		; BL+=AL
000000r 2               	.byte $48
000000r 2               	.endmacro
000000r 2                 .macro AAB		; BW+=AW
000000r 2               	.byte $58
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro SUB DestReg,SrcReg ; Subtract byte Src to Dest
000000r 2               	.byte $51,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro SUBB DestReg,SrcReg ; Subtract byte Src to Dest
000000r 2               	.byte $41,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro SABB		; BL=AL-BL
000000r 2               	.byte $49
000000r 2               	.endmacro
000000r 2                 .macro SAB		; BW=AW-BW
000000r 2               	.byte $59
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ANDC DestReg,SrcReg ; AND word Src to Dest
000000r 2               	.byte $52,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro ANDB DestReg,SrcReg ; AND byte Src to Dest
000000r 2               	.byte $42,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro NABB		; BL&=AL
000000r 2               	.byte $4A
000000r 2               	.endmacro
000000r 2                 .macro NAB		; BW&=AW
000000r 2               	.byte $5A
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ORI DestReg,SrcReg ; OR word Src to Dest
000000r 2               	.byte $53,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro ORIB DestReg,SrcReg ; OR byte Src to Dest
000000r 2               	.byte $43,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ORE DestReg,SrcReg ; XOR word Src to Dest
000000r 2               	.byte $54,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro OREB DestReg,SrcReg ; XOR byte Src to Dest
000000r 2               	.byte $44,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro XFR DestReg,SrcReg ; Copy Src register into Dest register
000000r 2               	.byte $55,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro XFRB DestReg,SrcReg ; Copy byte of Src register into byte of Dest register
000000r 2               	.byte $45,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ??
000000r 2               ;	.byte $46
000000r 2               ;	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; Execute micro code?
000000r 2               ;	.byte $47
000000r 2               ;	.endmacro
000000r 2               
000000r 2               
000000r 2                 .macro XAXB	; XL=AL  ???
000000r 2               	.byte $4B
000000r 2               	.endmacro
000000r 2                 .macro XAX	; XW=AW
000000r 2               	.byte $5B
000000r 2               	.endmacro
000000r 2                 .macro XAYB	; YL=AL
000000r 2               	.byte $4C
000000r 2               	.endmacro
000000r 2                 .macro XAY	; YW=AW
000000r 2               	.byte $5C
000000r 2               	.endmacro
000000r 2                 .macro XABB	; BL=AL
000000r 2               	.byte $4D
000000r 2               	.endmacro
000000r 2                 .macro XAB	; BW=AW
000000r 2               	.byte $5D
000000r 2               	.endmacro
000000r 2                 .macro XAZB	; ZL=AL
000000r 2               	.byte $4E
000000r 2               	.endmacro
000000r 2                 .macro XAZ	; ZW=AW
000000r 2               	.byte $5E
000000r 2               	.endmacro
000000r 2                 .macro XASB	; SL=AL
000000r 2               	.byte $4F
000000r 2               	.endmacro
000000r 2                 .macro XAS	; SW=AW
000000r 2               	.byte $5F
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro PUSH BeginReg,RegCount
000000r 2               	.byte $7e,(BeginReg<<4)+((RegCount-1)&$f)
000000r 2               	.endmacro
000000r 2                 .macro POP BeginReg,RegCount
000000r 2               	.byte $7f,(BeginReg<<4)+((RegCount-1)&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ??	; 56	0101 0110	??
000000r 2               
000000r 2               ;  .macro ??	; 57	0101 0111	??			Execute micro code?
000000r 2               
000000r 2               
000000r 2                 .macro LDABL Lit ; Load literal address into AL register
000000r 2               	.byte $80,Lit
000000r 2               	.endmacro
000000r 2                 .macro LDAL Lit ; Load literal address into full word of AW register
000000r 2               	.byte $90
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro LDABD Direct ; Load direct address into AL register
000000r 2               	.byte $81
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDAD Direct ; Load direct address into full word of AW register
000000r 2               	.byte $91
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDABI Indirect ; Load indirect address into AL register
000000r 2               	.byte $82
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDAI Indirect ; Load indirect address into full word of AW register
000000r 2               	.byte $92
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDABR Rel ; Load direct Program Counter offset by N address into AL register
000000r 2               	BRel $83,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDAR Rel ; Load direct Program Counter offset by N address into full word of AW register
000000r 2               	BRel $93,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDABRI Rel ; Load indirect Program Counter offset by N address into byte of AL register
000000r 2               	BRel $84,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDARI Rel ; Load indirect Program Counter offset by N address into full word of AW register
000000r 2               	BRel $94,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDABX WReg,Mod,Offset ; Load indexed register into byte of AL register
000000r 2               	.byte $85
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro LDAX WReg,Mod,Offset ; Load indexed register into full word of AW register
000000r 2               	.byte $95
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; 86	1000 0110	??
000000r 2               ;  .macro ?? ; 87	1000 0111	??
000000r 2                 .macro LDABA WReg ; Load byte from memory address stored in WReg into AL register
000000r 2               	.byte $88+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro LDAA WReg ; Load byte from memory address stored in WReg into AL register
000000r 2               	.byte $98+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; 96	1001 0110	??
000000r 2               ;  .macro ?? ; 97	1001 0111	??
000000r 2               
000000r 2                 .macro STABL Lit ; Store byte of AL register into literal address (Not possible?)
000000r 2               	.byte $A0
000000r 2               	.byte Lit
000000r 2               	.endmacro
000000r 2                 .macro STAL Lit ; Store word of AW register into literal address (Not possible?)
000000r 2               	.byte $B0
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro STABD Direct ; Store byte of AL register into direct address
000000r 2               	.byte $A1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STAD Direct ; Store word of AW register into direct address
000000r 2               	.byte $B1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STABI Indirect ; Store byte of AL register into indirect address
000000r 2               	.byte $A2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STAI Indirect ; Store word of AW register into indirect address
000000r 2               	.byte $B2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STABR Rel ; Store byte of AL register into direct Program Counter offset by N address
000000r 2               	BRel $a3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STAR Rel ; Store word of AW register into direct Program Counter offset by N address
000000r 2               	BRel $b3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STABRI Rel ; Store byte of AL register into indirect Program Counter offset by N address
000000r 2               	BRel $a4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STARI Rel ; Store word of AW register into indirect Program Counter offset by N address
000000r 2               	BRel $b4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STABX WReg,Mod,Offset ; Store byte of AL register into indexed register
000000r 2               	.byte $A5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro STAX WReg,Mod,Offset ; Store word of AW register into indexed register
000000r 2               	.byte $B5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; A6	1010 0110	??
000000r 2               ;  .macro ?? ; A7	1010 0111	??
000000r 2                 .macro STABA WReg ; Store AL register to memory address stored in WReg
000000r 2               	.byte $A8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro STAA WReg ; Store AW register to memory address stored in WReg
000000r 2               	.byte $B8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ; .macro ?? ; B6	1011 0110	??
000000r 2               ; .macro ?? ; B7	1011 0111	??
000000r 2               
000000r 2               
000000r 2                 .macro LDBBL Lit ; Load literal address into BL register
000000r 2               	.byte $C0
000000r 2               	.byte Lit
000000r 2               	.endmacro
000000r 2                 .macro LDBL Lit ; Load literal address into BW register
000000r 2               	.byte $D0
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro LDBBD Direct ; Load direct address into BL register
000000r 2               	.byte $C1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDBD Direct ; Load direct address into BW register
000000r 2               	.byte $D1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDBBI Indirect ; Load indirect address into BL register
000000r 2               	.byte $C2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDBI Indirect ; Load indirect address into BW register
000000r 2               	.byte $D2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDBBR Rel ; Load direct Program Counter offset by N address into BL register
000000r 2               	BRel $c3,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBR Rel ; Load direct Program Counter offset by N address into BW register
000000r 2               	BRel $d3,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBBRI Rel ; Load indirect Program Counter offset by N address into BL register
000000r 2               	BRel $c4,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBRI Rel ; Load indirect Program Counter offset by N address into BW register
000000r 2               	BRel $d4,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBBX WReg,Mod,Offset ; Load indexed register into BL register
000000r 2               	.byte $C5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro LDBX WReg,Mod,Offset ; Load indexed register into BW register
000000r 2               	.byte $D5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; C6	1100 0110	??
000000r 2               ;  .macro ?? ; C7	1100 0111	??
000000r 2               
000000r 2                 .macro LDBBA WReg ; Load byte from memory address stored in WReg into BL register
000000r 2               	.byte $C8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro LDBA WReg ; Load word from memory address stored in WReg into BW register
000000r 2               	.byte $D8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; D6	1101 0110	??
000000r 2               ;  .macro ?? ; D7	1101 0111	??
000000r 2               
000000r 2                 .macro STBBL Lit ; Store byte of BL register into literal address (Not possible?)
000000r 2               	.byte $E0
000000r 2               	.byte Lit
000000r 2               	.endmacro
000000r 2                 .macro STBL Lit ; Store BW into literal address (Not possible?)
000000r 2               	.byte $F0
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro STBBD Direct ; Store BL into direct address
000000r 2               	.byte $E1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STBD Direct ; Store BW into direct address
000000r 2               	.byte $F1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STBBI Indirect ; Store BL into indirect address
000000r 2               	.byte $E2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STBI Indirect ; Store BW into indirect address
000000r 2               	.byte $F2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STBBR Rel ; Store BL into direct Program Counter offset by N address
000000r 2               	BRel $e3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBR Rel ; Store BW into direct Program Counter offset by N address
000000r 2               	BRel $f3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBBRI Rel ; Store BL into indirect Program Counter offset by N address
000000r 2               	BRel $e4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBRI Rel ; Store BW into indirect Program Counter offset by N address
000000r 2               	BRel $f4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBBX WReg,Mod,Offset ; Store BL into indexed register
000000r 2               	.byte $E5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro STBX WReg,Mod,Offset ; Store BW into indexed register
000000r 2               	.byte $F5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; E6	1110 0110	??
000000r 2               ;  .macro ?? ; E7	1110 0111	??
000000r 2                 .macro STBBA WReg ; Store byte from BL register to memory address stored in WReg
000000r 2               	.byte $E8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro STBA WReg ; Store BW to memory address stored in WReg
000000r 2               	.byte $F8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; F6	1111 0110	??
000000r 2               ;  .macro ?? ; F7	1111 0111	??
000000r 2               
000000r 2               
000000r 2                 .macro LDXL Lit ; Load immediate into XW
000000r 2               	.byte $60
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro LDXD Direct ;	Load direct address into XW
000000r 2               	.byte $61
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDXI Indirect ; Load indirect address into XW
000000r 2               	.byte $62
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDXR Rel ; Load direct Program Counter offset by N address into XW
000000r 2               	BRel $63,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDXRI Rel ; Load indirect Program Counter offset by N address into XW
000000r 2               	BRel $64,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDXX WReg,Mod,Offset ; Load indexed mode register into XW
000000r 2               	.byte $65
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ??	; 66	0110 0110	??
000000r 2               ;  .macro ??	; 67	0110 0111	??
000000r 2                 .macro STXL Lit ; Store XW into literal address (Not possible?)
000000r 2               	.byte $68
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro STXD Direct ; Store XW into direct address
000000r 2               	.byte $69
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STXI Indirect ; Store XW into indirect address
000000r 2               	.byte $6A
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STXR Rel ; Store XW into direct Program Counter offset by N address
000000r 2               	BRel $6b,Rel
000000r 2               	.endmacro
000000r 2                 .macro STXRI Rel ; Store XW into indirect Program Counter offset by N address
000000r 2               	BRel $6c,Rel
000000r 2               	.endmacro
000000r 2                 .macro STXX WReg,Mod,Offset ; Store XW into indexed register
000000r 2               	.byte $6D
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ??	; 6E	0110 1110	??
000000r 2               ;  .macro ??	; 6F	0110 1111	??
000000r 2               
000000r 2               ;  .macro ??	; $70
000000r 2                 .macro JMPD Direct ; Jump to direct address
000000r 2               	.byte $71
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro JMPI Indirect ; Jump to indirect address
000000r 2               	.byte $72
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro JMPR Rel ; Jump to direct Program Counter offset by N address
000000r 2               	BRel $73,Rel
000000r 2               	.endmacro
000000r 2                 .macro JMPRI Rel ; Jump to indirect Program Counter offset by N address
000000r 2               	BRel $74,Rel
000000r 2               	.endmacro
000000r 2                 .macro JMPX WReg,Mod,Offset ;Jump to indexed mode register
000000r 2               	.byte $75
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro SYSCALL	; Call interrupt level 15
000000r 2               	.byte $76
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; 77	0111 0111	??
000000r 2               
000000r 2               ;  .macro ?? ; 78 ??
000000r 2                 .macro JSRD Direct ; Jump to subroutine at direct address
000000r 2               	.byte $79
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro JSRI Indirect ; Jump to subroutine at indirect address
000000r 2               	.byte $7A
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro JSRR Rel ; Jump to subroutine at Program Counter offset by N address
000000r 2               	BRel $7b,Rel
000000r 2               	.endmacro
000000r 2                 .macro JSRRI Rel ; Jump to subroutine at indirect Program Counter offset by N address
000000r 2               	BRel $7c,Rel
000000r 2               	.endmacro
000000r 2                 .macro JSRX WReg,Mod,Offset ; Jump to subroutine at indexed mode register
000000r 2               	.byte $7D
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro MEMCPY
000000r 2               	.byte $f7
000000r 2               	.endmacro
000000r 2               
000000r 2               
000000r 1               
000000r 1               
000000r 1               ; handy constants
000000r 1               
000000r 1               ; Sector size is a bit of a mess on Centurion.  Many devices use 400 byte sectors.
000000r 1               ;   How to map that to FORTH 1024 byte screens is unfinished.
000000r 1               SectorSize =256		; sector size in bytes
000000r 1               NBUF =1024/SectorSize	; number of buffers desired in RAM
000000r 1               			;     (SectorSize*NBUF >= 1024 bytes)
000000r 1               Sectors	=800		; sectors per drive
000000r 1               			;    forcing high drive to zero
000000r 1               SECTL	=2*Sectors	; sector limit for two drives
000000r 1               
000000r 1               
000000r 1               ; Error, Warning, and other messages - external text starting on on screens 4
000000r 1               Err_0			=  0 ; abort with no message
000000r 1               Err_StackUnderflow	=  1 ; EMPTY STACK
000000r 1               Err_DictionaryFull	=  2 ; DICTIONARY FULL
000000r 1               ; Err_3			=  3 ; HAS INCORRECT ADDRESS MODE
000000r 1               Err_IsntUnique		=  4 ; ISN'T UNIQUE
000000r 1               ;  5
000000r 1               ; Err_06 		=  6 ; DISC RANGE
000000r 1               Err_StackOverflow	=  7 ; stack overflow
000000r 1               Err_8			=  8 ; disk i/o error
000000r 1               ;  9
000000r 1               ; 10
000000r 1               ; 11
000000r 1               ; 12
000000r 1               ; 13
000000r 1               ; 14
000000r 1               Err_TriadFooter		  = 15  ; TRIAD footer message
000000r 1               ; 16
000000r 1               Err_CompileOnly		  = $11 ; COMPILATION ONLY, USE IN DEFINITION
000000r 1               Err_ExecuteOnly		  = $12 ; EXECUTION ONLY
000000r 1               Err_ConditionalsNotPaired = $13 ; CONDITIONALS NOT PAIRED
000000r 1               Err_DefinitionNotFinished = $14 ; DEFINITION NOT FINISHED
000000r 1               Err_InProtectedDictionary = $15 ; IN PROTECTED DICTIONARY
000000r 1               Err_UseOnlyWhenLoading    = $16 ; USE ONLY WHEN LOADING
000000r 1               ; $17
000000r 1               ; $18 DECLARE VOCABULARY
000000r 1               
000000r 1               
000000r 1               	.org $7000 ; more uninitialized RAM
007000  1               
007000  1               DictTop:	; From here downward to the top of the dictionary is free
007000  1               		; space where the user's applications are compiled.
007000  1               
007000  1  xx xx        VUse:	.res 2		; the address of the block buffer to use next, as the least recently written.
007002  1  xx xx        VPrev:	.res 2		; the address of the disc buffer most recently referenced.
007004  1               			;   The UPDATE command marks this buffer to be later written to disc.
007004  1               
007004  1  xx xx xx xx  TIBX:	.res 86		; terminal input buffer
007008  1  xx xx xx xx  
00700C  1  xx xx xx xx  
007010  1  xx xx xx xx  
007014  1  xx xx xx xx  
007018  1  xx xx xx xx  
00701C  1  xx xx xx xx  
007020  1  xx xx xx xx  
007024  1  xx xx xx xx  
007028  1  xx xx xx xx  
00702C  1  xx xx xx xx  
007030  1  xx xx xx xx  
007034  1  xx xx xx xx  
007038  1  xx xx xx xx  
00703C  1  xx xx xx xx  
007040  1  xx xx xx xx  
007044  1  xx xx xx xx  
007048  1  xx xx xx xx  
00704C  1  xx xx xx xx  
007050  1  xx xx xx xx  
007054  1  xx xx xx xx  
007058  1  xx xx        
00705A  1               
00705A  1  xx xx        RamDiskStart: .res 2	; RAM disk: start of memory buffer
00705C  1  xx xx        RamDiskCount: .res 2	; RAM disk: count of 256 byte blocks
00705E  1               
00705E  1               UArea:
00705E  1               VUser: ; user area variables, partially initialized from ORIG
00705E  1  xx xx        	.res 2	;+00:	ptr latest ROM word
007060  1  xx xx        VBS:	.res 2	;+02:	backspace char
007062  1  xx xx        VUA:	.res 2	;+04:	ptr user area (direct page IS the user area)
007064  1  xx xx        VS0:	.res 2	;+06:	initial value for the parameter stack index
007066  1  xx xx        VR0:	.res 2	;+08:	initial value of the return stack ptr
007068  1  xx xx        VTIB:	.res 2	;+0a:	Address of the terminal input buffer.
00706A  1  xx xx        VWidth:	.res 2	;+0c:	Maximum number of letters saved in the compilation of a definitions' name.
00706C  1               		;	It must be 1 thru 31, with a default of 31.
00706C  1               		;	The name char cound and its natural chars are saved, up to the value in WIDTH.
00706C  1               		;	The value may be changed at any time within the above limits.
00706C  1  xx xx        VWarning: .res 2 ;+0e:	Value controlling messages.  If =1 disc is present,
00706E  1               		;	and screen 4 of drive 0 is the base location for messages.
00706E  1               		;	If =0, no disc is present and messages will be presented by number.
00706E  1               		;	if =-1, execute (ABORT) for a user specified procedure.
00706E  1               		;	See MESSAGE ERROR
00706E  1  xx xx        VFence:	.res 2	;+10:	Address below which FORGETting is trapped.
007070  1               		;	To forget below this point the user must alter the contents of FENCE .
007070  1  xx xx        VDP:	.res 2	;+12:	ptr next available dictionary memory location
007072  1               		;	The value may be read by HERE and altered by ALLOT.
007072  1               
007072  1  xx xx        VVoc_Link: .res 2 ;+14:	Containing the address of a field in the definition of the most
007074  1               		;	recently created vocabulary.  All vocabulary names are linked by these fields
007074  1               		;	to allow control for FORGETting thru multiple vocabularys.
007074  1               
007074  1  xx xx        VBlk:	.res 2	;+16:	Block (not screen) number being interpreted.
007076  1               		;	If 0, input is being taken from the terminal input buffer.
007076  1               		;	https://forth-standard.org/standard/block/BLK
007076  1  xx xx        VIn:	.res 2	;+18:	Byte offset within the current input text buffer (terminal or disc)
007078  1               		;	from which the next text will be accepted.
007078  1               		;	WORD uses and moves the value of IN .
007078  1  xx xx        VOut:	.res 2	;+1A:	A value incremented by EMIT .
00707A  1               		;	The user may alter and examine OUT to control display formatting.
00707A  1  xx xx        VScr:	.res 2	;+1C:	the screen number most recently referenced by LIST .
00707C  1               		;	https://forth-standard.org/standard/block/SCR
00707C  1  xx xx        VOffset: .res 2	;+1E:	disc block offset in 1024 byte blocks
00707E  1               		;	The contents of OFFSET is added to the block number in BLOCK
00707E  1               		;	to allow for this selection.
00707E  1               		;	May contain a block offset to disc drives.  The contents
00707E  1               		;	of OFFSET is added to the stack number by BLOCK .
00707E  1               		;	Messages by MESSAGE are independent of OFFSET .
00707E  1               		;	See BLOCK DR0 DR1 MESSAGE
00707E  1               
00707E  1  xx xx        VContext: .res 2 ;+20:	pointer to the vocabulary within which dictionary searching will first begin.
007080  1               		;	ptr to dictionary head in vocabulary word
007080  1  xx xx        VCurrent: .res 2 ;+22:	ptr to dictionary head in vocabulary word
007082  1  xx xx        VState:	.res 2	;+24:	compilation state.  A non-zero value indicates compilation.
007084  1               		;	The value itself may be implementation dependent.
007084  1               		;	Contains the compilation-state flag.
007084  1               		;	STATE is true when in compilation state, false otherwise.
007084  1               		;	The true value in STATE is non-zero, but is otherwise implementation-defined.
007084  1               		;	Only the following standard words alter the value in STATE:
007084  1               		;		: (colon), ; (semicolon), ABORT, QUIT, :NONAME, [ (left-bracket), ] (right-bracket).
007084  1               		;	Note: A program shall not directly alter the contents of STATE.
007084  1  xx xx        VBase:	.res 2	;+26:	the current number base used for input and output conversion; 2..36
007086  1  xx xx        VDPL:	.res 2	;+28:	number of digits to the rights of the decimal on double integer input.
007088  1               		;	It may also be used to hold output column location of a decimal point,
007088  1               		;	in user generated formatting.
007088  1               		;	The default value on signel number input is -1 (none).
007088  1  xx xx        VFld:	.res 2	;+2A:	for control of number output field width. Presently unused in fig-FORTH.
00708A  1  xx xx        VCSP:	.res 2	;+2C:	temporarily store the stack pointer position, for compilation error checking.
00708C  1  xx xx        VRNum:	.res 2	;+2E:	may contain the location of an editing cursor, or other file related function.
00708E  1  xx xx        VHld:	.res 2	;+30:	holds the address of the latest char of text during numeric output conversion.
007090  1  xx           VLineComment: .res 1	; ignore remainder of line
007091  1               
007091  1  xx xx        VFPtr:	.res 2	;	Floating-point stack ptr
007093  1  xx xx        VFpLo:	.res 2	;	"                " lo limit
007095  1  xx xx        VFpHi:	.res 2	;	"                " hi limit
007097  1               
007097  1  xx xx xx xx  BOS:	.res $7e	; parameter (data) stack
00709B  1  xx xx xx xx  
00709F  1  xx xx xx xx  
0070A3  1  xx xx xx xx  
0070A7  1  xx xx xx xx  
0070AB  1  xx xx xx xx  
0070AF  1  xx xx xx xx  
0070B3  1  xx xx xx xx  
0070B7  1  xx xx xx xx  
0070BB  1  xx xx xx xx  
0070BF  1  xx xx xx xx  
0070C3  1  xx xx xx xx  
0070C7  1  xx xx xx xx  
0070CB  1  xx xx xx xx  
0070CF  1  xx xx xx xx  
0070D3  1  xx xx xx xx  
0070D7  1  xx xx xx xx  
0070DB  1  xx xx xx xx  
0070DF  1  xx xx xx xx  
0070E3  1  xx xx xx xx  
0070E7  1  xx xx xx xx  
0070EB  1  xx xx xx xx  
0070EF  1  xx xx xx xx  
0070F3  1  xx xx xx xx  
0070F7  1  xx xx xx xx  
0070FB  1  xx xx xx xx  
0070FF  1  xx xx xx xx  
007103  1  xx xx xx xx  
007107  1  xx xx xx xx  
00710B  1  xx xx xx xx  
00710F  1  xx xx xx xx  
007113  1  xx xx        
007115  1  xx xx xx xx  TOS:	.res 8		; top of parameter stack, with extra padding
007119  1  xx xx xx xx  
00711D  1               
00711D  1               ;N:	.res 8		; scratch workspace.
00711D  1               
00711D  1  xx xx xx xx  RStack:	.res 128	; return stack
007121  1  xx xx xx xx  
007125  1  xx xx xx xx  
007129  1  xx xx xx xx  
00712D  1  xx xx xx xx  
007131  1  xx xx xx xx  
007135  1  xx xx xx xx  
007139  1  xx xx xx xx  
00713D  1  xx xx xx xx  
007141  1  xx xx xx xx  
007145  1  xx xx xx xx  
007149  1  xx xx xx xx  
00714D  1  xx xx xx xx  
007151  1  xx xx xx xx  
007155  1  xx xx xx xx  
007159  1  xx xx xx xx  
00715D  1  xx xx xx xx  
007161  1  xx xx xx xx  
007165  1  xx xx xx xx  
007169  1  xx xx xx xx  
00716D  1  xx xx xx xx  
007171  1  xx xx xx xx  
007175  1  xx xx xx xx  
007179  1  xx xx xx xx  
00717D  1  xx xx xx xx  
007181  1  xx xx xx xx  
007185  1  xx xx xx xx  
007189  1  xx xx xx xx  
00718D  1  xx xx xx xx  
007191  1  xx xx xx xx  
007195  1  xx xx xx xx  
007199  1  xx xx xx xx  
00719D  1               RStackE:
00719D  1               
00719D  1               UserSize: ; end of user ara variables
00719D  1               ;	.assert <*<$100, error, "user area overflowed"
00719D  1               
00719D  1               
00719D  1               
00719D  1  xx xx xx xx  RndState: .res 4	; random # state
0071A1  1               
0071A1  1  xx xx xx xx  DArea:	.res (SectorSize+4)*NBUF ; disk buffer space.
0071A5  1  xx xx xx xx  
0071A9  1  xx xx xx xx  
0071AD  1  xx xx xx xx  
0071B1  1  xx xx xx xx  
0071B5  1  xx xx xx xx  
0071B9  1  xx xx xx xx  
0071BD  1  xx xx xx xx  
0071C1  1  xx xx xx xx  
0071C5  1  xx xx xx xx  
0071C9  1  xx xx xx xx  
0071CD  1  xx xx xx xx  
0071D1  1  xx xx xx xx  
0071D5  1  xx xx xx xx  
0071D9  1  xx xx xx xx  
0071DD  1  xx xx xx xx  
0071E1  1  xx xx xx xx  
0071E5  1  xx xx xx xx  
0071E9  1  xx xx xx xx  
0071ED  1  xx xx xx xx  
0071F1  1  xx xx xx xx  
0071F5  1  xx xx xx xx  
0071F9  1  xx xx xx xx  
0071FD  1  xx xx xx xx  
007201  1  xx xx xx xx  
007205  1  xx xx xx xx  
007209  1  xx xx xx xx  
00720D  1  xx xx xx xx  
007211  1  xx xx xx xx  
007215  1  xx xx xx xx  
007219  1  xx xx xx xx  
00721D  1  xx xx xx xx  
007221  1  xx xx xx xx  
007225  1  xx xx xx xx  
007229  1  xx xx xx xx  
00722D  1  xx xx xx xx  
007231  1  xx xx xx xx  
007235  1  xx xx xx xx  
007239  1  xx xx xx xx  
00723D  1  xx xx xx xx  
007241  1  xx xx xx xx  
007245  1  xx xx xx xx  
007249  1  xx xx xx xx  
00724D  1  xx xx xx xx  
007251  1  xx xx xx xx  
007255  1  xx xx xx xx  
007259  1  xx xx xx xx  
00725D  1  xx xx xx xx  
007261  1  xx xx xx xx  
007265  1  xx xx xx xx  
007269  1  xx xx xx xx  
00726D  1  xx xx xx xx  
007271  1  xx xx xx xx  
007275  1  xx xx xx xx  
007279  1  xx xx xx xx  
00727D  1  xx xx xx xx  
007281  1  xx xx xx xx  
007285  1  xx xx xx xx  
007289  1  xx xx xx xx  
00728D  1  xx xx xx xx  
007291  1  xx xx xx xx  
007295  1  xx xx xx xx  
007299  1  xx xx xx xx  
00729D  1  xx xx xx xx  
0072A1  1  xx xx xx xx  
0072A5  1  xx xx xx xx  
0072A9  1  xx xx xx xx  
0072AD  1  xx xx xx xx  
0072B1  1  xx xx xx xx  
0072B5  1  xx xx xx xx  
0072B9  1  xx xx xx xx  
0072BD  1  xx xx xx xx  
0072C1  1  xx xx xx xx  
0072C5  1  xx xx xx xx  
0072C9  1  xx xx xx xx  
0072CD  1  xx xx xx xx  
0072D1  1  xx xx xx xx  
0072D5  1  xx xx xx xx  
0072D9  1  xx xx xx xx  
0072DD  1  xx xx xx xx  
0072E1  1  xx xx xx xx  
0072E5  1  xx xx xx xx  
0072E9  1  xx xx xx xx  
0072ED  1  xx xx xx xx  
0072F1  1  xx xx xx xx  
0072F5  1  xx xx xx xx  
0072F9  1  xx xx xx xx  
0072FD  1  xx xx xx xx  
007301  1  xx xx xx xx  
007305  1  xx xx xx xx  
007309  1  xx xx xx xx  
00730D  1  xx xx xx xx  
007311  1  xx xx xx xx  
007315  1  xx xx xx xx  
007319  1  xx xx xx xx  
00731D  1  xx xx xx xx  
007321  1  xx xx xx xx  
007325  1  xx xx xx xx  
007329  1  xx xx xx xx  
00732D  1  xx xx xx xx  
007331  1  xx xx xx xx  
007335  1  xx xx xx xx  
007339  1  xx xx xx xx  
00733D  1  xx xx xx xx  
007341  1  xx xx xx xx  
007345  1  xx xx xx xx  
007349  1  xx xx xx xx  
00734D  1  xx xx xx xx  
007351  1  xx xx xx xx  
007355  1  xx xx xx xx  
007359  1  xx xx xx xx  
00735D  1  xx xx xx xx  
007361  1  xx xx xx xx  
007365  1  xx xx xx xx  
007369  1  xx xx xx xx  
00736D  1  xx xx xx xx  
007371  1  xx xx xx xx  
007375  1  xx xx xx xx  
007379  1  xx xx xx xx  
00737D  1  xx xx xx xx  
007381  1  xx xx xx xx  
007385  1  xx xx xx xx  
007389  1  xx xx xx xx  
00738D  1  xx xx xx xx  
007391  1  xx xx xx xx  
007395  1  xx xx xx xx  
007399  1  xx xx xx xx  
00739D  1  xx xx xx xx  
0073A1  1  xx xx xx xx  
0073A5  1  xx xx xx xx  
0073A9  1  xx xx xx xx  
0073AD  1  xx xx xx xx  
0073B1  1  xx xx xx xx  
0073B5  1  xx xx xx xx  
0073B9  1  xx xx xx xx  
0073BD  1  xx xx xx xx  
0073C1  1  xx xx xx xx  
0073C5  1  xx xx xx xx  
0073C9  1  xx xx xx xx  
0073CD  1  xx xx xx xx  
0073D1  1  xx xx xx xx  
0073D5  1  xx xx xx xx  
0073D9  1  xx xx xx xx  
0073DD  1  xx xx xx xx  
0073E1  1  xx xx xx xx  
0073E5  1  xx xx xx xx  
0073E9  1  xx xx xx xx  
0073ED  1  xx xx xx xx  
0073F1  1  xx xx xx xx  
0073F5  1  xx xx xx xx  
0073F9  1  xx xx xx xx  
0073FD  1  xx xx xx xx  
007401  1  xx xx xx xx  
007405  1  xx xx xx xx  
007409  1  xx xx xx xx  
00740D  1  xx xx xx xx  
007411  1  xx xx xx xx  
007415  1  xx xx xx xx  
007419  1  xx xx xx xx  
00741D  1  xx xx xx xx  
007421  1  xx xx xx xx  
007425  1  xx xx xx xx  
007429  1  xx xx xx xx  
00742D  1  xx xx xx xx  
007431  1  xx xx xx xx  
007435  1  xx xx xx xx  
007439  1  xx xx xx xx  
00743D  1  xx xx xx xx  
007441  1  xx xx xx xx  
007445  1  xx xx xx xx  
007449  1  xx xx xx xx  
00744D  1  xx xx xx xx  
007451  1  xx xx xx xx  
007455  1  xx xx xx xx  
007459  1  xx xx xx xx  
00745D  1  xx xx xx xx  
007461  1  xx xx xx xx  
007465  1  xx xx xx xx  
007469  1  xx xx xx xx  
00746D  1  xx xx xx xx  
007471  1  xx xx xx xx  
007475  1  xx xx xx xx  
007479  1  xx xx xx xx  
00747D  1  xx xx xx xx  
007481  1  xx xx xx xx  
007485  1  xx xx xx xx  
007489  1  xx xx xx xx  
00748D  1  xx xx xx xx  
007491  1  xx xx xx xx  
007495  1  xx xx xx xx  
007499  1  xx xx xx xx  
00749D  1  xx xx xx xx  
0074A1  1  xx xx xx xx  
0074A5  1  xx xx xx xx  
0074A9  1  xx xx xx xx  
0074AD  1  xx xx xx xx  
0074B1  1  xx xx xx xx  
0074B5  1  xx xx xx xx  
0074B9  1  xx xx xx xx  
0074BD  1  xx xx xx xx  
0074C1  1  xx xx xx xx  
0074C5  1  xx xx xx xx  
0074C9  1  xx xx xx xx  
0074CD  1  xx xx xx xx  
0074D1  1  xx xx xx xx  
0074D5  1  xx xx xx xx  
0074D9  1  xx xx xx xx  
0074DD  1  xx xx xx xx  
0074E1  1  xx xx xx xx  
0074E5  1  xx xx xx xx  
0074E9  1  xx xx xx xx  
0074ED  1  xx xx xx xx  
0074F1  1  xx xx xx xx  
0074F5  1  xx xx xx xx  
0074F9  1  xx xx xx xx  
0074FD  1  xx xx xx xx  
007501  1  xx xx xx xx  
007505  1  xx xx xx xx  
007509  1  xx xx xx xx  
00750D  1  xx xx xx xx  
007511  1  xx xx xx xx  
007515  1  xx xx xx xx  
007519  1  xx xx xx xx  
00751D  1  xx xx xx xx  
007521  1  xx xx xx xx  
007525  1  xx xx xx xx  
007529  1  xx xx xx xx  
00752D  1  xx xx xx xx  
007531  1  xx xx xx xx  
007535  1  xx xx xx xx  
007539  1  xx xx xx xx  
00753D  1  xx xx xx xx  
007541  1  xx xx xx xx  
007545  1  xx xx xx xx  
007549  1  xx xx xx xx  
00754D  1  xx xx xx xx  
007551  1  xx xx xx xx  
007555  1  xx xx xx xx  
007559  1  xx xx xx xx  
00755D  1  xx xx xx xx  
007561  1  xx xx xx xx  
007565  1  xx xx xx xx  
007569  1  xx xx xx xx  
00756D  1  xx xx xx xx  
007571  1  xx xx xx xx  
007575  1  xx xx xx xx  
007579  1  xx xx xx xx  
00757D  1  xx xx xx xx  
007581  1  xx xx xx xx  
007585  1  xx xx xx xx  
007589  1  xx xx xx xx  
00758D  1  xx xx xx xx  
007591  1  xx xx xx xx  
007595  1  xx xx xx xx  
007599  1  xx xx xx xx  
00759D  1  xx xx xx xx  
0075A1  1  xx xx xx xx  
0075A5  1  xx xx xx xx  
0075A9  1  xx xx xx xx  
0075AD  1  xx xx xx xx  
0075B1  1               DAreaEnd:
0075B1  1               
0075B1  1               
0075B1  1               
0075B1  1               INL_End = $0909	; RSR, & ha_inline code end marker
0075B1  1               
0075B1  1               ; Bit masks in "flags & length" byte of word header:
0075B1  1               ha_inline    = $80 ; can be compiled by copying inline
0075B1  1               ha_immediate = $40 ; aka precedence bit
0075B1  1               ha_smudge    = $20 ; do not find this word by name
0075B1  1               ha_length    = $1f ; # of chars in name (including ones > vWidth)
0075B1  1               
0075B1  1                 .macro FHdr name,flags ; compile a FORTH word header
0075B1  1               	.local L1,L2
0075B1  1               L1:	.byte name	;name of word as a string (no leading count byte)
0075B1  1               L2:	.byte L2-L1+flags ;flags & length of name (see ha_*)
0075B1  1               	.dbyt DictLink	;LFA: link to previous word's CFA in vocabulary chain
0075B1  1               DictLink .set *
0075B1  1               ;		The fields above are at negative offsets from label.
0075B1  1               ;label:	;NFA: same as CFA.  We access header fields using negative offsets from CFA.
0075B1  1               ;	;CFA: CPU6 code starts here.  This is the address that "find" returns.
0075B1  1               ;		Words that want PFA (eg CREATEd words) will have a JSR to the handler code,
0075B1  1               ;		  followed by the PFA area.  The JSR return address (+1) points to the PFA.
0075B1  1               	.endmacro
0075B1  1               
0075B1  1               DictLink .set 0 ; used to build the FHdr link chain.
0075B1  1               		; 0 indicates end of vocabulary list
0075B1  1               
0075B1  1               ; The FHdr line of each entry shows a symbolic description of the action of the procedure
0075B1  1               ; on the parameter stack.  The symbols indicate the order in which input parameters have
0075B1  1               ; been placed on the stack.  "---" indicate the execution point; any parameters left on the
0075B1  1               ; stack are listed after.  In this notation, the top of the stack is to the right.
0075B1  1               ;
0075B1  1               ; The symbols include:
0075B1  1               ;
0075B1  1               ; addr	memory address
0075B1  1               ; b	8 bit byte (i.e. hi 8  bits zero)
0075B1  1               ; c	ASCII character (hi 9 bits zero)
0075B1  1               ; d	32 bit signed double integer, most significant portion with sign on top of stack.
0075B1  1               ; f	boolean flag. 0=false, non-zero=true
0075B1  1               ; ff	boolean false flag=0
0075B1  1               ; n	16 bit signed integer number
0075B1  1               ; u	16 bit unsigned integer
0075B1  1               ; tf	boolean true flag (non-zero)
0075B1  1               ;
0075B1  1               ; The capital letters on the right show definition characteristics:
0075B1  1               ;   (not used)
0075B1  1               ; C	May only be used within a colon definition. A digit indicates number of memory
0075B1  1               ;	addresses used, if other than one.
0075B1  1               ; E	intended for execution only.
0075B1  1               ; L0	Level Zero definition of FORTH-78
0075B1  1               ; L1	Level One definition of FORTH-78
0075B1  1               ; P	Has precedence bit (immediate) set. Will execute even when compliling.
0075B1  1               ; U	A user variable.
0075B1  1               ;
0075B1  1               ; Unless otherwise noted, all references to numbers are for 16 bit signed integers.
0075B1  1               ; 16 bit numbers are big-endian, like the hardware.
0075B1  1               ; For 32 bit signed double numbers, the most significant part (with the sign) is on top.
0075B1  1               ;
0075B1  1               ; All arithmetic is implicitly 16 bit signed integer math, with error and underflow
0075B1  1               ; indication unspecified.
0075B1  1               
0075B1  1               
0075B1  1               	.org $200 ; start of program RAM ==========================================================
000200  1               ORIG:	; Start of boot up parameters.  34 bytes.
000200  1               
000200  1  01           Enter:	NOPC		; +00 User cold entry point
000201  1  71 17 1B     	JMPD Cold
000204  1  01           ReEnter: NOPC		; +04 User warm entry point
000205  1  71 17 29     	JMPD Warm
000208  1  00 00 00 00  	.dbyt 0,0	; +08 CPU6 in radix-36
00020C  1               
00020C  1               ; Initial values copied to VUser.
00020C  1               ; These values are altered as you make permanent extensions to your installation.
00020C  1  1D C6        	.dbyt NTOP	; +0C Last word
00020E  1  00 08        	.dbyt $08	; +0E Backspace Character
000210  1  70 5E        	.dbyt UArea	; +10 Initial User Area
000212  1  71 15        	.dbyt TOS	; +12 S0 - Initial Top of Stack (in user area)
000214  1  71 9D        	.dbyt RStackE	; +14 R0 - Initial Top of Return Stack
000216  1  70 04        	.dbyt TIBX	; +16 Initial terminal input buffer
000218  1  00 1F        	.dbyt 31	; +18 Initial name field width (not used)
00021A  1  00 00        	.dbyt 0		; +1A Initial warning
00021C  1  1E 33        	.dbyt TOP	; +1C Initial fence address
00021E  1  1E 33        	.dbyt TOP	; +1E Initial top of dictionary
000220  1  16 54        	.dbyt Forth+3+2	; +20 Initial Vocabulary link ptr.
000222  1               
000222  1               
000222  1  45 6D 70 74   FHdr 'Empty-RStack',0 ; ( -- ) ( R: ... -- )  empty the return stack (load from user variable R0 ) .
000226  1  79 2D 52 53  
00022A  1  74 61 63 6B  
00022E  1  0C 00 00     
000231  1               EmptyRStack:
000231  1  91 70 66     	LDAD VR0	; load S
000234  1  5F           	XAS
000235  1  75 40        	JMPX XW,ModBRB,0 ; return (without adjusting S)
000237  1               
000237  1               
000237  1               	.if 0
000237  1                FHdr 'RP!',0 ; ( -- )  FIG alias
000237  1               	JMPR EmptyRStack
000237  1               	.endif
000237  1               
000237  1               
000237  1               	.if 0
000237  1                FHdr 'RDepth',0 ; ( -- n )  return # of cells on return stack (not including this routine)
000237  1               	LDAD VR0
000237  1               	SUB AW,SW
000237  1               	INR AW,2
000237  1               	JMPR Depth3
000237  1               	.endif
000237  1               
000237  1               
000237  1  45 6D 70 74   FHdr 'Empty-Stack',0 ; ( ... -- )  empty the param stack.
00023B  1  79 2D 53 74  
00023F  1  61 63 6B 0B  
000243  1  02 31        
000245  1               EmptyStack:
000245  1  91 70 64     	LDAD VS0		; load the parameter stack pointer from S0
000248  1  5E           	XAZ
000249  1  D1 70 95     	LDBD VFpHi		; also empty FP stack
00024C  1  F1 70 91     	STBD VFPtr
00024F  1  09           	RSR
000250  1               
000250  1               
000250  1               	.if 0
000250  1                FHdr 'SP!',0 ; ( -- )  FIG alias
000250  1               	JMPR EmptyStack
000250  1               	.endif
000250  1               
000250  1               
000250  1  44 65 70 74   FHdr 'Depth',0 ; ( -- n )  https://forth-standard.org/standard/core/DEPTH
000254  1  68 05 02 45  
000258  1               ; Return the address of the stack position to the top of the stack, as it was before Depth was executed.
000258  1               ; (e.g. 1 2 Depth  . . .  would type 2 2 1 )
000258  1  91 70 64     Depth:	LDAD VS0
00025B  1  51 80        	SUB AW,ZW
00025D  1  33 01        Depth3:	IVR AW,1		; A = VS0-param_stack_ptr
00025F  1  3C           	SRA			; /2
000260  1  B5 82        	STAX ZW,ModBMRB,0	; push it
000262  1  09           	RSR			; return
000263  1               
000263  1               
000263  1               	.if 0
000263  1                FHdr 'SP@',0 ; ( -- n )  FIG alias
000263  1               	JMPR Depth
000263  1               	.endif
000263  1               
000263  1               
000263  1  44 72 6F 70   FHdr 'Drop',ha_inline ; ( n -- )  Drop a number from the stack.
000267  1  84 02 58     
00026A  1                  ; https://forth-standard.org/standard/core/DROP
00026A  1  30 81        Drop:	INR ZW,2		; bump the param stack index up 1 cell
00026C  1  09 09        	.dbyt INL_End		; return
00026E  1               
00026E  1               
00026E  1  32 44 72 6F   FHdr '2Drop',ha_inline ; ( n n -- )
000272  1  70 85 02 6A  
000276  1                  ; https://forth-standard.org/standard/core/TwoDROP
000276  1               TwoDrop:
000276  1  30 83        	INR ZW,4		; bump the param stack index up 2 cells
000278  1  09 09        	.dbyt INL_End		; return
00027A  1               
00027A  1               
00027A  1  52 6F 74 03   FHdr 'Rot',0 ; ( n1 n2 n3 -- n2 n3 n1 )  https://forth-standard.org/standard/core/ROT
00027E  1  02 76        
000280  1                  ; Rotate the top 3 values on the stack, bringing the 3rd to the top.
000280  1                  ; https://forth-standard.org/standard/core/ROT
000280  1  95 88 04     Rot:	LDAX ZW,ModNBRB,4	; Y=n1
000283  1  D5 88 02     	LDBX ZW,ModNBRB,2	; A=n2
000286  1  F5 88 04     	STBX ZW,ModNBRB,4	; store 3rd-on-stack
000289  1  DC           	LDBA ZW			; A=n1
00028A  1  F5 88 02     	STBX ZW,ModNBRB,2	; store next-on-stack
00028D  1  BC           	STAA ZW			; store top-on-stack
00028E  1  09           	RSR			; return
00028F  1               
00028F  1               
00028F  1               	.if 0
00028F  1                FHdr '-Rot',0 ; ( n1 n2 n3 -- n3 n1 n2 )  rotate the other way
00028F  1               MRot:	; small but slow
00028F  1               	JSRR Rot
00028F  1               	JMPR Rot
00028F  1               	.endif
00028F  1               
00028F  1               
00028F  1               	.if 0
00028F  1                FHdr '2Rot',0 ; ( d1 d2 d3 -- d2 d3 d1 )  Rotate the top 3 values on the stack
00028F  1                  ; https://forth-standard.org/standard/double/TwoROT
00028F  1               TwoRot:	DCR ZW,2		; do hi word
00028F  1               	JSRR @10
00028F  1               	INR ZW,2		; do lo word
00028F  1               @10:	LDAX ZW,ModNBRB,8+2	; Y=n1
00028F  1               	LDBX ZW,ModNBRB,4+2	; A=n2
00028F  1               	STBX ZW,ModNBRB,8+2	; store 3rd-on-stack
00028F  1               	LDBX ZW,ModNBRB,0+2	; A=n1
00028F  1               	STBX ZW,ModNBRB,4+2	; store next-on-stack
00028F  1               	STAX ZW,ModNBRB,0+2	; store top-on-stack
00028F  1               	RSR			; return
00028F  1               	.endif
00028F  1               
00028F  1               
00028F  1               	.if 0
00028F  1                FHdr 'Roll',0 ; ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
00028F  1                  ; Remove u. Rotate u+1 items on the top of the stack.
00028F  1                  ; An ambiguous condition exists if there are less than u+2 items on the stack before ROLL is executed.
00028F  1                  ; https://forth-standard.org/standard/core/ROLL
00028F  1               Roll:	JSRD ABort ;???
00028F  1               	.endif
00028F  1               
00028F  1               
00028F  1  53 77 61 70   FHdr 'Swap',0 ; ( n1 n2 -- n2 n1 )  Exchange the top 2 values on the stack.
000293  1  04 02 80     
000296  1                  ; https://forth-standard.org/standard/core/SWAP
000296  1  D5 81        Swap:	LDBX ZW,ModBRPB,0	; B=n2
000298  1  9C           	LDAA ZW			; A=n1
000299  1  FC           	STBA ZW			; store next-on-stack
00029A  1  B5 82        	STAX ZW,ModBMRB,0	; store top-on-stack
00029C  1  09           	RSR			; return
00029D  1               
00029D  1               
00029D  1  32 53 77 61   FHdr '2Swap',0 ; ( d1 d2 -- d2 d1 )  Exchange top 2 double values on the stack.
0002A1  1  70 05 02 96  
0002A5  1                  ; https://forth-standard.org/standard/core/TwoSWAP
0002A5  1               TwoSwap:
0002A5  1  D5 88 06     	LDBX ZW,ModNBRB,6	; swap lo words
0002A8  1  95 88 02     	LDAX ZW,ModNBRB,2
0002AB  1  F5 88 02     	STBX ZW,ModNBRB,2
0002AE  1  B5 88 06     	STAX ZW,ModNBRB,6
0002B1  1  D5 88 04     	LDBX ZW,ModNBRB,4	; swap hi words
0002B4  1  9C           	LDAA ZW
0002B5  1  FC           	STBA ZW
0002B6  1  B5 88 04     	STAX ZW,ModNBRB,4
0002B9  1  09           	RSR			; return
0002BA  1               
0002BA  1               
0002BA  1  4F 76 65 72   FHdr 'Over',ha_inline ; ( n1 n2 -- n1 n2 n1 )  Copy the second stack value, placing it as the new top.
0002BE  1  84 02 A5     
0002C1  1                  ; https://forth-standard.org/standard/core/OVER
0002C1  1  95 88 02     Over:	LDAX ZW,ModNBRB,2	; get next-on-stack
0002C4  1  B5 82        	STAX ZW,ModBMRB,0	; push it
0002C6  1  09 09        	.dbyt INL_End		; return
0002C8  1               
0002C8  1               
0002C8  1  32 4F 76 65   FHdr '2Over',0 ; ( d1 d2 -- d1 d2 d1 )  Copy the 2nd double value
0002CC  1  72 05 02 C1  
0002D0  1                  ; https://forth-standard.org/standard/core/TwoOVER
0002D0  1               TwoOver:
0002D0  1  D5 88 04     	LDBX ZW,ModNBRB,4	; get d1.hi word
0002D3  1  95 88 06     	LDAX ZW,ModNBRB,6	; get d1.lo word
0002D6  1  73 16        	JMPR PushBA
0002D8  1               
0002D8  1               
0002D8  1  44 75 70 83   FHdr 'Dup',ha_inline ; ( n1 -- n1 n1 )  Duplicate the value on the stack.
0002DC  1  02 D0        
0002DE  1                  ; https://forth-standard.org/standard/core/DUP
0002DE  1  9C           Dup:	LDAA ZW
0002DF  1  B5 82        PushA:	STAX ZW,ModBMRB,0 ; pushes AW register to the param stack.
0002E1  1  09 09        	.dbyt INL_End
0002E3  1               
0002E3  1               
0002E3  1  32 44 75 70   FHdr '2Dup',0 ; ( d1 -- d1 d1 )  Duplicate double value o the stack.
0002E7  1  04 02 DE     
0002EA  1                  ; https://forth-standard.org/standard/core/TwoDUP
0002EA  1  DC           TwoDup:	LDBA ZW			; get hi word
0002EB  1  95 88 02     	LDAX ZW,ModNBRB,2	; get lo word
0002EE  1  B5 82        PushBA:	STAX ZW,ModBMRB,0	; push lo word
0002F0  1  F5 82        	STBX ZW,ModBMRB,0	; push hi word
0002F2  1  09           	RSR
0002F3  1               
0002F3  1               
0002F3  1  3F 44 75 70   FHdr '?Dup',0	; ( n1 -- n1    ) (if zero)
0002F7  1  04 02 EA     
0002FA  1               		; ( n1 -- n1 n1 ) (non-zero)
0002FA  1                  ; Reproduce n1 only if it is non-zero.  This is usually used to copy a
0002FA  1                  ; value just before IF, to eliminate the need for an ELSE part to drop it.
0002FA  1                  ; https://forth-standard.org/standard/core/qDUP
0002FA  1  9C           QDup:	LDAA ZW			; n1<>0?
0002FB  1  15 E2        	BNZ PushA		;   push it & return
0002FD  1  09           	RSR			; return
0002FE  1               
0002FE  1               
0002FE  1               	.if 0
0002FE  1                FHdr '-Dup',0	; FIG alias
0002FE  1               	JMPR QDup
0002FE  1               	.endif
0002FE  1               
0002FE  1               
0002FE  1               	.if 0
0002FE  1                FHdr 'Pick',0 ; ( xu...x1 x0 u -- xu...x1 x0 xu )  Remove u. Copy the xu to the top of the stack.
0002FE  1                  ; An ambiguous condition exists if there are less than u+2 items on the stack before PICK is executed.
0002FE  1                  ; https://forth-standard.org/standard/core/PICK
0002FE  1               	.endif
0002FE  1               
0002FE  1               
0002FE  1  4E 69 70 83   FHdr 'Nip',ha_inline ; ( n1 n2 -- n2 )   Drop the first item below the top of stack.
000302  1  02 FA        
000304  1                  ; https://forth-standard.org/standard/core/NIP
000304  1  95 81        Nip:	LDAX ZW,ModBRPB,0	; pop n2
000306  1  BC           Nip3:	STAA ZW			; store as top-of-stack
000307  1  09 09        	.dbyt INL_End		; return
000309  1               
000309  1               
000309  1  32 4E 69 70   FHdr '2Nip',0 ; ( d1 d2 -- d2 )
00030D  1  04 03 04     
000310  1  D5 81        TwoNip:	LDBX ZW,ModBRPB,0	; pop d2.hi
000312  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
000314  1  FC           	STBA ZW			; store d.hi
000315  1  B5 88 02     	STAX ZW,ModNBRB,2	; store d.lo
000318  1  09           	RSR
000319  1               
000319  1               
000319  1               	.if 0
000319  1                FHdr 'Tuck',0 ; ( x1 x2 -- x2 x1 x2 )
000319  1                  ; Copy the first (top) stack item below the second stack item.
000319  1                  ; https://forth-standard.org/standard/core/TUCK
000319  1               Tuck:	LDAX ZW,ModBRPB,0	; pop x2
000319  1               	LDBA ZW			; get x1
000319  1               	STAA ZW
000319  1               	STBX ZW,ModBMRB,0
000319  1               	STAX ZW,ModBMRB,0
000319  1               	RSR
000319  1               	.endif
000319  1               
000319  1               
000319  1  4D 69 6E 03   FHdr 'Min',0 ; ( n1 n2 -- n3 )	Leave the smaller of two numbers.
00031D  1  03 10        
00031F  1                  ; https://forth-standard.org/standard/core/MIN
00031F  1  95 81        Min:	LDAX ZW,ModBRPB,0	; pop n2
000321  1  DC           	LDBA ZW			; get n1
000322  1  59           	SAB			; B=A-B
000323  1  12 0F        	BF Max3			; overflow?
000325  1  16 DF        Min3:	BM Nip3			; keep n2, return
000327  1  09           	RSR			; return
000328  1               
000328  1               
000328  1  4D 61 78 03   FHdr 'Max',0 ; ( n1 n2 -- n3 )	Leave the greater of two numbers.
00032C  1  03 1F        
00032E  1                  ; https://forth-standard.org/standard/core/MAX
00032E  1  95 81        Max:	LDAX ZW,ModBRPB,0	; pop n2
000330  1  DC           	LDBA ZW			; get n1
000331  1  59           	SAB			; B=A-B
000332  1  12 F1        	BF Min3			; overflow?
000334  1  17 D0        Max3:	BP Nip3			; keep n2, return
000336  1  09           	RSR			; return
000337  1               
000337  1               
000337  1  44 4D 61 78   FHdr 'DMax',0 ; ( d1 d2 -- d )
00033B  1  04 03 2E     
00033E  1                  ; https://forth-standard.org/standard/double/DMAX
00033E  1  95 81        DMax:	LDAX ZW,ModBRPB,0	; pop d2.hi
000340  1  5C           	XAY
000341  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
000343  1  DC           	LDBA ZW			; get d1.hi
000344  1  51 62        	SUB BW,YW		; compare hi words
000346  1  15 07        	BNZ @3
000348  1  D5 88 02     	LDBX ZW,ModNBRB,2	; get d1.lo
00034B  1  59           	SAB
00034C  1  10 05        	BL DMax7
00034E  1  09           	RSR
00034F  1               
00034F  1  12 23        @3:	BF DMin3
000351  1  16 06        DMax3:	BM DMax9
000353  1  55 62        DMax7:	XFR BW,YW		; store d.hi
000355  1  FC           	STBA ZW
000356  1  B5 88 02     	STAX ZW,ModNBRB,2	; store d.lo
000359  1  09           DMax9:	RSR
00035A  1               
00035A  1               
00035A  1  44 4D 69 6E   FHdr 'DMin',0 ; ( d1 d2 -- d )
00035E  1  04 03 3E     
000361  1                  ; https://forth-standard.org/standard/double/DMIN
000361  1  95 81        DMin:	LDAX ZW,ModBRPB,0	; pop d2.hi
000363  1  5C           	XAY
000364  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
000366  1  DC           	LDBA ZW			; get d1.hi
000367  1  51 62        	SUB BW,YW		; compare hi words
000369  1  15 07        	BNZ @3
00036B  1  D5 88 02     	LDBX ZW,ModNBRB,2	; get d1.lo
00036E  1  59           	SAB
00036F  1  11 E2        	BNL DMax7
000371  1  09           	RSR
000372  1               
000372  1  12 DD        @3:	BF DMax3
000374  1  16 DD        DMin3:	BM DMax7
000376  1  09           	RSR
000377  1               
000377  1               
000377  1               	.if 0
000377  1                FHdr 'Within',0 ; ( n1 | u1 n2 | u2 n3 | u3 -- flag )
000377  1                  ; Perform a comparison of a test value n1 | u1 with a lower limit n2 | u2 and an upper limit n3 | u3,
000377  1                  ; returning true if either (n2 | u2 < n3 | u3 and (n2 | u2 <= n1 | u1 and n1 | u1 < n3 | u3)) or
000377  1                  ; (n2 | u2 > n3 | u3 and (n2 | u2 <= n1 | u1 or n1 | u1 < n3 | u3)) is true, returning false otherwise.
000377  1                  ; An ambiguous condition exists n1 | u1, n2 | u2, and n3 | u3 are not all the same type.
000377  1                  ; https://forth-standard.org/standard/core/WITHIN
000377  1               Within:	JSRD Abort ;???
000377  1               	.endif
000377  1               
000377  1               
000377  1               ; Note that top-of-return-stack lives in X in the calling routine,
000377  1               ; so inline code is not R@="LDAA SW", >R="STAX SW,ModBMRB,0", R>="LDAX SW,ModBRPB,0"
000377  1               
000377  1  52 40 02 03   FHdr 'R@',0 ; ( R: n -- n ) ( -- n )  Copy the top of the return stack to the param stack.
00037B  1  61           
00037C  1                  ; https://forth-standard.org/standard/core/RFetch
00037C  1  9D           RAt:	LDAA SW			; get top of return stack of my caller
00037D  1  B5 82        	STAX ZW,ModBMRB,0	; push it
00037F  1  09           	RSR			; return
000380  1               
000380  1               	.if 0
000380  1                FHdr 'R',0 ; ( -- n )  FIG alias
000380  1               	JMPR RAt
000380  1               	.endif
000380  1               
000380  1               
000380  1  52 3E 02 03   FHdr 'R>',0 ; ( R: n -- ) ( -- n )  https://forth-standard.org/standard/core/Rfrom
000384  1  7C           
000385  1                  ; Remove the top value from the return stack and leave it on the param stack.
000385  1                  ; See >R and R@
000385  1  95 A1        RFrom:	LDAX SW,ModBRPB,0	; pop return stack, skipping my return addr in X
000387  1  B5 82        	STAX ZW,ModBMRB,0	; push n
000389  1  09           	RSR
00038A  1               
00038A  1               
00038A  1  3E 52 02 03   FHdr '>R',0 ; ( n -- ) ( R: -- n )   https://forth-standard.org/standard/core/toR
00038E  1  85           
00038F  1                  ; Remove a numbef from the computation stack and place as the most accessable
00038F  1                  ; on the return stack.  Use should be balanced with R> in the same definition.
00038F  1                  ; https://forth-standard.org/standard/core/toR
00038F  1  95 81        ToR:	LDAX ZW,ModBRPB,0	; pop n
000391  1  B5 A2        	STAX SW,ModBMRB,0	; push n on return stack
000393  1  09           	RSR
000394  1               
000394  1               
000394  1  32 3E 52 03   FHdr '2>R',0 ; ( d -- ) ( R: -- d )
000398  1  03 8F        
00039A  1                  ; https://forth-standard.org/standard/core/TwotoR
00039A  1  95 81        TwoToR:	LDAX ZW,ModBRPB,0	; pop d.hi
00039C  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d.lo
00039E  1  7E 03        	PUSH AH,4		; push d.lo & d.hi
0003A0  1  09           	RSR
0003A1  1               
0003A1  1               
0003A1  1  32 52 40 03   FHdr '2R@',0 ; ( -- d ) ( R: d -- d )
0003A5  1  03 9A        
0003A7  1                  ; https://forth-standard.org/standard/core/TwoRFetch
0003A7  1  DD           TwoRAt:	LDBA SW			; get d.hi
0003A8  1  95 A8 02     	LDAX SW,ModNBRB,2	; get d.lo
0003AB  1  71 02 EE     	JMPD PushBA
0003AE  1               
0003AE  1               
0003AE  1  32 52 3E 03   FHdr '2R>',0 ; ( R: d -- ) ( -- d )
0003B2  1  03 A7        
0003B4  1                  ; https://forth-standard.org/standard/core/TwoRfrom
0003B4  1               TwoRFrom:
0003B4  1  D5 A1        	LDBX SW,ModBRPB,0	; pop d.hi
0003B6  1  95 A1        	LDAX SW,ModBRPB,0	; pop d.lo
0003B8  1  71 02 EE     	JMPD PushBA
0003BB  1               
0003BB  1               
0003BB  1               	.if 0
0003BB  1               
0003BB  1                FHdr 'NR>',0
0003BB  1                  ; Interpretation:
0003BB  1                  ;   Interpretation semantics for this word are undefined.
0003BB  1                  ; Execution:
0003BB  1                  ;   ( -- i * x +n ) ( R: j * x +n -- )
0003BB  1                  ;   Retrieve the items previously stored by an invocation of N>R. n is the number of items placed on the data stack.
0003BB  1                  ;   It is an ambiguous condition if NR> is used with data not stored by N>R.
0003BB  1                  ; https://forth-standard.org/standard/tools/NRfrom
0003BB  1               NRFrom:
0003BB  1               	JSRD Abort ;???
0003BB  1               
0003BB  1               
0003BB  1                FHdr 'N>R',0
0003BB  1                  ; Interpretation:
0003BB  1                  ;   Interpretation semantics for this word are undefined.
0003BB  1                  ; Execution:
0003BB  1                  ;   ( i * n +n -- ) ( R: -- j * x +n )
0003BB  1                  ;   Remove n+1 items from the data stack and store them for later retrieval by NR>.
0003BB  1                  ;   The return stack may be used to store the data. Until this data has been retrieved by NR>:
0003BB  1                  ;   * this data will not be overwritten by a subsequent invocation of N>R and
0003BB  1                  ;   * a program may not access data placed on the return stack before the invocation of N>R.
0003BB  1                  ; https://forth-standard.org/standard/tools/NtoR
0003BB  1               NToR:
0003BB  1               	JSRD Abort ;???
0003BB  1               
0003BB  1               	.endif
0003BB  1               
0003BB  1               
0003BB  1  49 6E 76 65   FHdr 'Invert',ha_inline ; ( n1 -- n2 ) Invert bits
0003BF  1  72 74 86 03  
0003C3  1  B4           
0003C4  1                  ; see 0= for logical negate
0003C4  1                  ; https://forth-standard.org/standard/core/INVERT
0003C4  1  9C           Invert:	LDAA ZW
0003C5  1  33 00        	IVR AW,0
0003C7  1  BC           	STAA ZW
0003C8  1  09 09        	.dbyt INL_End
0003CA  1               
0003CA  1               
0003CA  1  41 6E 64 83   FHdr 'And',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical and of n1 and n2 as n3.
0003CE  1  03 C4        
0003D0  1                  ; https://forth-standard.org/standard/core/AND
0003D0  1  95 81        AndD:	LDAX ZW,ModBRPB,0	; pop n2
0003D2  1  DC           	LDBA ZW			; get n1
0003D3  1  5A           	NAB			; and
0003D4  1  FC           	STBA ZW			; store result
0003D5  1  09 09        	.dbyt INL_End		; return
0003D7  1               
0003D7  1               
0003D7  1  4F 72 82 03   FHdr 'Or',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical or of two 16 bit values.
0003DB  1  D0           
0003DC  1                  ; https://forth-standard.org/standard/core/OR
0003DC  1  95 81        Or:	LDAX ZW,ModBRPB,0	; pop n2
0003DE  1  DC           	LDBA ZW			; get n1
0003DF  1  53 02        	ORI BW,AW
0003E1  1  FC           	STBA ZW			; store result
0003E2  1  09 09        	.dbyt INL_End		; return
0003E4  1               
0003E4  1               
0003E4  1  58 6F 72 83   FHdr 'Xor',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical exclusive-or of two values.
0003E8  1  03 DC        
0003EA  1                  ; https://forth-standard.org/standard/core/XOR
0003EA  1  95 81        Xor:	LDAX ZW,ModBRPB,0	; pop n2
0003EC  1  DC           XorA:	LDBA ZW			; get n1
0003ED  1  54 02        	ORE BW,AW
0003EF  1  FC           	STBA ZW			; store result
0003F0  1  09 09        	.dbyt INL_End		; return
0003F2  1               
0003F2  1               
0003F2  1  32 2A 82 03   FHdr '2*',ha_inline ; ( x1 -- x2 )  signed multiply by 2 (signed left shift)
0003F6  1  EA           
0003F7  1                  ; x2 is the result of shifting x1 one bit toward the most-significant bit, filling the vacated
0003F7  1                  ; least-significant bit with zero.
0003F7  1                  ; https://forth-standard.org/standard/core/TwoTimes
0003F7  1               TwoStar:
0003F7  1  9C           	LDAA ZW
0003F8  1  3D           	SLA
0003F9  1  BC           	STAA ZW
0003FA  1  09 09        	.dbyt INL_End
0003FC  1               
0003FC  1               
0003FC  1  44 32 2A 03   FHdr 'D2*',0 ; ( xd1 -- xd2 )  signed double multiply by 2 (signed left shift)
000400  1  03 F7        
000402  1                  ; xd2 is the result of shifting xd1 one bit toward the most-significant bit, filling the vacated
000402  1                  ; least-significant bit with zero.
000402  1                  ; https://forth-standard.org/standard/double/DTwoTimes
000402  1               DTwoStar:
000402  1  95 88 02     	LDAX ZW,ModNBRB,2
000405  1  3D           	SLA
000406  1  B5 88 02     	STAX ZW,ModNBRB,2
000409  1  9C           	LDAA ZW
00040A  1  37 00        	RLR AW,1
00040C  1  BC           	STAA ZW
00040D  1  09           	RSR
00040E  1               
00040E  1               
00040E  1  32 2F 82 04   FHdr '2/',ha_inline ; ( x1 -- x2 )  signed divide by  (signed right shift)
000412  1  02           
000413  1                  ; x2 is the result of shifting x1 one bit toward the least-significant bit, leaving the most significant
000413  1                  ; bit unchanged.
000413  1                  ; https://forth-standard.org/standard/core/TwoDiv
000413  1               TwoSlash:
000413  1  9C           	LDAA ZW
000414  1  3C           	SRA
000415  1  BC           	STAA ZW
000416  1  09 09        	.dbyt INL_End
000418  1               
000418  1               
000418  1  44 32 2F 03   FHdr 'D2/',0 ; ( xd1 -- xd2 )  signed double divide by 2 (signed right shift)
00041C  1  04 13        
00041E  1                  ; xd2 is the result of shifting xd1 one bit toward the least-significant bit, leaving the most significant
00041E  1                  ; bit unchanged.
00041E  1                  ; https://forth-standard.org/standard/double/DTwoDiv
00041E  1  9C           DDiv2:	LDAA ZW
00041F  1  3C           	SRA
000420  1  BC           	STAA ZW
000421  1  95 88 02     	LDAX ZW,ModNBRB,2
000424  1  36 00        	RRR AW,1
000426  1  B5 88 02     	STAX ZW,ModNBRB,2
000429  1  09           	RSR
00042A  1               
00042A  1               
00042A  1  55 32 2F 83   FHdr 'U2/',ha_inline ; ( u -- u/2 )   Unsigned divide by two (logical right shift)
00042E  1  04 1E        
000430  1                  ; https://forth-standard.org/standard/core/TwoDiv "Shr"
000430  1  9C           UDiv2:	LDAA ZW
000431  1  07           	RL
000432  1  36 00        	RRR AW,1
000434  1  BC           	STAA ZW
000435  1  09 09        	.dbyt INL_End
000437  1               
000437  1               
000437  1               	.if 0
000437  1                FHdr 'UD2/',0 ; ( ud1 -- ud2 ) unsigned double divide by 2 (logical right shift)
000437  1               	JSRR UDiv2
000437  1               	LDAX ZW,ModNBRB,2
000437  1               	RRR AW,1
000437  1               	STAX ZW,ModNBRB,2
000437  1               	RSR
000437  1               	.endif
000437  1               
000437  1               
000437  1  72 6F 72 83   FHdr 'ror',ha_inline ; ( x1 -- x2 )   Logical right-rotation of one bit-place
00043B  1  04 30        
00043D  1  9C           	LDAA ZW
00043E  1  36 00        	RRR AW,1
000440  1  BC           	STAA ZW
000441  1  09 09        	.dbyt INL_End
000443  1               
000443  1               
000443  1  72 6F 6C 83   FHdr 'rol',ha_inline ; ( x1 -- x2 )   Logical left-rotation of one bit-place
000447  1  04 3D        
000449  1  9C           	LDAA ZW
00044A  1  37 00        	RLR AW,1
00044C  1  BC           	STAA ZW
00044D  1  09 09        	.dbyt INL_End
00044F  1               
00044F  1               
00044F  1               	.if 0
00044F  1               
00044F  1                FHdr 'LShift',0 ; ( x1 u -- x2 )  Perform a logical left shift of u bit-places on x1, giving x2.
00044F  1                  ; Put zeroes into the least significant bits vacated by the shift.
00044F  1                  ; An ambiguous condition exists if u is greater than or equal to the number of bits in a cell.
00044F  1                  ; https://forth-standard.org/standard/core/LSHIFT
00044F  1               LShift:	LDAX ZW,ModBRPB,0	; pop u
00044F  1               	BZ @9
00044F  1               	LDBA ZW			; get x1
00044F  1               @2:	SLR BW,1
00044F  1               	DCAB
00044F  1               	BNZ @2
00044F  1               	STBA ZW			; save x2
00044F  1               @9:	RSR
00044F  1               
00044F  1               
00044F  1                FHdr 'RShift',0 ; ( x1 u -- x2 )  Perform a logical right shift of u bit-places on x1, giving x2.
00044F  1                  ; Put zeroes into the most significant bits vacated by the shift.
00044F  1                  ; An ambiguous condition exists if u is greater than or equal to the number of bits in a cell.
00044F  1                  ; https://forth-standard.org/standard/core/RSHIFT
00044F  1               RShift:	LDAX ZW,ModBRPB,0	; pop u
00044F  1               	BZ @9
00044F  1               	LDBA ZW			; get x1
00044F  1               @2:	RL
00044F  1               	RRR BW,1
00044F  1               	DCAB
00044F  1               	BNZ @2
00044F  1               	STBA ZW			; save x2
00044F  1               @9:	RSR
00044F  1               
00044F  1               	.endif
00044F  1               
00044F  1               
00044F  1  31 2B 82 04   FHdr '1+',ha_inline ; ( n1 -- n2 )  Increment n1 by 1
000453  1  49           
000454  1                  ; https://forth-standard.org/standard/core/OnePlus
000454  1               OnePlus:
000454  1  9C           	LDAA ZW			; get n1
000455  1  38           	INA
000456  1  BC           	STAA ZW			; store n2
000457  1  09 09        	.dbyt INL_End		; return
000459  1               
000459  1               
000459  1  32 2B 82 04   FHdr '2+',ha_inline ; ( n1 -- n2 )  Increment n1 by 2
00045D  1  54           
00045E  1               TwoPlus:
00045E  1  9C           	LDAA ZW			; get n1
00045F  1  30 01        	INR AW,2
000461  1  BC           	STAA ZW			; store n2
000462  1  09 09        	.dbyt INL_End		; return
000464  1               
000464  1               
000464  1  31 2D 82 04   FHdr '1-',ha_inline ; ( n1 -- n2 )  Decrement n1 by 1
000468  1  5E           
000469  1                  ; https://forth-standard.org/standard/core/OneMinus
000469  1               OneMinus:
000469  1  9C           	LDAA ZW			; get n1
00046A  1  39           	DCA
00046B  1  BC           	STAA ZW			; store n2
00046C  1  09 09        	.dbyt INL_End		; return
00046E  1               
00046E  1               
00046E  1  32 2D 82 04   FHdr '2-',ha_inline ; ( n1 -- n2 ) Decrement n1 by 2
000472  1  69           
000473  1               TwoMinus:
000473  1  9C           	LDAA ZW			; get n1
000474  1  31 01        	DCR AW,2		; subtract 2
000476  1  BC           	STAA ZW			; store n2
000477  1  09 09        	.dbyt INL_End
000479  1               
000479  1               
000479  1  2B 81 04 73   FHdr '+',ha_inline ; ( n1 n2 -- n_sum )  n_sum = n1 + n2
00047D  1                  ; https://forth-standard.org/standard/core/Plus
00047D  1  95 81        Plus:	LDAX ZW,ModBRPB,0	; pop n2
00047F  1  DC           PlusA:	LDBA ZW			; get n1
000480  1  58           	AAB
000481  1  FC           	STBA ZW			; store n_sum
000482  1  09 09        	.dbyt INL_End		; return
000484  1               
000484  1               
000484  1  4D 2B 02 04   FHdr 'M+',0 ; ( d1 n -- d2 )  d2 = d1 + signed(n)
000488  1  7D           
000489  1                 ; https://forth-standard.org/standard/double/MPlus
000489  1  95 81        MPlus:	LDAX ZW,ModBRPB,0	; pop n
00048B  1  D5 88 02     MPlusA:	LDBX ZW,ModNBRB,2	; get d1.lo
00048E  1  58           	AAB
00048F  1  F5 88 02     	STBX ZW,ModNBRB,2
000492  1  DC           	LDBA ZW			; get d1.hi
000493  1  11 02        	BNL @4			; carry?
000495  1  30 20        	INR BW,1
000497  1  5C           @4:	XAY			; test n sign
000498  1  17 02        	BP @6
00049A  1  31 20        	DCR BW,1
00049C  1  FC           @6:	STBA ZW
00049D  1  09           	RSR
00049E  1               
00049E  1               
00049E  1  44 2B 02 04   FHdr 'D+',0 ; ( d1 d2 -- d_sum )  d_sum = d1 + d2
0004A2  1  89           
0004A3  1  95 81        DPlus:	LDAX ZW,ModBRPB,0 ; pop d2.hi
0004A5  1  5C           	XAY
0004A6  1  95 81        	LDAX ZW,ModBRPB,0 ; pop d2.lo
0004A8  1  D5 88 02     	LDBX ZW,ModNBRB,2 ; get d1.lo
0004AB  1  58           	AAB
0004AC  1  F5 88 02     	STBX ZW,ModNBRB,2 ; store d1.lo
0004AF  1  11 02        	BNL @2		; carry?
0004B1  1  30 60        	INR YW,1
0004B3  1               @2:
0004B3  1  9C           	LDAA ZW		; get d1.hi
0004B4  1  50 60        	ADD AW,YW
0004B6  1  BC           	STAA ZW		; store d1.hi
0004B7  1  09           	RSR
0004B8  1               
0004B8  1               
0004B8  1  2D 81 04 A3   FHdr '-',ha_inline ; ( n1 n2 -- n_diff )  n_diff=n1-n2
0004BC  1                  ; https://forth-standard.org/standard/core/Minus
0004BC  1               Subtract:
0004BC  1  D5 81        	LDBX ZW,ModBRPB,0 ; pop n2
0004BE  1  9C           	LDAA ZW		; get n1
0004BF  1  59           	SAB
0004C0  1  FC           	STBA ZW		; store n_diff
0004C1  1  09 09        	.dbyt INL_End
0004C3  1               
0004C3  1               
0004C3  1  44 2D 02 04   FHdr 'D-',0 ; ( d1 d2 -- d )  d=d1-d2
0004C7  1  BC           
0004C8  1                  ; https://forth-standard.org/standard/double/DMinus
0004C8  1               DMinus:
0004C8  1                   .if 1
0004C8  1               	; short slower version
0004C8  1  7B 2F        	JSRR DNegate
0004CA  1  73 D7        	JMPR DPlus
0004CC  1                   .else
0004CC  1               	; long faster version
0004CC  1               	LDAX ZW,ModBRPB,0	; Y= d2.hi
0004CC  1               	XAY
0004CC  1               	LDBX ZW,ModBRPB,0	; B= dl.lo
0004CC  1               	LDAX ZW,ModNBRB,2	; A= d1.lo
0004CC  1               	SAB
0004CC  1               	STBX ZW,ModNBRB,2
0004CC  1               	LDAA ZW			; A= d1.hi
0004CC  1               	XFR BW,YW
0004CC  1               	SAB
0004CC  1               	STAA ZW
0004CC  1               	RSR
0004CC  1                   .endif
0004CC  1               
0004CC  1               
0004CC  1  4E 65 67 61   FHdr 'Negate',ha_inline ; ( n -- n )  Leave the two's complement of a number.
0004D0  1  74 65 86 04  
0004D4  1  C8           
0004D5  1                  ; https://forth-standard.org/standard/core/NEGATE
0004D5  1  DC           Negate:	LDBA ZW		; get n
0004D6  1  33 21        Negat1:	IVR BW,1
0004D8  1  FC           	STBA ZW		; store n
0004D9  1  09 09        	.dbyt INL_End
0004DB  1               
0004DB  1               
0004DB  1               	.if 0
0004DB  1                FHdr "Minus",0 ; ( n -- n )  FIG alias
0004DB  1               	JMPR Negate
0004DB  1               	.endif
0004DB  1               
0004DB  1               
0004DB  1  41 62 73 03   FHdr 'Abs',0 ; ( n -- u )  Leave the absolute value of n as u.
0004DF  1  04 D5        
0004E1  1  DC           Abs:	LDBA ZW		; n<0?
0004E2  1  16 F2        	BM Negat1	;   negate it & return
0004E4  1  09           	RSR		; return
0004E5  1               
0004E5  1               
0004E5  1  2B 2D 02 04   FHdr '+-',0 ; ( n1 n2 -- n3 )  Apply the sign of n2 to n1, which is left as n3.
0004E9  1  E1           
0004EA  1  95 81        PM:	LDAX ZW,ModBRPB,0 ; pop n2
0004EC  1  16 E7        PMP:	BM Negate	;   negate n1 & return
0004EE  1  09           	RSR		; return
0004EF  1               
0004EF  1               
0004EF  1  44 4E 65 67   FHdr 'DNegate',0 ; ( d1 -- d2 )  Convert d1 to its double number two's complement.
0004F3  1  61 74 65 07  
0004F7  1  04 EA        
0004F9  1                  ; https://forth-standard.org/standard/double/DNEGATE
0004F9  1  D5 88 02     DNegate: LDBX ZW,ModNBRB,2 ; get d1.lo
0004FC  1  3A           	CLA
0004FD  1  59           	SAB
0004FE  1  F5 88 02     	STBX ZW,ModNBRB,2 ; store d2.lo
000501  1  DC           	LDBA ZW		; get d1.hi
000502  1  10 01        	BL @3		; borrow?
000504  1  39           	DCA
000505  1               @3:
000505  1  59           	SAB
000506  1  FC           	STBA ZW		; store d2.hi
000507  1  09           	RSR
000508  1               
000508  1               
000508  1               	.if 0
000508  1                FHdr 'DMinus',0 ; ( d1 -- d2 )  FIG alias
000508  1               	JMPR DNegate
000508  1               	.endif
000508  1               
000508  1               
000508  1  44 41 62 73   FHdr 'DAbs',0 ; ( d -- ud )  Leave the absolute value ud of a double number.
00050C  1  04 04 F9     
00050F  1                  ; https://forth-standard.org/standard/double/DABS
00050F  1  8C           DAbs:	LDABA ZW	; d<0?
000510  1  16 E7        	BM DNegate	;   negate d & return
000512  1  09           	RSR		; return
000513  1               
000513  1               
000513  1  44 2B 2D 03   FHdr 'D+-',0 ; ( d1 n -- d2 )  Apply the sign of n to the doulbe number d1, leaving it as d2.
000517  1  05 0F        
000519  1                  ; https://forth-standard.org/standard/double/DPlus
000519  1  95 81        DPM:	LDAX ZW,ModBRPB,0 ; pop n
00051B  1  16 DC        DPMP:	BM DNegate	;   negate d1 & return
00051D  1  09           	RSR		; return
00051E  1               
00051E  1               
00051E  1               	.if 1
00051E  1               
00051E  1  46 61 6C 73   FHdr 'False',ha_inline ; ( -- false )  Return a false flag.
000522  1  65 85 05 19  
000526  1                  ; https://forth-standard.org/standard/core/FALSE
000526  1  3A           False:	CLA
000527  1  B5 82        	STAX ZW,ModBMRB,0
000529  1  09 09        	.dbyt INL_End
00052B  1               
00052B  1               
00052B  1  54 72 75 65   FHdr 'True',ha_inline ; ( -- true )  Return a true flag.
00052F  1  84 05 26     
000532  1                  ; https://forth-standard.org/standard/core/TRUE
000532  1  32 01        True:	CLR AW,1
000534  1  B5 82        	STAX ZW,ModBMRB,0
000536  1  09 09        	.dbyt INL_End
000538  1               
000538  1               	.endif
000538  1               
000538  1               
000538  1  30 3E 02 05   FHdr '0>',0 ; ( n -- f )  Leave a bool n>0
00053C  1  32           
00053D  1  9C           ZGt:	LDAA ZW			; test n
00053E  1  16 6F        	BM False0
000540  1  14 6D        	BZ False0
000542  1  73 5C        	JMPR True0
000544  1               
000544  1               
000544  1  30 3C 02 05   FHdr '0<',0 ; ( n -- f )  Leave a bool n<0
000548  1  3D           
000549  1                  ; https://forth-standard.org/standard/core/Zeroless
000549  1               ZLessThan:
000549  1  8C           	LDABA ZW		; test n
00054A  1  16 54        	BM True0
00054C  1  73 61        	JMPR False0
00054E  1               
00054E  1               
00054E  1  44 30 3C 03   FHdr 'D0<',0 ; ( d -- f ) f=(d<0)
000552  1  05 49        
000554  1                  ; https://forth-standard.org/standard/double/DZeroless
000554  1               DZLessThan:
000554  1  95 81        	LDAX ZW,ModBRPB,0	; pop d.hi
000556  1  16 48        	BM True0
000558  1  73 55        	JMPR False0
00055A  1               
00055A  1               
00055A  1  30 3D 02 05   FHdr '0=',0 ; ( n -- f )  Leave a bool n==0
00055E  1  54           
00055F  1                  ; https://forth-standard.org/standard/core/ZeroEqual
00055F  1  9C           ZEqual:	LDAA ZW			; test n
000560  1  14 3E        	BZ True0
000562  1  73 4B        	JMPR False0
000564  1               
000564  1               
000564  1  44 30 3D 03   FHdr 'D0=',0 ; ( d -- f ) Leave a bool d==0
000568  1  05 5F        
00056A  1                  ; https://forth-standard.org/standard/double/DZeroEqual
00056A  1               DZEqual:
00056A  1  95 81        	LDAX ZW,ModBRPB,0	; pop hi word
00056C  1  15 41        	BNZ False0
00056E  1  DC           	LDBA ZW			; get lo word
00056F  1  14 2F        	BZ True0
000571  1  73 3C        	JMPR False0
000573  1               
000573  1               
000573  1  44 3D 02 05   FHdr 'D=',0 ; ( d1 d2 -- f )  f=(d1==d2)  double equal
000577  1  6A           
000578  1                  ; https://forth-standard.org/standard/double/DEqual
000578  1  95 81        DEqual:	LDAX ZW,ModBRPB,0	; pop d2.hi
00057A  1  5C           	XAY
00057B  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
00057D  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d1.hi
00057F  1  51 62        	SUB BW,YW		; compare hi words
000581  1  15 2C        	BNZ False0
000583  1  DC           	LDBA ZW			; get d1.lo
000584  1  59           	SAB			; compare lo words
000585  1  15 28        	BNZ False0
000587  1  73 17        	JMPR True0
000589  1               
000589  1               
000589  1  3C 3E 02 05   FHdr '<>',0 ; ( x1 x2 -- flag)  https://forth-standard.org/standard/core/ne
00058D  1  78           
00058E  1                  ; https://forth-standard.org/standard/core/Zerone
00058E  1               NtoEqual:
00058E  1  95 81        	LDAX ZW,ModBRPB,0	; pop x2
000590  1  DC           	LDBA ZW			; get x1
000591  1  59           	SAB			; x2<>x1?
000592  1  15 0C        	BNZ True0
000594  1  FC           	STBA ZW			; flag=false
000595  1  09           	RSR
000596  1               
000596  1               
000596  1  3D 01 05 8E   FHdr '=',0 ; ( x1 x2 -- flag )  Leave a true flag if x1=x2; otherwise leave a false flag.
00059A  1                  ; https://forth-standard.org/standard/core/Equal
00059A  1  95 81        Equal:	LDAX ZW,ModBRPB,0	; pop x2
00059C  1  DC           	LDBA ZW			; get x1
00059D  1  59           	SAB			; x2==x1?
00059E  1  15 0F        	BNZ False0
0005A0  1  32 01        True0:	CLR AW,1		; flag=true
0005A2  1  BC           	STAA ZW
0005A3  1  09           	RSR
0005A4  1               
0005A4  1               
0005A4  1  55 3C 02 05   FHdr 'U<',0 ; ( u1 u2 -- f )  f=u1<u2 (unsigned compare)
0005A8  1  9A           
0005A9  1                  ; https://forth-standard.org/standard/core/Uless
0005A9  1               ULessThan:
0005A9  1  D5 81        	LDBX ZW,ModBRPB,0	; pop u2
0005AB  1  9C           	LDAA ZW			; get u1
0005AC  1  59           ULt3:	SAB			; n1<n2?
0005AD  1  11 F1        	BNL True0
0005AF  1  3A           False0:	CLA			; f=false
0005B0  1  BC           	STAA ZW
0005B1  1  09           	RSR
0005B2  1               
0005B2  1               
0005B2  1  55 3E 02 05   FHdr 'U>',0 ; ( u1 u2 -- f )  f=u1>u2 (unsigned compare)
0005B6  1  A9           
0005B7  1                  ; https://forth-standard.org/standard/core/Umore
0005B7  1               UGreaterThan:
0005B7  1  95 81        	LDAX ZW,ModBRPB,0	; pop u2
0005B9  1  DC           	LDBA ZW			; get u1
0005BA  1  73 F0        	JMPR ULt3
0005BC  1               
0005BC  1               
0005BC  1  3C 01 05 B7   FHdr '<',0 ; ( n1 n2 -- f )  f=n1<n2 (signed compare)
0005C0  1                  ; https://forth-standard.org/standard/core/less
0005C0  1               LessThan:
0005C0  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n2
0005C2  1  9C           	LDAA ZW			; get n1
0005C3  1  59           LT2:	SAB			; n1<n2?
0005C4  1  12 04        LT3:	BF @3			; overflow?
0005C6  1  16 D8        	BM True0
0005C8  1  73 E5        	JMPR False0
0005CA  1               
0005CA  1  16 E3        @3:	BM False0
0005CC  1  73 D2        	JMPR True0
0005CE  1               
0005CE  1               
0005CE  1  3C 3D 02 05   FHdr '<=',0 ; ( n1 n2 -- flag ) flag=n1<=n2 (signed compare)
0005D2  1  C0           
0005D3  1               LessEqual:
0005D3  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n2
0005D5  1  9C           	LDAA ZW			; get n1
0005D6  1  59           LE3:	SAB			; n1<n2?
0005D7  1  15 EB        	BNZ LT3
0005D9  1  73 C5        	JMPR True0
0005DB  1               
0005DB  1               
0005DB  1  3E 01 05 D3   FHdr '>',0 ; ( n1 n2 -- f )  f=n1>n2 (signed compare)
0005DF  1                  ; https://forth-standard.org/standard/core/less
0005DF  1               GreaterThan:
0005DF  1  95 81        	LDAX ZW,ModBRPB,0	; pop n2
0005E1  1  DC           	LDBA ZW			; get n1
0005E2  1  73 DF        	JMPR LT2
0005E4  1               
0005E4  1               
0005E4  1  3E 3D 02 05   FHdr '>=',0 ; ( n1 n2 -- f )  f=n1>=n2 (signed compare)
0005E8  1  DF           
0005E9  1               GreaterEqual:
0005E9  1  95 81        	LDAX ZW,ModBRPB,0	; pop n2
0005EB  1  DC           	LDBA ZW			; get n1
0005EC  1  73 E8        	JMPR LE3
0005EE  1               
0005EE  1               
0005EE  1  44 55 3C 03   FHdr 'DU<',0 ; ( d1 d2 -- f )  f=d1<d2 (unsigned compare)
0005F2  1  05 E9        
0005F4  1                  ; https://forth-standard.org/standard/double/DUless
0005F4  1               DULessThan:
0005F4  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d2.hi
0005F6  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
0005F8  1  5C           	XAY
0005F9  1  95 81        	LDAX ZW,ModBRPB,0	; pop d1.hi
0005FB  1  59           	SAB
0005FC  1  15 03        	BNZ @7
0005FE  1  9C           	LDAA ZW			; get d1.lo
0005FF  1  51 06        	SUB YW,AW
000601  1  11 9D        @7:	BNL True0
000603  1  73 AA        	JMPR False0
000605  1               
000605  1               
000605  1  44 3C 02 05   FHdr 'D<',0 ; ( d1 d2 -- f )  f=d1<d2 (signed compare)
000609  1  F4           
00060A  1                  ; https://forth-standard.org/standard/double/Dless
00060A  1               DLessThan:
00060A  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d2.hi
00060C  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
00060E  1  5C           	XAY
00060F  1  95 81        	LDAX ZW,ModBRPB,0	; pop d1.hi
000611  1  59           	SAB
000612  1  15 07        	BNZ @10
000614  1  9C           	LDAA ZW			; get d1.lo
000615  1  51 06        	SUB YW,AW
000617  1  11 87        	BNL True0
000619  1  73 94        	JMPR False0
00061B  1               
00061B  1  13 05        @10:	BNF @14
00061D  1  16 90        	BM False0
00061F  1  71 05 A0     	JMPD True0
000622  1               
000622  1  17 8B        @14:	BP False0
000624  1  71 05 A0     	JMPD True0
000627  1               
000627  1               
000627  1  44 3E 53 83   FHdr 'D>S',ha_inline ; ( d -- n )  Convert double to single
00062B  1  06 0A        
00062D  1                  ; https://forth-standard.org/standard/double/DtoS
00062D  1  30 81        DToS:	INR ZW,2
00062F  1  09 09        	.dbyt INL_End
000631  1               
000631  1               
000631  1  53 3E 44 03   FHdr 'S>D',0 ; ( n -- d )  Sign extend a single number to form a double number.
000635  1  06 2D        
000637  1                  ; https://forth-standard.org/standard/core/StoD
000637  1  3A           SToD:	CLA			; assume hi word is 0
000638  1  DC           	LDBA ZW			; n<0?
000639  1  17 01        	BP @2
00063B  1  39           	DCA			;   change to -1
00063C  1  B5 82        @2:	STAX ZW,ModBMRB,0	; push hi word
00063E  1  09           	RSR
00063F  1               
00063F  1               
00063F  1               	.if 0
00063F  1                FHdr 'S->D',0 ; ( n -- d )  FIG alias
00063F  1               	JMPR SToD
00063F  1               	.endif
00063F  1               
00063F  1               
00063F  1  55 4D 2A 03   FHdr 'UM*',0 ; ( u1 u2 -- ud )  ud = unsigned double number product of 2 unsigned numbers.
000643  1  06 37        
000645  1                  ; https://forth-standard.org/standard/core/UMTimes
000645  1  6D A2        UMStar:	STXX SW,ModBMRB,0	; save X
000647  1  95 88 02     	LDAX ZW,ModNBRB,2	; Y=u1
00064A  1  5C           	XAY
00064B  1  9C           	LDAA ZW			; A=u2
00064C  1  32 20        	CLR BW,0		; product.hi=0
00064E  1  60 00 10     	LDXL 16			; for 16 bits
000651  1  07           	RL			; pre-shift u2
000652  1  36 00        	RRR AW,1
000654  1  11 02        @3:	BNL @4			;   set?
000656  1  50 62        	ADD BW,YW		;     add u1 to product.hi
000658  1  36 20        @4:	RRR BW,1		;   rotate product right 1 bit
00065A  1  36 00        	RRR AW,1
00065C  1  3F           	DCX			;  next bit
00065D  1  15 F5        	BNZ @3
00065F  1  FC           	STBA ZW			; store product.hi
000660  1  B5 88 02     	STAX ZW,ModNBRB,2	; store product.lo
000663  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
000665  1  09           	RSR			; return
000666  1               
000666  1               
000666  1               	.if 0
000666  1                FHdr 'U*',0 ; ( u1 u2 -- ud )  FIG alias
000666  1               	JMPR UMStar
000666  1               	.endif
000666  1               
000666  1                 .if 0
000666  1               UMStarTest1:
000666  1               	LDAL 1
000666  1               	STAX ZW,ModBMRB,0
000666  1               	LDAL 1
000666  1               	STAX ZW,ModBMRB,0
000666  1               	JSRD UMStar
000666  1               	LDAX ZW,ModBRPB,0
000666  1               	LDBL 0
000666  1               	SAB
000666  1               	BZ @13
000666  1               	HLT
000666  1               @13:
000666  1               	LDAX ZW,ModBRPB,0
000666  1               	LDBL 1
000666  1               	SAB
000666  1               	BZ @14
000666  1               	HLT
000666  1               @14:
000666  1               
000666  1               	LDAL $9876
000666  1               	STAX ZW,ModBMRB,0
000666  1               	LDAL $a987
000666  1               	STAX ZW,ModBMRB,0
000666  1               	JSRD UMStar
000666  1               	LDAX ZW,ModBRPB,0
000666  1               	LDBL $64f6
000666  1               	SAB
000666  1               	BZ @23
000666  1               	HLT
000666  1               @23:
000666  1               	LDAX ZW,ModBRPB,0
000666  1               	LDBL $4c3a
000666  1               	SAB
000666  1               	BZ @24
000666  1               	HLT
000666  1               @24:
000666  1               
000666  1               	RSR
000666  1                 .endif
000666  1               
000666  1               
000666  1  55 4D 2F 4D   FHdr 'UM/Mod',0 ; ( ud_dividend u_divisor -- u_rem u_quot )
00066A  1  6F 64 06 06  
00066E  1  45           
00066F  1                  ; Leave the unsigned remainder and unsigned quotient from the unsigned
00066F  1                  ; double dividend and unsigned divisor.
00066F  1                  ; https://forth-standard.org/standard/core/UMDivMOD
00066F  1               UMSlashMod:
00066F  1  95 81        	LDAX ZW,ModBRPB,0	; pop divisor into A
000671  1  33 01        	IVR AW,1		; negate
000673  1  6D A2        	STXX SW,ModBMRB,0	; save X
000675  1  55 82        	XFR BW,ZW		; save Z
000677  1  F5 A2        	STBX SW,ModBMRB,0
000679  1  D5 88 02     	LDBX ZW,ModNBRB,2	; Y=dividend.lo
00067C  1  55 26        	XFR YW,BW
00067E  1  65 80        	LDXX ZW,ModBRB,0	; X=dividend.hi
000680  1               
000680  1  C0 10        	LDBBL 16		; for 16 bits
000682  1  45 39        	XFRB ZL,BL
000684  1  35 60        	SLR YW,1		; shift dividend.lo left
000686  1  37 40        @2:	RLR XW,1		;   rotate dividend.hi left
000688  1  10 1B        	BL @7			;   dividend overflowed?
00068A  1  55 42        	XFR BW,XW
00068C  1  58           	AAB			;   dividend.hi>=divisor?
00068D  1  14 02        	BZ @3
00068F  1  11 02        	BNL @4
000691  1  55 24        @3:	XFR XW,BW		;     dividend.hi-=divisor
000693  1  37 60        @4:	RLR YW,1		;   shift into quotient, start dividend shift
000695  1  21 90        	DCRB ZL			;  next bit
000697  1  15 ED        	BNZ @2
000699  1  95 A1        	LDAX SW,ModBRPB,0	; restore Z
00069B  1  5E           	XAZ
00069C  1  6D 88 02     	STXX ZW,ModNBRB,2	; save remainder
00069F  1  55 60        	XFR AW,YW
0006A1  1  BC           	STAA ZW			; save quotient
0006A2  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
0006A4  1  09           	RSR			; return
0006A5  1               
0006A5  1               @7:				; dividend overflowed, so it's always bigger than the divisor
0006A5  1  55 42        	XFR BW,XW
0006A7  1  58           	AAB			; dividend.hi-=divisor
0006A8  1  06           	SL			; it always fits, because the shifted out bit was set
0006A9  1  73 E6        	JMPR @3
0006AB  1               
0006AB  1               
0006AB  1               	.if 0
0006AB  1                FHdr 'U/',0 ; FIG alias
0006AB  1               	JMPR UMSlashMod
0006AB  1               	.endif
0006AB  1               
0006AB  1               
0006AB  1               	.if 0
0006AB  1               UMSlashModTest1:
0006AB  1               	LDAL $5678		; dividend = $12345678
0006AB  1               	STAX ZW,ModBMRB,0
0006AB  1               	LDAL $1234
0006AB  1               	STAX ZW,ModBMRB,0
0006AB  1               	LDAL $6789		; divisor = $6789
0006AB  1               	STAX ZW,ModBMRB,0
0006AB  1               	JSRD UMSlashMod
0006AB  1               	LDAX ZW,ModBRPB,0	; quotient
0006AB  1               	LDBL $2d03
0006AB  1               	SAB
0006AB  1               	BZ @3
0006AB  1               	HLT
0006AB  1               @3:
0006AB  1               	LDAX ZW,ModBRPB,0	; remainder
0006AB  1               	LDBL $add
0006AB  1               	SAB
0006AB  1               	BZ @4
0006AB  1               	HLT
0006AB  1               @4:
0006AB  1               	RSR
0006AB  1               	.endif
0006AB  1               
0006AB  1               
0006AB  1  4D 2A 02 06   FHdr 'M*',0 ; ( n1 n2 -- d )
0006AF  1  6F           
0006B0  1                  ; A mixed magnitude math operations which leaves the double number signed
0006B0  1                  ; product of two signed integers.
0006B0  1                  ; https://forth-standard.org/standard/core/MTimes
0006B0  1  9C           MStar:	LDAA ZW			; save result sign
0006B1  1  D5 88 02     	LDBX ZW,ModNBRB,2
0006B4  1  54 02        	ORE BW,AW
0006B6  1  F5 A2        	STBX SW,ModBMRB,0
0006B8  1  79 04 E1     	JSRD Abs		; n2=abs(n2)
0006BB  1  D5 88 02     	LDBX ZW,ModNBRB,2	; n1<0?
0006BE  1  17 05        	BP @4
0006C0  1  3A           	CLA			;   n1=-n1
0006C1  1  59           	SAB
0006C2  1  F5 88 02     	STBX ZW,ModNBRB,2
0006C5  1               @4:
0006C5  1  79 06 45     	JSRD UMStar		; unsigned multiply giving double product
0006C8  1  95 A1        	LDAX SW,ModBRPB,0	; should be negative?
0006CA  1  71 05 1B     	JMPD DPMP		; fix sign & return
0006CD  1               
0006CD  1               
0006CD  1  4D 2F 4D 6F   FHdr 'M/Mod',0 ; ( ud1 u2 -- u3 ud4 )
0006D1  1  64 05 06 B0  
0006D5  1                  ; An unsigned mixed magnitude math operation which leaves a double quotient ud4 and
0006D5  1                  ; remainder u3, from a double dividend ud1 and single divisor u2.
0006D5  1               MSlashMod:
0006D5  1  DC           	LDBA ZW			; >R 0
0006D6  1  F5 A2        	STBX SW,ModBMRB,0
0006D8  1  3A           	CLA
0006D9  1  BC           	STAA ZW
0006DA  1  F5 82        	STBX ZW,ModBMRB,0	; R
0006DC  1  79 06 6F     	JSRD UMSlashMod		; U/
0006DF  1  DD           	LDBA SW			; R> Swap >R
0006E0  1  9C           	LDAA ZW
0006E1  1  FC           	STBA ZW
0006E2  1  BD           	STAA SW
0006E3  1  79 06 6F     	JSRD UMSlashMod		; U/
0006E6  1  95 A1        	LDAX SW,ModBRPB,0	; R>
0006E8  1  B5 82        	STAX ZW,ModBMRB,0
0006EA  1  09           	RSR
0006EB  1               
0006EB  1               
0006EB  1               	.if 0
0006EB  1               MSlashModTest1:
0006EB  1               	LDAL .loword(123456789)
0006EB  1               	STAX ZW,ModBMRB,0
0006EB  1               	LDAL .hiword(123456789)
0006EB  1               	STAX ZW,ModBMRB,0
0006EB  1               	LDAL 10
0006EB  1               	STAX ZW,ModBMRB,0
0006EB  1               	JSRR MSlashMod
0006EB  1               	LDAX ZW,ModBRPB,0
0006EB  1               	LDBL .hiword(12345678)
0006EB  1               	SAB
0006EB  1               	BZ @11
0006EB  1               	HLT
0006EB  1               @11:
0006EB  1               	LDAX ZW,ModBRPB,0
0006EB  1               	LDBL .loword(12345678)
0006EB  1               	SAB
0006EB  1               	BZ @12
0006EB  1               	HLT
0006EB  1               @12:
0006EB  1               	LDAX ZW,ModBRPB,0
0006EB  1               	LDBL 9
0006EB  1               	SAB
0006EB  1               	BZ @13
0006EB  1               	HLT
0006EB  1               @13:
0006EB  1               	RSR
0006EB  1               	.endif
0006EB  1               
0006EB  1               
0006EB  1  53 4D 2F 52   FHdr 'SM/Rem',0 ; ( d_dividend n_divisor -- n_remainder n_quotient )
0006EF  1  65 6D 06 06  
0006F3  1  D5           
0006F4  1                  ; A mixed magnitude math operation which leaves the signed remainder and signed
0006F4  1                  ; quotient, from a double number dividend and divisor.
0006F4  1                  ; The remainder takes its sign from the dividend.
0006F4  1               
0006F4  1                  ; Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
0006F4  1                  ;  Input and output stack arguments are signed.
0006F4  1                  ;  An ambiguous condition exists if n1 is zero or if the quotient lies outside the range of a single-cell signed integer.
0006F4  1                  ; https://forth-standard.org/standard/core/SMDivREM
0006F4  1               SMSlashRem:
0006F4  1  95 81        	LDAX ZW,ModBRPB,0	; pop divisor
0006F6  1  DC           	LDBA ZW			; push dividend sign to return stack
0006F7  1  F5 A2        	STBX SW,ModBMRB,0
0006F9  1  B5 A2        	STAX SW,ModBMRB,0	; push divisor to return stack
0006FB  1  79 05 0F     	JSRD DAbs		; d=abs(d)
0006FE  1  9D           	LDAA SW			; get a copy of divisor from return stack
0006FF  1  B5 82        	STAX ZW,ModBMRB,0
000701  1  79 04 E1     	JSRD Abs		; abs
000704  1  79 06 6F     	JSRD UMSlashMod		; unsigned divide
000707  1  95 A1        	LDAX SW,ModBRPB,0	; pop divisor from return stack
000709  1               ;	STAX ZW,ModBMRB,0
000709  1  DD           	LDBA SW			; should quotient be negative?
00070A  1  54 02        	ORE BW,AW
00070C  1  79 04 EC     	JSRD PMP
00070F  1  95 A1        	LDAX SW,ModBRPB,0	; pop dividend sign
000711  1  17 08        	BP @18			; should remander be negative?
000713  1  3A           	CLA			;   negate remainder
000714  1  D5 88 02     	LDBX ZW,ModNBRB,2
000717  1  59           	SAB
000718  1  F5 88 02     	STBX ZW,ModNBRB,2
00071B  1               @18:
00071B  1  09           	RSR			; return
00071C  1               
00071C  1               
00071C  1               	.if 0
00071C  1                FHdr 'M/',0 ; ( d_dividend n_divisor -- n_remainder n_quotient )  FIG alias
00071C  1               	JMPR SMSlashRem
00071C  1               	.endif
00071C  1               
00071C  1               
00071C  1               	.if 0
00071C  1                FHdr 'FM/Mod',0 ; ( d n1 — n2 n3 )
00071C  1                  ;Divide d1 by n1, giving the floored quotient n3 and the remainder n2.
00071C  1                  ; Input and output stack arguments are signed.
00071C  1                  ; An ambiguous condition exists if n1 is zero or if the quotient lies outside the range of a single-cell signed integer.
00071C  1                  ; https://forth-standard.org/standard/core/FMDivMOD
00071C  1               	.endif
00071C  1               
00071C  1               
00071C  1  2A 01 06 F4   FHdr '*',0 ; ( n1 n2 -- n_prod )  Leave the signed product of two signed numbers.
000720  1                  ; https://forth-standard.org/standard/core/Times
000720  1  79 06 45     Star:	JSRD UMStar		; do unsigned multiply
000723  1  30 81        	INR ZW,2		; drop hi word of result
000725  1  09           	RSR			; return
000726  1               
000726  1               
000726  1  2F 4D 6F 64   FHdr '/Mod',0 ; ( n_dividend n_divisor -- n_rem n_quot )  Divide
00072A  1  04 07 20     
00072D  1                  ; https://forth-standard.org/standard/core/DivMOD
00072D  1               SlashMod:
00072D  1  95 81        	LDAX ZW,ModBRPB,0	; save divisor
00072F  1  B5 A2        	STAX SW,ModBMRB,0
000731  1  79 06 37     	JSRD SToD		; convert dividend to double
000734  1  95 A1        	LDAX SW,ModBRPB,0	; get divisor
000736  1  B5 82        	STAX ZW,ModBMRB,0
000738  1  73 BA        	JMPR SMSlashRem		; divide & return
00073A  1               
00073A  1               
00073A  1  2F 01 07 2D   FHdr '/',0 ; ( n_dividend n_divisor -- n_quot )  Divide
00073E  1                  ; https://forth-standard.org/standard/core/Div
00073E  1  7B ED        Slash:	JSRR SlashMod		; do the divide
000740  1  71 03 04     	JMPD Nip		; discard the remainder, & return
000743  1               
000743  1               
000743  1  4D 6F 64 03   FHdr 'Mod',0 ; ( n_dividend n_divisor -- n_mod )
000747  1  07 3E        
000749  1                  ; Leave the remainder of n1/n2, with the same sign as n1.
000749  1                  ; https://forth-standard.org/standard/core/MOD
000749  1  7B E2        Mod:	JSRR SlashMod		; do the divide
00074B  1  30 81        	INR ZW,2		; drop the quotient
00074D  1  09           	RSR			; return
00074E  1               
00074E  1               
00074E  1  2A 2F 4D 6F   FHdr '*/Mod',0 ; ( n1 n_multipier n_divisor -- n_remainder n_quotient )
000752  1  64 05 07 49  
000756  1                  ; Leave the quotient and remainder of the operation (n1*n_multiplier)/n_divisor .
000756  1                  ; A 31 bit intermediate product is used as for */ .
000756  1                  ; https://forth-standard.org/standard/core/TimesDivMOD
000756  1               StarSlashMod:
000756  1  95 81        	LDAX ZW,ModBRPB,0	; save divisor on return stack
000758  1  B5 A2        	STAX SW,ModBMRB,0
00075A  1  79 06 B0     	JSRD MStar		; do multiply
00075D  1  95 A1        	LDAX SW,ModBRPB,0	; get divisor from return stack
00075F  1  B5 82        	STAX ZW,ModBMRB,0
000761  1  73 91        	JMPR SMSlashRem		; do divide & return
000763  1               
000763  1               
000763  1  2A 2F 02 07   FHdr '*/',0 ; ( n1 n_multiplier n_divisor -- n_quotient )
000767  1  56           
000768  1                  ; Leave the ratio n_quotient = (n1*n_multiplier)/n_divisor where all are signed numbers.
000768  1                  ; Retention of an intermediate 31 bit product permits greater accuracy
000768  1                  ; than would be available with the sequence:
000768  1                  ;	n1 n_multiplier * n_divisor /
000768  1                  ; https://forth-standard.org/standard/core/TimesDiv
000768  1               StarSlash:
000768  1  7B EC        	JSRR StarSlashMod ; do it
00076A  1  71 03 04     	JMPD Nip		; discard the remainder & return
00076D  1               
00076D  1               
00076D  1               	.if 0
00076D  1                FHdr 'M*/',0 ; ( d1 n1 +n2 -- d2 )
00076D  1                  ; https://forth-standard.org/standard/double/MTimesDiv
00076D  1               	JSRD Abort ;???
00076D  1               	.endif
00076D  1               
00076D  1               
00076D  1  2B 21 02 07   FHdr '+!',0 ; ( n adr -- )  Add n to the value at the address.
000771  1  68           
000772  1                  ; https://forth-standard.org/standard/core/PlusStore
000772  1               PlusStore:
000772  1  95 81        	LDAX ZW,ModBRPB,0	; pop adr
000774  1  5C           	XAY
000775  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
000777  1  DB           	LDBA YW
000778  1  58           	AAB
000779  1  FB           	STBA YW
00077A  1  09           	RSR
00077B  1               
00077B  1               
00077B  1  31 2B 21 83   FHdr '1+!',ha_inline ; ( adr -- )  increment a variable
00077F  1  07 72        
000781  1  D5 81        	LDBX ZW,ModBRPB,0	; pop addr
000783  1  99           	LDAA BW			; increment the word
000784  1  38           	INA
000785  1  B9           	STAA BW
000786  1  09 09        	.dbyt INL_End		; return
000788  1               
000788  1               
000788  1  30 21 82 07   FHdr '0!',ha_inline ; ( adr -- )  store 0 in a variable
00078C  1  81           
00078D  1  3A           	CLA
00078E  1  B5 85        	STAX ZW,ModABRPB,0
000790  1  09 09        	.dbyt INL_End		; return
000792  1               
000792  1               
000792  1               	.if 0
000792  1                FHdr 'Toggle',0 ; ( adr n -- )  Complement the contents of addr by the bit pattern n .
000792  1               Toggle:	LDBX ZW,ModBRPB,0	; pop n
000792  1               	LDAX ZW,ModBRPB,0	; pop adr
000792  1               	XAY
000792  1               	LDAA YW			; do a word
000792  1               	ORE AW,BW
000792  1               	STAA YW
000792  1               	RSR
000792  1               	.endif
000792  1               
000792  1               
000792  1  40 81 07 8D   FHdr '@',ha_inline ; ( adr -- n )  Leave the 16 bit contents of address.
000796  1                  ; https://forth-standard.org/standard/core/Fetch
000796  1  95 84        At:	LDAX ZW,ModABRB,0	; get @adr
000798  1  BC           	STAA ZW			; store n
000799  1  09 09        	.dbyt INL_End
00079B  1               
00079B  1               
00079B  1  32 40 02 07   FHdr '2@',0 ; ( adr -- d )  Leave the 32 bit contents of address.
00079F  1  96           
0007A0  1                  ; https://forth-standard.org/standard/core/TwoFetch
0007A0  1  DC           TwoAt:	LDBA ZW			; get addr
0007A1  1  95 21        	LDAX BW,ModBRPB,0	; get d.hi
0007A3  1  D9           	LDBA BW			; get d.lo
0007A4  1  FC           	STBA ZW			; store d.lo
0007A5  1  B5 82        	STAX ZW,ModBMRB,0	; store d.hi
0007A7  1  09           	RSR
0007A8  1               
0007A8  1               
0007A8  1  43 40 82 07   FHdr 'C@',ha_inline ; ( adr -- n )  Leave the 8 bit contents of memory address.
0007AC  1  A0           
0007AD  1               ; https://forth-standard.org/standard/core/CFetch
0007AD  1  3A           CAt:	CLA			; set the hi byte to 0
0007AE  1  85 84        	LDABX ZW,ModABRB,0	; fetch byte addressed by bottom of stack
0007B0  1  BC           	STAA ZW			; store as n
0007B1  1  09 09        	.dbyt INL_End		; return
0007B3  1               
0007B3  1               
0007B3  1  21 81 07 AD   FHdr '!',ha_inline ; ( n adr -- )  Store 16 bits of n at address.
0007B7  1                  ; https://forth-standard.org/standard/core/Store
0007B7  1  D5 81        Store:	LDBX ZW,ModBRPB,0	; pop adr
0007B9  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
0007BB  1  B9           	STAA BW			; store at (adr)
0007BC  1  09 09        	.dbyt INL_End		; return
0007BE  1               
0007BE  1               
0007BE  1  32 21 02 07   FHdr '2!',0 ; ( d adr -- )  Store 32 bits at adr.
0007C2  1  B7           
0007C3  1                  ; https://forth-standard.org/standard/core/TwoStore
0007C3  1               TwoStore:
0007C3  1  D5 81        	LDBX ZW,ModBRPB,0	; pop adr
0007C5  1  95 81        	LDAX ZW,ModBRPB,0	; pop d.hi
0007C7  1  B5 21        	STAX BW,ModBRPB,0	; store at adr+0
0007C9  1  95 81        	LDAX ZW,ModBRPB,0	; pop d.lo
0007CB  1  B9           	STAA BW			; store at adr+2
0007CC  1  09           	RSR			; return
0007CD  1               
0007CD  1               
0007CD  1  43 21 82 07   FHdr 'C!',ha_inline ; ( n adr -- )  Store 8 bits at address.
0007D1  1  C3           
0007D2  1                  ; https://forth-standard.org/standard/core/CStore
0007D2  1  D5 81        CStore:	LDBX ZW,ModBRPB,0	; pop adr
0007D4  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
0007D6  1  A9           	STABA BW		; store at adr
0007D7  1  09 09        	.dbyt INL_End		; return
0007D9  1               
0007D9  1               
0007D9  1  45 78 65 63   FHdr 'Execute',0 ; ( xt -- )
0007DD  1  75 74 65 07  
0007E1  1  07 D2        
0007E3  1                  ; Execute the definition whose address is on the stack.
0007E3  1                  ; The code address is also called the compilation address.
0007E3  1                  ; https://forth-standard.org/standard/core/EXECUTE
0007E3  1  75 85        Execute: JMPX ZW,ModABRPB,0	; pop xt & jmp to it
0007E5  1               
0007E5  1               
0007E5  1  43 6F 75 6E   FHdr 'Count',0 ; ( addr1 -- addr2 len )
0007E9  1  74 05 07 E3  
0007ED  1               ; Leave the byte address addr2 and byte count len of a counted string beginning at
0007ED  1               ; address addr1.  It is presumed that the first byte at addr1 contains the text
0007ED  1               ; byte count and the actual text starts with the second byte.
0007ED  1               ; Typically COUNT is followed by TYPE .
0007ED  1               ; https://forth-standard.org/standard/core/COUNT
0007ED  1  DC           Count:	LDBA ZW			; get addr1
0007EE  1  3A           	CLA			; get length byte
0007EF  1  85 21        	LDABX BW,ModBRPB,0
0007F1  1  FC           	STBA ZW			; store addr2
0007F2  1  B5 82        	STAX ZW,ModBMRB,0	; push length
0007F4  1  09           	RSR			; return
0007F5  1               
0007F5  1               
0007F5  1               	.if 0
0007F5  1               
0007F5  1                FHdr 'Chars',ha_inline ; ( n1 -- n2 )
0007F5  1                  ; n2 is the size in address units of n1 characters.
0007F5  1                  ; https://forth-standard.org/standard/core/CHARS
0007F5  1               Chars:	.dbyt INL_End
0007F5  1               
0007F5  1               
0007F5  1                FHdr 'Char+',0 ; ( c-addr1 -- c-addr2 )
0007F5  1                  ; Add the size in address units of a character to c-addr1, giving c-addr2.
0007F5  1                  ; https://forth-standard.org/standard/core/CHARPlus
0007F5  1               CharPlus: JMPR OnePlus
0007F5  1               
0007F5  1               	.endif
0007F5  1               
0007F5  1               
0007F5  1  43 65 6C 6C   FHdr 'Cell',0 ; ( -- n )  size of a cell in bytes
0007F9  1  04 07 ED     
0007FC  1  71 09 F8     Cell:	JMPD Two
0007FF  1               
0007FF  1               
0007FF  1  43 65 6C 6C   FHdr 'Cells',0 ; ( n1 -- n2 ) convert # of cells to bytes
000803  1  73 05 07 FC  
000807  1                  ; https://forth-standard.org/standard/core/CELLS
000807  1  71 03 F7     Cells:	JMPD TwoStar
00080A  1               
00080A  1               
00080A  1  43 65 6C 6C   FHdr 'Cell+',0 ; ( n1 -- n2 ) add size of cell
00080E  1  2B 05 08 07  
000812  1                  ; https://forth-standard.org/standard/core/CELLPlus
000812  1               CellPlus:
000812  1  71 04 5E     	JMPD TwoPlus
000815  1               
000815  1               
000815  1               	.if 0
000815  1                FHdr '/String',0 ; ( c-addr1 u1 n -- c-addr2 u2 )
000815  1                  ; Adjust the character string at c-addr1 by n characters. The resulting character string, specified by c-addr2 u2,
000815  1                  ; begins at c-addr1 plus n characters and is u1 minus n characters long.
000815  1                  ; https://forth-standard.org/standard/string/DivSTRING
000815  1               SlashString:
000815  1               	LDAX ZW,ModBRPB,0	; pop n
000815  1               	LDBX ZW,ModNBRB,2	; fix c-addr1
000815  1               	AAB
000815  1               	STBX ZW,ModNBRB,2
000815  1               	LDBA ZW			; fix u1
000815  1               	SUB AW,BW
000815  1               	STAA ZW
000815  1               	RSR
000815  1               	.endif
000815  1               
000815  1               
000815  1  2D 54 72 61   FHdr '-Trailing',0 ; ( addr n1 -- addr n2 )  Remove trailing blanks
000819  1  69 6C 69 6E  
00081D  1  67 09 08 12  
000821  1                  ; Adjust the char count n1 of a text string beginning at addr to suppress
000821  1                  ; the output of trailing blanks.  i.e. the chars at addr+n1 to addr+n2
000821  1                  ; are blanks.
000821  1                  ; https://forth-standard.org/standard/string/MinusTRAILING
000821  1               DTrailing:
000821  1  6D A2        	STXX SW,ModBMRB,0	; save X
000823  1               
000823  1  65 80        	LDXX ZW,ModBRB,0	; X= len
000825  1  95 88 02     	LDAX ZW,ModNBRB,2	; Y= addr+len
000828  1  5C           	XAY
000829  1  50 46        	ADD YW,XW
00082B  1  3F           @8:	DCX			; step to previous char
00082C  1  16 07        	BM @9
00082E  1  C5 62        	LDBBX YW,ModBMRB,0	; get char
000830  1  80 20        	LDABL ' '		; is char blank?
000832  1  49           	SABB
000833  1  14 F6        	BZ @8			;   if so, do another char
000835  1  3E           @9:	INXC			; done
000836  1  6D 80        	STXX ZW,ModBRB,0	; store new len
000838  1               
000838  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
00083A  1  09           	RSR			; return
00083B  1               
00083B  1               
00083B  1  55 70 70 65   FHdr 'Upper',0 ; ( adr len -- ) uppercase a string
00083F  1  72 05 08 21  
000843  1  6D A2        Upper:	STXX SW,ModBMRB,0	; push X
000845  1  65 81        	LDXX ZW,ModBRPB,0	; pop len
000847  1  95 81        	LDAX ZW,ModBRPB,0	; pop adr
000849  1  5C           	XAY
00084A  1  14 15        	BZ @Done
00084C  1               
00084C  1  85 61        @2:	LDABX YW,ModBRPB,0	; get char
00084E  1  C0 61        	LDBBL 'a'		; <'a'?
000850  1  49           	SABB
000851  1  11 0B        	BNL @7
000853  1  C0 7B        	LDBBL 'z'+1		; >'z'?
000855  1  49           	SABB
000856  1  10 06        	BL @7
000858  1  C0 DF        	LDBBL $DF		; change to ASCII uppercase
00085A  1  4A           	NABB
00085B  1  E5 68 FF     	STBBX YW,ModNBRB,$ff	; store it back
00085E  1  3F           @7:	DCX			; len--
00085F  1  17 EB        	BP @2			; <0?
000861  1               
000861  1  65 A1        @Done:	LDXX SW,ModBRPB,0	; pop X
000863  1  09           	RSR
000864  1               
000864  1               
000864  1               	.if 0
000864  1                FHdr 'Replaces',0 ; ( c-addr1 u1 c-addr2 u2 -- )
000864  1                  ; Set the string c-addr1 u1 as the text to substitute for the substitution named by c-addr2 u2.
000864  1                  ; If the substitution does not exist it is created. The program may then reuse the buffer c-addr1 u1
000864  1                  ; without affecting the definition of the substitution.
000864  1                  ;
000864  1                  ; Ambiguous conditions occur as follows:
000864  1                  ;	The substitution cannot be created;
000864  1                  ;	The name of a substitution contains the `%' delimiter character.
000864  1                  ; 	REPLACES may allot data space and create a definition. This breaks the contiguity of the current region and
000864  1                  ;	  is not allowed during compilation of a colon definition
000864  1                  ; https://forth-standard.org/standard/string/REPLACES
000864  1               Replaces:
000864  1               	JSRD Abort ;???
000864  1               	.endif
000864  1               
000864  1               
000864  1               	.if 0
000864  1                FHdr 'Search',0 ; ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
000864  1                  ; Search the string specified by c-addr1 u1 for the string specified by c-addr2 u2.
000864  1                  ; If flag is true, a match was found at c-addr3 with u3 characters remaining.
000864  1                  ; If flag is false there was no match and c-addr3 is c-addr1 and u3 is u1.
000864  1                  ; https://forth-standard.org/standard/string/SEARCH
000864  1               Search:
000864  1               	STXX SW,ModBMRB,0	; save X
000864  1               	LDAX ZW,ModBRPB,0	; pop u2
000864  1               	INA
000864  1               	STAX SW,ModBMRB,0	;   push u2
000864  1               	LDAA ZW			; get c-addr2
000864  1               	LDBL $7f00		;   YH=$7f, YL=1st char
000864  1               	LDBBX AW,ModBRPB,0
000864  1               	STBX SW,ModBMRB,0	;     push
000864  1               	STAX SW,ModBMRB,0	;   push c-addr2 + 1
000864  1               	LDAX ZW,ModNBRB,2	; get u1
000864  1               	INA			;   + 1
000864  1               	LDBX SW,ModNBRB,4	;   - u2
000864  1               	SAB
000864  1               	STBX SW,ModBMRB,0	;   push
000864  1               	LDAX ZW,ModNBRB,4	; get c-addr1
000864  1               	STAX SW,ModBMRB,0	;   push
000864  1               	XFR AW,ZW		; save Z
000864  1               	STAX SW,ModBMRB,0
000864  1               @c2	= 10
000864  1               @chr2	=  8
000864  1               @A2	=  6
000864  1               @A1	=  4
000864  1               @c1	=  2
000864  1               @Z	=  0
000864  1               
000864  1               @10:				; load regs for 1st char search
000864  1               	LDAX SW,ModNBRB,@c1	; Z = @c1
000864  1               	XAZ
000864  1               	LDAX SW,ModNBRB,@chr2	; Yh = $7f; YL = 1st pattern char
000864  1               	XAY
000864  1               	LDXX SW,ModNBRB,@A1	; X = @A1
000864  1               @12:	DCR ZW			;   get next byte
000864  1               	BZ @NotFound
000864  1               	LDABX XW,ModBRPB,0
000864  1               	SUBB BL,YL		;   compare
000864  1               	ANR BL,YH		;   is this helpful?
000864  1               	BNZ @12
000864  1               	STXX SW,ModNBRB,@A1	; save loc of 2nd char
000864  1               	XFR AW,ZW
000864  1               	STAX SW,ModNBRB,@c1	; save count
000864  1               
000864  1               	LDAX SW,ModNBRB,@A2	; load regs for additional chars search
000864  1               	XAY
000864  1               	LDAX SW,ModNBRB,@c2
000864  1               	XAZ
000864  1               	JMPR @28
000864  1               @22:	LDABX XW,ModBRPB,0	; compare char
000864  1               	LDBBX YW,ModBRPB,0
000864  1               	SABB
000864  1               	BNZ @10
000864  1               @28:	DCR ZW			; adjust count
000864  1               	BNZ @22
000864  1               
000864  1               @Found:	LDAA SW ;@Z		; restore Z
000864  1               	XAZ
000864  1               	LDAX SW,ModNBRB,@A1	; c-addr3 = @A1 - 1
000864  1               	DCA
000864  1               	STAX ZW,ModNBRB,4
000864  1               	LDAX SW,ModNBRB,@c1	; u3 = @c1 + @c2
000864  1               	LDBX SW,ModNBRB,@c2
000864  1               	AAB
000864  1               	STBX ZW,ModNBRB,2
000864  1               	LDAL 1			; flag = true
000864  1               	JMPR @99
000864  1               
000864  1               @NotFound:
000864  1               	LDAA SW ; @Z		; restore Z
000864  1               	XAZ
000864  1               	CLA			; flag = false
000864  1               
000864  1               @99:	INR SW,@c2+2
000864  1               	LDXX SW,MonBRPB,0	; restore X
000864  1               	STAA ZW			; save flag
000864  1               	RSR
000864  1               	.endif
000864  1               
000864  1               
000864  1               	.if 0
000864  1                FHdr 'Substitute',0 ; ( c-addr1 u1 c-addr2 u2 -- c-addr2 u3 n )
000864  1                  ; Perform substitution on the string c-addr1 u1 placing the result at string c-addr2 u3,
000864  1                  ; where u3 is the length of the resulting string.
000864  1                  ; An error occurs if the resulting string will not fit into c-addr2 u2 or if c-addr2 is the same as c-addr1.
000864  1                  ; The return value n is positive or 0 on success and indicates the number of substitutions made. A negative value for n indicates that an error occurred, leaving c-addr2 u3 undefined. Negative values of n are implementation defined except for values in table 9.1 THROW code assignments.
000864  1                  ;
000864  1                  ; Substitution occurs left to right from the start of c-addr1 in one pass and is non-recursive.
000864  1                  ;
000864  1                  ; When text of a potential substitution name, surrounded by `%' (ASCII $25) delimiters is encountered by SUBSTITUTE, the following occurs:
000864  1                  ;
000864  1                  ; If the name is null, a single delimiter character is passed to the output, i.e., %% is replaced by %. The current number of substitutions is not changed.
000864  1                  ; If the text is a valid substitution name acceptable to 17.6.2.2141 REPLACES, the leading and trailing delimiter characters and the enclosed substitution name are replaced by the substitution text. The current number of substitutions is incremented.
000864  1                  ; If the text is not a valid substitution name, the name with leading and trailing delimiters is passed unchanged to the output. The current number of substitutions is not changed.
000864  1                  ; Parsing of the input string resumes after the trailing delimiter.
000864  1                  ; If after processing any pairs of delimiters, the residue of the input string contains a single delimiter, the residue is passed unchanged to the output.
000864  1                  ; https://forth-standard.org/standard/string/SUBSTITUTE
000864  1               Substutute:
000864  1               	JSRD Abort ;???
000864  1               	.endif
000864  1               
000864  1               
000864  1               	.if 0
000864  1                FHdr 'Unescape',0 ; ( c-addr1 u1 c-addr2 -- c-addr2 u2 )
000864  1                  ; Replace each `%' character in the input string c-addr1 u1 by two `%' characters.
000864  1                  ; The output is represented by c-addr2 u2. The buffer at c-addr2 shall be big enough to hold the unescaped string.
000864  1                  ; An ambiguous condition occurs if the resulting string will not fit into the destination buffer (c-addr2).
000864  1                  ; https://forth-standard.org/standard/string/UNESCAPE
000864  1               Unescape:
000864  1               	JSRD Abort ;???
000864  1               	.endif
000864  1               
000864  1               
000864  1  45 6E 63 6C   FHdr 'Enclose',0 ; ( addr delimiter - addr1 n1 n2 n3 )
000868  1  6F 73 65 07  
00086C  1  08 43        
00086E  1                  ; The text scanning primitive used by WORD.  From the text address addr1 and an ASCII
00086E  1                  ; delimiting char, is determined the byte offset to the first non-delimiter
00086E  1                  ; char n1, the offset to the first delimiter after the text n2, and the offset to the
00086E  1                  ; first char not included.
00086E  1                  ; This procedure will not process past an ASCII 'null', treating it as an unconditional delimiter.
00086E  1               Enclose:
00086E  1  6D A2        	STXX SW,ModBMRB,0	; push X
000870  1  65 88 02     	LDXX ZW,ModNBRB,2	; X=addr
000873  1  9C           	LDAA ZW			; AL=delimiter
000874  1  31 83        	DCR ZW,4		; alloc space for n2 & n3
000876  1               
000876  1               	; skip initial delimiters
000876  1  3F           	DCX
000877  1  3E           @313:	INXC			; get next char
000878  1  CA           	LDBBA XW
000879  1  49           	SABB
00087A  1  14 FB        	BZ @313
00087C  1  D5 88 06     	LDBX ZW,ModNBRB,6	; n1=index of 1st non-delimiter char
00087F  1  51 42        	SUB BW,XW
000881  1  F5 88 04     	STBX ZW,ModNBRB,4
000884  1               
000884  1  3F           	DCX			; skip word
000885  1  3E           @318:	INXC			; get next char
000886  1  CA           	LDBBA XW
000887  1  14 10        	BZ @70			;    null?
000889  1  49           	SABB			;    !delimiter?
00088A  1  15 F9        	BNZ @318
00088C  1  D5 88 06     	LDBX ZW,ModNBRB,6	; n2=index of delimiter after word
00088F  1  51 42        	SUB BW,XW
000891  1  F5 88 02     	STBX ZW,ModNBRB,2
000894  1  30 20        	INR BW,1		; n3=n2+1
000896  1  FC           	STBA ZW
000897  1  73 15        	JMPR @Rtn
000899  1               
000899  1               @70: ; we hit a null
000899  1  D5 88 06     	LDBX ZW,ModNBRB,6	; n2=index of null
00089C  1  51 42        	SUB BW,XW
00089E  1  F5 88 02     	STBX ZW,ModNBRB,2
0008A1  1  FC           	STBA ZW			; n3=index of null
0008A2  1               
0008A2  1  95 88 04     	LDAX ZW,ModNBRB,4	; n2==n1?
0008A5  1  51 20        	SUB AW,BW
0008A7  1  15 05        	BNZ @326
0008A9  1  30 20        	INR BW,1		;   n2+=1
0008AB  1  F5 88 02     	STBX ZW,ModNBRB,2
0008AE  1               @326:
0008AE  1  65 A1        @Rtn:	LDXX SW,ModBRPB,0	; pop X
0008B0  1  09           	RSR			; return
0008B1  1               
0008B1  1               
0008B1  1               ; FHdr 'Word',0 ; ( c -- addr )  ANSI
0008B1  1                  ;	Parses one word from the input stream, using the character (usually blank) as a delimiter.
0008B1  1                  ;	Moves the string to the address HERE with the count in the first byte, leaving the address on the stack.
0008B1  1                  ; https://forth-standard.org/standard/core/WORD
0008B1  1               
0008B1  1               
0008B1  1  57 6F 72 64   FHdr 'Word',0 ; ( c -- )  FIG
0008B5  1  04 08 6E     
0008B8  1                  ; Read the next text chars from the input stream being interpreted, until a delimiter
0008B8  1                  ; c is found, storing the packed char string beginning at the dictionary buffer HERE .
0008B8  1                  ; WORD leaves the char count in the 1st byte, the chars, and ends with 2 or more blanks.
0008B8  1                  ; Leading occurances of c are ignored.  If BLK is zero, text is taken from the
0008B8  1                  ; terminal input buffer, otherwise from the disc block stored in BLK .
0008B8  1                  ; See BLK IN
0008B8  1  91 70 74     Word:	LDAD VBlk		; if not terminal
0008BB  1  14 07        	BZ @1914
0008BD  1               
0008BD  1  B5 82        	STAX ZW,ModBMRB,0	;   get block ptr
0008BF  1  79 18 5E     	JSRD Block
0008C2  1  73 05        	JMPR @1916		;  else
0008C4  1               
0008C4  1  91 70 68     @1914:	LDAD VTIB		;   get terminal buffer ptr
0008C7  1  B5 82        	STAX ZW,ModBMRB,0
0008C9  1               				;  then
0008C9  1               @1916:				; ( c buf )
0008C9  1               
0008C9  1  91 70 76     	LDAD VIn
0008CC  1  79 04 7F     	JSRD PlusA
0008CF  1  79 02 96     	JSRD Swap
0008D2  1  79 08 6E     	JSRD Enclose		; ( buf n1 n2 n3 )
0008D5  1               
0008D5  1  91 70 70     	LDAD VDP		; output ptr
0008D8  1  5C           	XAY
0008D9  1               
0008D9  1  95 88 02     	LDAX ZW,ModNBRB,2	; store string length
0008DC  1  D5 88 04     	LDBX ZW,ModNBRB,4
0008DF  1  59           	SAB
0008E0  1  E5 61        	STBBX YW,ModBRPB,0
0008E2  1               
0008E2  1  95 88 06     	LDAX ZW,ModNBRB,6	; source addr
0008E5  1  D5 88 04     	LDBX ZW,ModNBRB,4
0008E8  1  58           	AAB
0008E9  1  85 68 FF     	LDABX YW,ModNBRB,$ff
0008EC  1  45 10        	XFRB AH,AL		; store chars
0008EE  1  85 21        @31:	LDABX BW,ModBRPB,0
0008F0  1  A5 61        	STABX YW,ModBRPB,0
0008F2  1  21 00        	DCRB AH
0008F4  1  15 F8        	BNZ @31
0008F6  1               
0008F6  1  90 20 20     	LDAL $2020		; store blanks
0008F9  1  BB           	STAA YW
0008FA  1               
0008FA  1  79 0A C7     	JSRD In			; In+=n3
0008FD  1  79 07 72     	JSRD PlusStore
000900  1  30 85        	INR ZW,6		; drop n2 n1 buf
000902  1  09           	RSR
000903  1               
000903  1               
000903  1               	.if 0
000903  1                FHdr 'Digit',0	; ( c n1 -- n2 true ) (ok)
000903  1               		; ( c n1 ---  false ) (bad)
000903  1                  ; Converts the ASCII char c (using base n1) to its binary equivalent n2,
000903  1                  ; accompanied by a true flag.  If the conversion is invalid, leaves
000903  1                  ; only a false flag.
000903  1               	JSRD Abort ;???
000903  1               	.endif
000903  1               
000903  1               
000903  1  28 4E 75 6D   FHdr '(Number)',0 ; ( d1 addr1 -- d2 addr2 )
000907  1  62 65 72 29  
00090B  1  08 08 B8     
00090E  1                  ; Convert the ASCII text beginning at addr1+1 with regard to BASE.  The new value
00090E  1                  ; is accumulated into double number d1, being left as d2.  Addr2 is the address
00090E  1                  ; of the first unconvertable digit.  Used by NUMBER.
00090E  1               PNumber:
00090E  1  9C           @1971:	LDAA ZW			; addr1+=1
00090F  1  38           	INA
000910  1  BC           	STAA ZW
000911  1  88           	LDABA AW		; get char
000912  1  C0 D0        	LDBBL $100-'0'		; 0..9?
000914  1  40 31        	ADDB AL,BL
000916  1  11 48        	BNL @bad
000918  1  C0 0A        	LDBBL 10
00091A  1  49           	SABB
00091B  1  11 18        	BNL @base
00091D  1  C0 F9        	LDBBL $100-7
00091F  1  40 31        	ADDB AL,BL
000921  1  C0 0A        	LDBBL 10		; A..Z?
000923  1  49           	SABB
000924  1  11 3A        	BNL @bad
000926  1  C1 70 85     	LDBBD 1+VBase
000929  1  49           	SABB
00092A  1  11 0F        	BNL @ok
00092C  1  C0 E0        	LDBBL $100-$20		; a..z?
00092E  1  40 31        	ADDB AL,BL
000930  1  C0 0A        	LDBBL 10
000932  1  49           	SABB
000933  1  11 2B        	BNL @bad
000935  1  C1 70 85     @base:	LDBBD 1+VBase		; >=base?
000938  1  49           	SABB
000939  1  10 25        	BL @bad
00093B  1               @ok:
00093B  1  DC           	LDBA ZW			; save addr1 on return stack
00093C  1  F5 A2        	STBX SW,ModBMRB,0
00093E  1  22 00        	CLRB AH
000940  1  BC           	STAA ZW			; ( ul uh digit )
000941  1               
000941  1  79 02 96     	JSRD Swap		; ( ul digit uh )
000944  1  7B 1B        	JSRR @mul		; ( u1 digit dh )
000946  1  30 81        	INR ZW,2		; ( ul digit uh )
000948  1  79 02 80     	JSRD Rot		; ( digit uh ul )  ( n1 n2 n3 -- n2 n3 n1 )
00094B  1  79 09 61     	JSRD @mul		; ( digit uh dl )
00094E  1  79 04 A3     	JSRD DPlus		; ( d2 )
000951  1  91 70 86     	LDAD VDPL		; decimal_places>=0?
000954  1  16 04        	BM @1998
000956  1  38           	INA
000957  1  B1 70 86     	STAD VDPL		;   increment decimal_places
00095A  1               @1998:
00095A  1  95 A1        	LDAX SW,ModBRPB,0	; pop addr1 from return stack  ( d2 addr )
00095C  1  B5 82        	STAX ZW,ModBMRB,0
00095E  1  73 AE        	JMPR @1971		; back for more digits
000960  1               
000960  1  09           @bad:	RSR			; we hit something not-a-number, return
000961  1               
000961  1  91 70 84     @mul:	LDAD VBase
000964  1  B5 82        	STAX ZW,ModBMRB,0
000966  1  71 06 45     	JMPD UMStar
000969  1               
000969  1               
000969  1  4E 75 6D 62   FHdr 'Number',0 ; ( addr -- d )
00096D  1  65 72 06 09  
000971  1  0E           
000972  1                  ; Convert a character string left at addr with a preceeding count, to a signed
000972  1                  ; double number, using the current numeric base.  If a decimal point is encountered
000972  1                  ; in the text its position will be given in DPL, but no other effect occurs.
000972  1                  ; If numeric conversion is not possible, an error message will be given.
000972  1  6D A2        Number:	STXX SW,ModBMRB,0	; save X
000974  1  65 80        	LDXX ZW,ModBRB,0	; get addr
000976  1  3A           	CLA			; push 0.
000977  1  BC           	STAA ZW
000978  1  B5 82        	STAX ZW,ModBMRB,0
00097A  1  31 81        	DCR ZW,2		; ( d addr )
00097C  1               
00097C  1  91 70 84     	LDAD VBase		; save default base
00097F  1  B5 A2        	STAX SW,ModBMRB,0
000981  1  90 FF FF     	LDAL $ffff		; init decimal places to "no . found"
000984  1  B1 70 86     	STAD VDPL
000987  1               
000987  1  3E           	INXC			; skip string count byte
000988  1  8A           	LDABA XW		; look at next char
000989  1  C0 2D        	LDBBL '-'		; negative sign?
00098B  1  49           	SABB
00098C  1  E5 A2        	STBBX SW,ModBMRB,0	;   save this for finish
00098E  1  15 02        	BNZ @17
000990  1  3E           	INXC			;   skip sign char
000991  1  8A           	LDABA XW
000992  1               @17:
000992  1  C0 24        	LDBBL '$'		;    hex?
000994  1  49           	SABB
000995  1  14 1D        	BZ @Hex
000997  1  C0 27        	LDBBL "'"		;    char literal?
000999  1  49           	SABB
00099A  1  14 1E        	BZ @Char
00099C  1  3F           @29:	DCX			; save addr of remaining string-1
00099D  1  6D 80        	STXX ZW,ModBRB,0
00099F  1               
00099F  1  79 09 0E     @2023:	JSRD PNumber		; do some digits
0009A2  1  85 84        	LDABX ZW,ModABRB,0	; look at next char
0009A4  1  C0 20        	LDBBL ' '		; blank?
0009A6  1  49           	SABB
0009A7  1  14 27        	BZ @2042
0009A9  1  C0 2E        	LDBBL '.'		; '.'?
0009AB  1  49           	SABB
0009AC  1  15 1D        	BNZ @err
0009AE  1  3A           	CLA			; remember the dot
0009AF  1  B1 70 86     	STAD VDPL
0009B2  1  73 EB        	JMPR @2023		; back for more chars
0009B4  1               
0009B4  1               @Hex:	; temporary hex base
0009B4  1  79 0C C5     	JSRD Hex
0009B7  1  3E           	INXC
0009B8  1  73 E2        	JMPR @29
0009BA  1               
0009BA  1               @Char: ; char literal
0009BA  1  85 48 02     	LDABX XW,ModNBRB,2	; check ending delimiter
0009BD  1  C0 27        	LDBBL "'"
0009BF  1  49           	SABB
0009C0  1  15 DA        	BNZ @29
0009C2  1  3A           	CLA			; get char
0009C3  1  85 48 01     	LDABX XW,ModNBRB,1
0009C6  1  B5 88 04     	STAX ZW,ModNBRB,4
0009C9  1  73 05        	JMPR @2042
0009CB  1               
0009CB  1  32 20        @err:	CLR BW,Err_0		; unconvertable digit, signal error
0009CD  1  79 0E F4     	JSRD ErrorY
0009D0  1               
0009D0  1               @2042:				; done
0009D0  1  30 81        	INR ZW,2		; drop addr
0009D2  1  85 A1        	LDABX SW,ModBRPB,0	; was there a '-' sign?
0009D4  1  15 03        	BNZ @2047
0009D6  1  79 04 F9     	JSRD DNegate		;   negate the result
0009D9  1               @2047:
0009D9  1  95 A1        	LDAX SW,ModBRPB,0	; restore base
0009DB  1  B1 70 84     	STAD VBase
0009DE  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
0009E0  1  09           	RSR			; return
0009E1  1               
0009E1  1               
0009E1  1               	.if 0
0009E1  1                FHdr '>Number',0 ; ( ud1 addr1 u1 — ud2 addr2 u2 )
0009E1  1                  ;Return value ud2 is the unsigned result of converting the characters within the string specified
0009E1  1                  ; by addr1 u1 into digits, using the number in BASE, and adding each into ud1 after multiplying
0009E1  1                  ; ud1 by the number in BASE. Conversion continues left-to-right until a character that is not
0009E1  1                  ; convertible, including any “+” or “-“, is encountered or the string is entirely converted.
0009E1  1                  ; Address addr2 is the location of the first unconverted character or the first character past
0009E1  1                  ; the end of the string if the string was entirely converted.
0009E1  1                  ; Length u2 is the number of unconverted characters in the string.
0009E1  1               	JSRD Abort ;???
0009E1  1               	.endif
0009E1  1               
0009E1  1               
0009E1  1               ; These small numbers are used so often that it is attractive to define them
0009E1  1               ; by name in the dictionary as constants.
0009E1  1               
0009E1  1  30 81 09 72   FHdr '0',ha_inline ; ( -- n )  constant: 0
0009E5  1  3A           Zero:	CLA
0009E6  1  B5 82        	STAX ZW,ModBMRB,0
0009E8  1  09 09        	.dbyt INL_End
0009EA  1               
0009EA  1               
0009EA  1  31 81 09 E5   FHdr '1',ha_inline ; ( -- n )  constant: 1
0009EE  1  32 01        One:	CLR AW,1
0009F0  1  B5 82        	STAX ZW,ModBMRB,0
0009F2  1  09 09        	.dbyt INL_End
0009F4  1               
0009F4  1               
0009F4  1  32 81 09 EE   FHdr '2',ha_inline ; ( -- n )  constant: 2
0009F8  1  32 02        Two:	CLR AW,2
0009FA  1  B5 82        	STAX ZW,ModBMRB,0
0009FC  1  09 09        	.dbyt INL_End
0009FE  1               
0009FE  1               
0009FE  1  33 81 09 F8   FHdr '3',ha_inline ; ( -- n )  constant: 3
000A02  1  32 03        Three:	CLR AW,3
000A04  1  B5 82        	STAX ZW,ModBMRB,0
000A06  1  09 09        	.dbyt INL_End
000A08  1               
000A08  1               
000A08  1  42 6C 82 0A   FHdr 'Bl',ha_inline ; ( -- n )	constant: the ASCII value for "blank".
000A0C  1  02           
000A0D  1               ; https://forth-standard.org/standard/core/BL
000A0D  1  90 00 20     Bl:	LDAL ' '		; push a blank & return
000A10  1  B5 82        	STAX ZW,ModBMRB,0
000A12  1  09 09        	.dbyt INL_End
000A14  1               
000A14  1               
000A14  1  43 2F 4C 03   FHdr 'C/L',0 ; ( -- n )  constant: chars per screen line
000A18  1  0A 0D        
000A1A  1  90 00 40     CSlashL: LDAL 64
000A1D  1  B5 82        	STAX ZW,ModBMRB,0
000A1F  1  09           	RSR
000A20  1               
000A20  1               
000A20  1  42 2F 42 75   FHdr 'B/Buf',0 ; ( -- n )  constant: number of bytes per disc buffer,
000A24  1  66 05 0A 1A  
000A28  1               			; the byte count read from disc by BLOCK.
000A28  1  90 01 00     BBuf:	LDAL SectorSize
000A2B  1  B5 82        	STAX ZW,ModBMRB,0
000A2D  1  09           	RSR
000A2E  1               
000A2E  1               
000A2E  1  42 2F 53 63   FHdr 'B/Scr',0 ; ( -- n )  constant: number of blocks per editing screen.
000A32  1  72 05 0A 28  
000A36  1               		; By convention, an editing screen is 1024 bytes organized as 16 lines of 64 chars each.
000A36  1  90 00 04     BScr:	LDAL 1024/SectorSize
000A39  1  B5 82        	STAX ZW,ModBMRB,0
000A3B  1  09           	RSR
000A3C  1               
000A3C  1               
000A3C  1  2B 4F 72 69   FHdr '+Origin',0 ; ( n -- adr )  Memory address relative by n to the origin parameter area.
000A40  1  67 69 6E 07  
000A44  1  0A 36        
000A46  1               	; n is the minimum address unit, either byte or word.
000A46  1               	; This definition is used to access or modify the boot-up parameters at the origin area.
000A46  1  90 02 00     POrig:	LDAL ORIG
000A49  1  71 04 7F     	JMPD PlusA
000A4C  1               
000A4C  1               
000A4C  1  55 73 65 72   FHdr 'User',0 ;
000A50  1  04 0A 46     
000A53  1                  ; A defining word used in the form:
000A53  1                  ;	n USER cccc
000A53  1                  ; which creates a user variable cccc.
000A53  1                  ; When cccc is later executed, it places the sum of its offset and the user area
000A53  1                  ; base address on the stack as the storage address of that particular variable.
000A53  1  79 12 14     User:	JSRD HeaderComma	; compile word header
000A56  1  79 10 86     	JSRD LdaComma		; compile "ldal n"
000A59  1  90 0A E8     	LDAL DoUser		; compile "jmp DoUser" & return
000A5C  1  71 10 51     	JMPD JmpCommaA
000A5F  1               
000A5F  1               
000A5F  1  42 53 02 0A   FHdr 'BS',0 ; ( -- n )	User variable
000A63  1  53           
000A64  1  90 70 60     BS:	LDAL VBS
000A67  1  73 7F        	JMPR DoUser
000A69  1               
000A69  1               
000A69  1  54 49 42 03   FHdr 'TIB',0 ; ( -- adr )  User variable
000A6D  1  0A 64        
000A6F  1  90 70 68     TIB:	LDAL VTIB
000A72  1  73 74        	JMPR DoUser
000A74  1               
000A74  1               
000A74  1               	.if 0
000A74  1                FHdr '#TIB',0 ; ( — addr )  User variable
000A74  1               	HLT ; ??Contains the size of the contents of the terminal input buffer.
000A74  1               	.endif
000A74  1               
000A74  1               
000A74  1  57 69 64 74   FHdr 'Width',0 ; ( -- adr )  User variable
000A78  1  68 05 0A 6F  
000A7C  1  90 70 6A     Width:	LDAL VWidth
000A7F  1  73 67        	JMPR DoUser
000A81  1               
000A81  1               
000A81  1  57 61 72 6E   FHdr 'Warning',0 ; ( -- adr )  User variable
000A85  1  69 6E 67 07  
000A89  1  0A 7C        
000A8B  1  90 70 6C     Warning: LDAL VWarning
000A8E  1  73 58        	JMPR DoUser
000A90  1               
000A90  1               
000A90  1  46 65 6E 63   FHdr 'Fence',0 ; ( -- adr )  User variable
000A94  1  65 05 0A 8B  
000A98  1  90 70 6E     Fence:	LDAL VFence
000A9B  1  73 4B        	JMPR DoUser
000A9D  1               
000A9D  1               
000A9D  1  44 50 02 0A   FHdr 'DP',0 ; ( -- adr )  User variable
000AA1  1  98           
000AA2  1  90 70 70     DP:	LDAL VDP
000AA5  1  73 41        	JMPR DoUser
000AA7  1               
000AA7  1               
000AA7  1  56 6F 63 2D   FHdr 'Voc-Link',0 ; ( -- adr )  User variable
000AAB  1  4C 69 6E 6B  
000AAF  1  08 0A A2     
000AB2  1  90 70 72     VocL:	LDAL VVoc_Link
000AB5  1  73 31        	JMPR DoUser
000AB7  1               
000AB7  1               
000AB7  1  42 6C 6B 03   FHdr 'Blk',0 ; ( -- adr )  User variable
000ABB  1  0A B2        
000ABD  1  90 70 74     Blk:	LDAL VBlk
000AC0  1  73 26        	JMPR DoUser
000AC2  1               
000AC2  1               
000AC2  1  49 6E 02 0A   FHdr 'In',0 ; ( -- adr )  User variable
000AC6  1  BD           
000AC7  1  90 70 76     In:	LDAL VIn
000ACA  1  73 1C        	JMPR DoUser
000ACC  1               
000ACC  1               
000ACC  1  3E 49 4E 03   FHdr '>IN',0 ; ( -- a-addr )
000AD0  1  0A C7        
000AD2  1                  ; a-addr is the address of a cell containing the offset in characters from the start of the input
000AD2  1                  ; buffer to the start of the parse area.
000AD2  1                  ; https://forth-standard.org/standard/core/toIN
000AD2  1  73 F3        ToIn:	JMPR In
000AD4  1               
000AD4  1               
000AD4  1  4F 75 74 03   FHdr 'Out',0 ; ( -- adr )  User variable
000AD8  1  0A D2        
000ADA  1  90 70 78     Out:	LDAL VOut
000ADD  1  73 09        	JMPR DoUser
000ADF  1               
000ADF  1               
000ADF  1  53 63 72 03   FHdr 'Scr',0 ; ( -- adr )  User variable
000AE3  1  0A DA        
000AE5  1  90 70 7A     Scr:	LDAL VScr
000AE8  1               ;	JMPR DoUser
000AE8  1               
000AE8  1               
000AE8  1               DoUser: ; runtime.  Push A + user area base
000AE8  1  B5 82        	STAX ZW,ModBMRB,0	; push A
000AEA  1               ;	LDBD VUA		; add user area base
000AEA  1               ;	AAB
000AEA  1               ;	STBX ZW,ModBMRB,0	; push B
000AEA  1  09           	RSR			; return
000AEB  1               
000AEB  1               
000AEB  1  4F 66 66 73   FHdr 'Offset',0 ; ( -- adr )  User variable
000AEF  1  65 74 06 0A  
000AF3  1  E5           
000AF4  1  90 70 7C     Offset:	LDAL VOffset
000AF7  1  73 EF        	JMPR DoUser
000AF9  1               
000AF9  1               
000AF9  1  43 6F 6E 74   FHdr 'Context',0 ; ( -- adr )  User variable
000AFD  1  65 78 74 07  
000B01  1  0A F4        
000B03  1  90 70 7E     Context: LDAL VContext
000B06  1  73 E0        	JMPR DoUser
000B08  1               
000B08  1               
000B08  1  43 75 72 72   FHdr 'Current',0 ; ( -- adr )  User variable
000B0C  1  65 6E 74 07  
000B10  1  0B 03        
000B12  1  90 70 80     Current: LDAL VCurrent
000B15  1  73 D1        	JMPR DoUser
000B17  1               
000B17  1               
000B17  1  53 74 61 74   FHdr 'State',0 ; ( -- adr )  User variable
000B1B  1  65 05 0B 12  
000B1F  1  90 70 82     State:	LDAL VState
000B22  1  73 C4        	JMPR DoUser
000B24  1               
000B24  1               
000B24  1  42 61 73 65   FHdr 'Base',0 ; ( -- adr )  User variable
000B28  1  04 0B 1F     
000B2B  1  90 70 84     Base:	LDAL VBase
000B2E  1  73 B8        	JMPR DoUser
000B30  1               
000B30  1               
000B30  1  44 50 4C 03   FHdr 'DPL',0 ; ( -- adr )  User variable
000B34  1  0B 2B        
000B36  1  90 70 86     DPL:	LDAL VDPL
000B39  1  73 AD        	JMPR DoUser
000B3B  1               
000B3B  1               
000B3B  1  46 6C 64 03   FHdr 'Fld',0 ; ( -- adr )  User variable
000B3F  1  0B 36        
000B41  1  90 70 88     Fld:	LDAL VFld
000B44  1  73 A2        	JMPR DoUser
000B46  1               
000B46  1               
000B46  1  43 53 50 03   FHdr 'CSP',0 ; ( -- adr )  User variable
000B4A  1  0B 41        
000B4C  1  90 70 8A     CSP:	LDAL VCSP
000B4F  1  73 97        	JMPR DoUser
000B51  1               
000B51  1               
000B51  1  52 23 02 0B   FHdr 'R#',0 ; ( -- adr )  User variable
000B55  1  4C           
000B56  1  90 70 8C     RNum:	LDAL VRNum
000B59  1  71 0A E8     	JMPD DoUser
000B5C  1               
000B5C  1               
000B5C  1  48 6C 64 03   FHdr 'Hld',0 ; ( -- adr )  User variable
000B60  1  0B 56        
000B62  1  90 70 8E     Hld:	LDAL VHld
000B65  1  71 0A E8     	JMPD DoUser
000B68  1               
000B68  1               
000B68  1               	.if 0
000B68  1                FHdr 'N',0 ; ( -- adr )  User variable
000B68  1               N:	LDAL VN
000B68  1               	JMPD DoUser
000B68  1               	.endif
000B68  1               
000B68  1               
000B68  1  46 50 74 72   FHdr 'FPtr',0 ; ( -- adr )  User variable
000B6C  1  04 0B 62     
000B6F  1  90 70 91     FPtr:	LDAL VFPtr
000B72  1  71 0A E8     	JMPD DoUser
000B75  1               
000B75  1               
000B75  1  46 70 4C 6F   FHdr 'FpLo',0 ; ( -- adr )  User variable
000B79  1  04 0B 6F     
000B7C  1  90 70 93     FpLo:	LDAL VFpLo
000B7F  1  71 0A E8     	JMPD DoUser
000B82  1               
000B82  1               
000B82  1  46 70 48 69   FHdr 'FpHi',0 ; ( -- adr )  User variable
000B86  1  04 0B 7C     
000B89  1  90 70 95     FpHi:	LDAL VFpHi
000B8C  1  71 0A E8     	JMPD DoUser
000B8F  1               
000B8F  1               
000B8F  1  48 65 72 65   FHdr 'Here',0 ; ( -- n )  Leave the address of the next available dictionary location.
000B93  1  04 0B 89     
000B96  1                  ; https://forth-standard.org/standard/core/HERE
000B96  1  91 70 70     Here:	LDAD VDP		; get next available dictionary location
000B99  1  B5 82        	STAX ZW,ModBMRB,0	; push it
000B9B  1  09           	RSR			; return
000B9C  1               
000B9C  1               
000B9C  1  4C 61 74 65   FHdr 'Latest',0 ; ( -- addr )
000BA0  1  73 74 06 0B  
000BA4  1  96           
000BA5  1                  ; Leave the code field address of the topmost word in the CURRENT vocabulary.
000BA5  1  92 70 80     Latest:	LDAI VCurrent
000BA8  1  B5 82        	STAX ZW,ModBMRB,0	; push A
000BAA  1  09           	RSR
000BAB  1               
000BAB  1               
000BAB  1  43 4D 6F 76   FHdr 'CMove',0 ; ( src_addr dest_addr len -- )
000BAF  1  65 05 0B A5  
000BB3  1                  ; Move the specified quantity of bytes beginning at src_addr to dest_addr.
000BB3  1                  ; The contents of src_addr is moved first proceeding toward high memory.
000BB3  1                  ; Further specification is necessary on word addressing computers.
000BB3  1                  ; This would probably run faster if it took advantage of word load & store.
000BB3  1                  ; https://forth-standard.org/standard/string/CMOVE
000BB3  1                  ; Also: CPU6 0xf7 memcpy instruction
000BB3  1  6D A2        CMove:	STXX SW,ModBMRB,0	; save X
000BB5  1  65 81        	LDXX ZW,ModBRPB,0	; pop len
000BB7  1  95 81        	LDAX ZW,ModBRPB,0	; pop dest
000BB9  1  5C           	XAY
000BBA  1  D5 81        	LDBX ZW,ModBRPB,0	; pop src
000BBC  1  55 44        	XFR XW,XW		; len=0?
000BBE  1  14 07        	BZ @Done
000BC0  1  85 21        @4:	LDABX BW,ModBRPB,0	; copy a byte
000BC2  1  A5 61        	STABX YW,ModBRPB,0
000BC4  1  3F           	DCX
000BC5  1  15 F9        	BNZ @4
000BC7  1  65 A1        @Done:	LDXX SW,ModBRPB,0	; restore X
000BC9  1  09           	RSR
000BCA  1               
000BCA  1               
000BCA  1  43 4D 6F 76   FHdr 'CMove>',0 ; ( src_addr dest_addr len -- )
000BCE  1  65 3E 06 0B  
000BD2  1  B3           
000BD3  1                  ; Move the specified quantity of bytes beginning at src_addr to dest_addr.
000BD3  1                  ; Moves proceeding toward low memory.
000BD3  1                  ; This would probably run faster if it took advantage of word load & store.
000BD3  1                  ; https://forth-standard.org/standard/string/CMOVEtop
000BD3  1  6D A2        CMoveG:	STXX SW,ModBMRB,0	; save X
000BD5  1  65 81        	LDXX ZW,ModBRPB,0	; pop len
000BD7  1  95 81        	LDAX ZW,ModBRPB,0	; pop dest
000BD9  1  5C           	XAY
000BDA  1  D5 81        	LDBX ZW,ModBRPB,0	; pop src
000BDC  1  55 44        	XFR XW,XW		; len=0?
000BDE  1  14 0B        	BZ @Done
000BE0  1  50 42        	ADD BW,XW
000BE2  1  50 46        	ADD YW,XW
000BE4  1  85 22        @4:	LDABX BW,ModBMRB,0	; copy a byte
000BE6  1  A5 62        	STABX YW,ModBMRB,0
000BE8  1  3F           	DCX
000BE9  1  15 F9        	BNZ @4
000BEB  1  65 A1        @Done:	LDXX SW,ModBRPB,0	; restore X
000BED  1  09           	RSR
000BEE  1               
000BEE  1               
000BEE  1  4D 6F 76 65   FHdr 'Move',0 ; ( src_addr dest_addr len -- )
000BF2  1  04 0B D3     
000BF5  1                  ; After this move, the u bytes at addr2 contain exactly what the u bytes at addr1 contained before
000BF5  1                  ; the move (no “clobbering” occurs).
000BF5  1                  ; https://forth-standard.org/standard/core/MOVE
000BF5  1  95 88 04     Move:	LDAX ZW,ModNBRB,4
000BF8  1  D5 88 02     	LDBX ZW,ModNBRB,2
000BFB  1  59           	SAB
000BFC  1  10 B5        	BL CMove
000BFE  1  73 D3        	JMPR CMoveG
000C00  1               
000C00  1               
000C00  1               	.if 0
000C00  1                FHdr 'Compare',0 ; ( addr1 u1 addr2 u2 — n )
000C00  1                  ;Compare the string specified by addr1 and u1 to the string specified by addr2 and u2.
000C00  1                  ; The strings are compared, beginning at the given addresses, character by character up
000C00  1                  ; to the length of the shorter string, or until a difference is found.
000C00  1                  ; If both strings are the same up to the length of the shorter string, then the longer
000C00  1                  ; string is greater than the shorter string.
000C00  1                  ; n is -1 if the string specified by addr1 and u1 is less than the string specified by addr2 and u2.
000C00  1                  ; n is zero if the strings are equal.
000C00  1                  ; n is 1 if the string specified by addr1 and u1 is greater than the string specified by addr2 and u2.
000C00  1                  ; https://forth-standard.org/standard/string/COMPARE
000C00  1               Compare:
000C00  1               	STXX SW,ModBMRB,0	; save X
000C00  1               	XFR AW,ZW		; save Z
000C00  1               	STAX SW,ModBMRB,0
000C00  1               
000C00  1               	JSRD Abort ;???
000C00  1               
000C00  1               	LDBX ZW,ModBRPB,0	; pop u2
000C00  1               	LDAZ ZW,ModBRPB,0	; pop addr2
000C00  1               	XAY
000C00  1               	LDAX ZW,ModBRPB,0	; pop u2
000C00  1               	SAB
000C00  1               	STBA ZW			; save u1-u2
000C00  1               	BL @17
000C00  1               	LDAA ZW
000C00  1               @17:	XAY			; save min(u1,u2)
000C00  1               	XFR AW,ZW		; push Z
000C00  1               	STAX SW,ModBMRB,0
000C00  1               
000C00  1               	LDAX ZW,ModNBRB,2	; X = addr2
000C00  1               	XAX
000C00  1               	LDAX ZW,ModNBRB,6	; Z = addr1
000C00  1               	XAZ
000C00  1               @12:	DCR YW,1
000C00  1               	BZ @30
000C00  1               	LDABX XW,ModBRPB,0	; get chars
000C00  1               	LDBBX ZW,ModBRPB,0
000C00  1               	SABB
000C00  1               	BZ @12
000C00  1               
000C00  1               @20:	CLR BW,0
000C00  1               	RLR BW,2
000C00  1               	INR SW,2		; rdrop u1-u2
000C00  1               @22:	LDAA SW			; restore Z
000C00  1               	XAZ
000C00  1               	INR ZW,6		; drop u2, addr2, u1
000C00  1               	STBA ZW			; save n
000C00  1               	LDXX SW,ModBRPB,0	; restore X
000C00  1               	RSR
000C00  1               
000C00  1               @30: ; chars are equal, compare lengths
000C00  1               
000C00  1               	.endif
000C00  1               
000C00  1               
000C00  1  46 69 6C 6C   FHdr 'Fill',0 ; ( adr len value -- )  Fill memory at the address with the specified quantity of bytes value.
000C04  1  04 0B F5     
000C07  1                  ; https://forth-standard.org/standard/core/FILL
000C07  1  D5 81        Fill:	LDBX ZW,ModBRPB,0	; pop value
000C09  1  55 46        Fill1:	XFR YW,XW		; save X
000C0B  1  95 81        	LDAX ZW,ModBRPB,0	; pop len
000C0D  1  38           	INA
000C0E  1  65 81        	LDXX ZW,ModBRPB,0	; pop adr
000C10  1  73 02        	JMPR @8
000C12  1               
000C12  1  E5 41        @2:	STBBX XW,ModBRPB,0	; store a byte
000C14  1  39           @8:	DCA			; count it
000C15  1  15 FB        	BNZ @2
000C17  1  55 64        	XFR XW,YW		; restore X
000C19  1  09           	RSR
000C1A  1               
000C1A  1               
000C1A  1  45 72 61 73   FHdr 'Erase',0 ; ( adr len -- )  Clear a region of memory to zero from addr over len addresses.
000C1E  1  65 05 0C 07  
000C22  1                  ; https://forth-standard.org/standard/core/ERASE
000C22  1  C0 00        Erase:	LDBBL 0			; fill value
000C24  1  73 E3        	JMPR Fill1		; do Fill, & return
000C26  1               
000C26  1               
000C26  1  42 6C 61 6E   FHdr 'Blanks',0 ; ( adr count -- )  Fill an area of memory beginning at addr with blanks.
000C2A  1  6B 73 06 0C  
000C2E  1  22           
000C2F  1                  ; https://forth-standard.org/standard/string/BLANK
000C2F  1  C0 20        Blanks:	LDBBL ' '		; fill value
000C31  1  73 D6        	JMPR Fill1		; do Fill, & return
000C33  1               
000C33  1               ;----------------------
000C33  1               ; 1st Terminal muliplexer port
000C33  1               
000C33  1               Term0CmdStat = $f200	; command (Write) & status (Read)
000C33  1               Term0Data = $f201	; data tx (Write) & rx (Read)
000C33  1               
000C33  1               ;TermInit:
000C33  1               ;	LDABL $c5		; configure UART - 9600,n,8,1
000C33  1               ;	STABD Term0CmdStat
000C33  1               ;	RSR
000C33  1               
000C33  1               
000C33  1  4B 65 79 03   FHdr 'Key',0 ; ( -- n )
000C37  1  0C 2F        
000C39  1                  ; Leave the ASCII value of the next terminal key struck.
000C39  1                  ; https://forth-standard.org/standard/core/KEY
000C39  1               Key:
000C39  1               	.if 1
000C39  1  71 1D 09     	JMPD Tty_GetC
000C3C  1               
000C3C  1               KeyA = Tty_GetC_A ; reads one terminal keystroke to A
000C3C  1               
000C3C  1               	.else
000C3C  1               
000C3C  1               	JSRR KeyA
000C3C  1               	STAX ZW,ModBMRB,0	; push it on param stack
000C3C  1               	RSR			; return
000C3C  1               
000C3C  1               KeyA: ; reads one terminal keystroke to A
000C3C  1               @1:	LDABD Term0CmdStat	; char ready?
000C3C  1               	SRAB
000C3C  1               	BNL @Empty
000C3C  1               	CLA			; get char
000C3C  1               	LDABD Term0Data
000C3C  1               	LDBBL $7f		; strip hi bit
000C3C  1               	ANDB AL,BL
000C3C  1               	RSR
000C3C  1               
000C3C  1               @Empty:	; queue empty
000C3C  1               ;	JSRD Pause		; wait awhile
000C3C  1               	JMPR @1			; & try again
000C3C  1               
000C3C  1               	.endif
000C3C  1               
000C3C  1               
000C3C  1  3F 54 65 72   FHdr '?Terminal',0 ; ( -- f )
000C40  1  6D 69 6E 61  
000C44  1  6C 09 0C 39  
000C48  1                  ; Perform a test of the terminal keyboard for actuation of the break key.
000C48  1                  ; A true flags indicates actuation.
000C48  1                  ; This definition is installation dependent.
000C48  1               QTerminal:
000C48  1               	.if 1
000C48  1  71 1D 2F     	JMPD Tty_Next
000C4B  1               
000C4B  1               QTerminalA:
000C4B  1  7B FB        	JSRR QTerminal
000C4D  1  95 81        	LDAX ZW,ModBRPB,0	; set flags too
000C4F  1  09           	RSR
000C50  1               
000C50  1               	.else
000C50  1               	JSRR QTerminalA
000C50  1               	STAX ZW,ModBMRB,0	; push it
000C50  1               	RSR			; return
000C50  1               
000C50  1               QTerminalA: ; leaves a boolean in A & V flag representing terminal break
000C50  1               	CLA
000C50  1               	LDABD Term0CmdStat
000C50  1               	LDBL 1
000C50  1               	ANDC AW,BW
000C50  1               	RSR
000C50  1               	.endif
000C50  1               
000C50  1               
000C50  1  45 6D 69 74   FHdr 'Emit',0 ; ( n -- )
000C54  1  04 0C 48     
000C57  1                  ; Transmit ASCII char n to the selected output device.
000C57  1                  ; OUT is incremented for each char output.
000C57  1                  ; https://forth-standard.org/standard/core/EMIT
000C57  1               Emit:	; writes one ASCII character to terminal
000C57  1  91 70 78     	LDAD VOut	; count the char
000C5A  1  38           	INA
000C5B  1  B1 70 78     	STAD VOut
000C5E  1               	.if 1
000C5E  1  71 1C C9     	JMPD Tty_PutC
000C61  1               	.else
000C61  1               @1:	LDABD Term0CmdStat ; ready?
000C61  1               	SRAB
000C61  1               	SRAB
000C61  1               	BNL @Full
000C61  1               
000C61  1               	LDAX ZW,ModBRPB,0	; pop n
000C61  1               	STABD Term0Data		; transmit it
000C61  1               	RSR
000C61  1               
000C61  1               @Full:	; queue full
000C61  1               ;	JSRD Pause		; wait awhile
000C61  1               	JMPR @1			; & try again
000C61  1               	.endif
000C61  1               
000C61  1               
000C61  1               EmitA: ; writes one ASCII character in A to terminal
000C61  1  B5 82        	STAX ZW,ModBMRB,0	; push char
000C63  1  F5 A2        	STBX SW,ModBMRB,0	; push B
000C65  1  55 62        	XFR BW,YW		; push Y
000C67  1  F5 A2        	STBX SW,ModBMRB,0
000C69  1  7B EC        	JSRR Emit		; do it
000C6B  1  95 A1        	LDAX SW,ModBRPB,0	; pop Y
000C6D  1  5C           	XAY
000C6E  1  D5 A1        	LDBX SW,ModBRPB,0	; pop B
000C70  1  09           	RSR
000C71  1               
000C71  1               
000C71  1  43 52 02 0C   FHdr 'CR',0 ; ( -- )  Transmit a carriage return and line feed to the selected output device.
000C75  1  57           
000C76  1                  ; https://forth-standard.org/standard/core/CR
000C76  1  80 0D        CR:	LDABL $0d		; send CR
000C78  1  7B E7        	JSRR EmitA
000C7A  1  80 0A        	LDABL $0a		; send LF
000C7C  1  7B E3        	JSRR EmitA
000C7E  1  3A           	CLA			; clear output position
000C7F  1  B1 70 78     	STAD VOut
000C82  1  09           	RSR
000C83  1               
000C83  1               
000C83  1  53 70 61 63   FHdr 'Space',0 ; ( -- )  InseRSR an ASCII blank to the output device.
000C87  1  65 05 0C 76  
000C8B  1                  ; https://forth-standard.org/standard/core/SPACE
000C8B  1  80 20        Space:	LDABL ' '
000C8D  1  73 D2        	JMPR EmitA
000C8F  1               
000C8F  1               
000C8F  1  53 70 61 63   FHdr 'Spaces',0 ; ( n -- )  Transmit n ASCII blanks to the output device.
000C93  1  65 73 06 0C  
000C97  1  8B           
000C98  1                  ; https://forth-standard.org/standard/core/SPACES
000C98  1  73 03        Spaces:	JMPR @8
000C9A  1               
000C9A  1  BC           @2:	STAA ZW			; save n
000C9B  1  7B EE        	JSRR Space		; type 1 space
000C9D  1  9C           @8:	LDAA ZW			; load n
000C9E  1  39           	DCA			; decrement n
000C9F  1  17 F9        	BP @2			; >=0?
000CA1  1  30 81        	INR ZW,2		; drop n
000CA3  1  09           	RSR			; return
000CA4  1               
000CA4  1               
000CA4  1  54 79 70 65   FHdr 'Type',0 ; ( adr len -- )  Transmit len chars from addr to the selected output device.
000CA8  1  04 0C 98     
000CAB  1                  ; https://forth-standard.org/standard/core/TYPE
000CAB  1  9C           Type:	LDAA ZW			; test remaining length
000CAC  1  14 0E        	BZ @9
000CAE  1  39           	DCA			; decrement length
000CAF  1  BC           	STAA ZW
000CB0  1  D5 88 02     	LDBX ZW,ModNBRB,2	; get addr
000CB3  1  85 21        	LDABX BW,ModBRPB,0	; get char
000CB5  1  F5 88 02     	STBX ZW,ModNBRB,2	; save updated addr
000CB8  1  7B A7        	JSRR EmitA		; send to console
000CBA  1  73 EF        	JMPR Type
000CBC  1               
000CBC  1  30 83        @9:	INR ZW,4		; pop len & adr
000CBE  1  09           	RSR			; return
000CBF  1               
000CBF  1               
000CBF  1  48 65 78 03   FHdr 'Hex',0 ; ( -- )  Set the numeric conversion base to sixteen (hexadecimal).
000CC3  1  0C AB        
000CC5  1                  ; https://forth-standard.org/standard/core/HEX
000CC5  1  90 00 10     Hex:	LDAL 16			; Base=16
000CC8  1  73 0C        	JMPR Decim3
000CCA  1               
000CCA  1               
000CCA  1  44 65 63 69   FHdr 'Decimal',0 ; ( -- )  set the numeric conversion base for decimal input-output.
000CCE  1  6D 61 6C 07  
000CD2  1  0C C5        
000CD4  1                  ; https://forth-standard.org/standard/core/DECIMAL
000CD4  1  32 0A        Decimal: CLR AW,10		; Base=10
000CD6  1  B1 70 84     Decim3:	STAD VBase
000CD9  1  09           	RSR
000CDA  1               
000CDA  1               
000CDA  1               	.if 0
000CDA  1                FHdr 'Octal',0 ; ( -- )  set the numeric conversion base for octa input-output.
000CDA  1               Decimal: CLR AW,8		; Base=8
000CDA  1               	JMPR Decim3
000CDA  1               	.endif
000CDA  1               
000CDA  1               
000CDA  1               PadSize = 68	; PAD is 68 ( C/L + a little) bytes above here.
000CDA  1               
000CDA  1  50 61 64 03   FHdr 'Pad',0 ; ( -- adr )  address of the text output buffer, which is a fixed offset above HERE .
000CDE  1  0C D4        
000CE0  1                  ; https://forth-standard.org/standard/core/PAD
000CE0  1  7B 03        Pad:	JSRR PadA		; get Pad in A
000CE2  1  B5 82        	STAX ZW,ModBMRB,0	; push it
000CE4  1  09           	RSR			; return
000CE5  1               
000CE5  1  91 70 70     PadA:	LDAD VDP		; get dictionary location
000CE8  1  D0 00 44     	LDBL PadSize
000CEB  1  50 20        	ADD AW,BW
000CED  1  09           	RSR
000CEE  1               
000CEE  1               
000CEE  1  3C 23 02 0C   FHdr '<#',0 ; ( --- )
000CF2  1  E0           
000CF3  1                  ; Setup for pictured numeric output formatting using the words:
000CF3  1                  ;	<# # #S SIGN #>
000CF3  1                  ; The conversion is done on a double number producting text at PAD .
000CF3  1                  ; https://forth-standard.org/standard/core/num-start
000CF3  1  7B F0        BDigs:	JSRR PadA		; Hld= PAD addr
000CF5  1  B1 70 8E     	STAD VHld
000CF8  1  09           	RSR			; return
000CF9  1               
000CF9  1               
000CF9  1  48 6F 6C 64   FHdr 'Hold',0 ; ( c -- )
000CFD  1  04 0C F3     
000D00  1                  ; Used between <# and #> to insert an ASCII char into a pictured numeric
000D00  1                  ; output string.  e.g. 2E HOLD will place a decimal point.
000D00  1                  ; https://forth-standard.org/standard/core/HOLD
000D00  1  95 81        Hold:	LDAX ZW,ModBRPB,0	; pop c
000D02  1  D1 70 8E     HoldA:	LDBD VHld
000D05  1  A5 22        	STABX BW,ModBMRB,0	; decr addr & store char
000D07  1  F1 70 8E     	STBD VHld
000D0A  1  09           	RSR			; return
000D0B  1               
000D0B  1               
000D0B  1               	.if 0
000D0B  1                FHdr 'HoldS',0 ; ( c-addr u -- )
000D0B  1                  ; Adds the string represented by c-addr u to the pictured numeric output string.
000D0B  1                  ; An ambiguous condition exists if HOLDS executes outside of a <# #> delimited number conversion.
000D0B  1                  ; https://forth-standard.org/standard/core/HOLDS
000D0B  1               HoldS:	LDAX ZW,ModNBRB,2	; get c-addr
000D0B  1               	XAY
000D0B  1               @11:	LDAA ZW			; get u
000D0B  1               	BZ @19
000D0B  1               	DCA
000D0B  1               	STAA ZW
000D0B  1               	LDABX YW,ModBRPB,0	; get char
000D0B  1               	JSRD EmitA
000D0B  1               	JMPR @11
000D0B  1               
000D0B  1               @19:	INR ZW,4		; drop u & c-addr
000D0B  1               	RSR
000D0B  1               	.endif
000D0B  1               
000D0B  1               
000D0B  1  23 3E 02 0D   FHdr '#>',0 ; ( ud -- adr count )
000D0F  1  00           
000D10  1                  ; Terminates numeric output conversion by dropping ud, leaving the text
000D10  1                  ; addres and char count suitable for TYPE.
000D10  1                  ; https://forth-standard.org/standard/core/num-end
000D10  1  91 70 8E     EDigs:	LDAD VHld
000D13  1  B5 88 02     	STAX ZW,ModNBRB,2	; store adr
000D16  1  79 0C E5     	JSRD PadA		; count=PAD-Hld
000D19  1  D1 70 8E     	LDBD VHld
000D1C  1  59           	SAB
000D1D  1  FC           	STBA ZW			; store count
000D1E  1  09           	RSR			; return
000D1F  1               
000D1F  1               
000D1F  1  53 69 67 6E   FHdr 'Sign',0 ; ( n d -- d )
000D23  1  04 0D 10     
000D26  1                  ; Stores an ASCII '-' sign just before a converted numeric output string in the text
000D26  1                  ; buffer when n is negative.  n is discarded, but double number d is maintained.
000D26  1                  ; Must be used between <# and #> .
000D26  1                  ; https://forth-standard.org/standard/core/SIGN
000D26  1  79 02 80     Sign:	JSRD Rot		; bring n to top of param stack
000D29  1  95 81        	LDAX ZW,ModBRPB,0	; <0?
000D2B  1  17 04        	BP @3496
000D2D  1  80 2D        	LDABL '-'		;   append '-'
000D2F  1  15 D1        	BNZ HoldA
000D31  1  09           @3496:	RSR			; return
000D32  1               
000D32  1               
000D32  1  23 01 0D 26   FHdr '#',0 ; ( ud1 -- ud2 )
000D36  1                  ; Generate from a double number ud1, the next ASCII char which is placed in
000D36  1                  ; an output string.  Result ud2 is the quotient after division by BASE, and
000D36  1                  ; is maintained for further processing.  Used between <# and #>.  See #S.
000D36  1                  ; https://forth-standard.org/standard/core/num
000D36  1  91 70 84     Hash:	LDAD VBase
000D39  1  B5 82        	STAX ZW,ModBMRB,0	; ( ud1 u )
000D3B  1  79 06 D5     	JSRD MSlashMod		; ( rem ud2 )
000D3E  1  79 02 80     	JSRD Rot		; ( ud2 remainder )
000D41  1  95 81        	LDAX ZW,ModBRPB,0	; pop remainder
000D43  1  C0 0A        	LDBBL 10		; >=10?
000D45  1  49           	SABB
000D46  1  11 04        	BNL @3517
000D48  1  C0 07        	LDBBL 7			;   change from ASCII digit to letter
000D4A  1  40 31        	ADDB AL,BL
000D4C  1  C0 30        @3517:	LDBBL '0'		; convert to ASCII
000D4E  1  40 31        	ADDB AL,BL
000D50  1  73 B0        	JMPR HoldA		; append to HOLD, & return
000D52  1               
000D52  1               
000D52  1  23 53 02 0D   FHdr '#S',0 ; ( ud1 -- ud2 )
000D56  1  36           
000D57  1                  ; Generates ASCII text in the text output buffer, by the use of #, until
000D57  1                  ; a zero double number ud2 results.  Used between <# and #>.
000D57  1                  ; https://forth-standard.org/standard/core/numS
000D57  1               HashS:
000D57  1  7B DD        @3529:	JSRR Hash		; do a digit
000D59  1  95 88 02     	LDAX ZW,ModNBRB,2	;  until ud1=0
000D5C  1  DC           	LDBA ZW
000D5D  1  53 02        	ORI BW,AW
000D5F  1  15 F6        	BNZ @3529
000D61  1  09           	RSR			; return
000D62  1               
000D62  1               
000D62  1  44 2E 52 03   FHdr 'D.R',0 ; ( d numdigits -- )
000D66  1  0D 57        
000D68  1                  ; Print a signed double number d right aligned in a field n chars wide.
000D68  1                  ; https://forth-standard.org/standard/double/DDotR
000D68  1  95 81        DDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000D6A  1  B5 A2        	STAX SW,ModBMRB,0
000D6C  1  79 02 96     DDotR3:	JSRD Swap		; push sign under d
000D6F  1  79 02 C1     	JSRD Over
000D72  1  79 05 0F     	JSRD DAbs		; d=abs(d)
000D75  1  79 0C F3     	JSRD BDigs		; begin collecting string
000D78  1  7B DD        	JSRR HashS		; do all digits
000D7A  1  7B AA        	JSRR Sign		; do sign
000D7C  1  79 0D 10     DDotR7:	JSRD EDigs		; end collecting string
000D7F  1  95 A1        	LDAX SW,ModBRPB,0	; get numdigits from return stack
000D81  1  DC           	LDBA ZW			; calc # of padding spaces
000D82  1  59           	SAB
000D83  1  F5 82        	STBX ZW,ModBMRB,0	; type that many spaces
000D85  1  79 0C 98     	JSRD Spaces
000D88  1  71 0C AB     	JMPD Type		; type the string, & return
000D8B  1               
000D8B  1               
000D8B  1  55 44 2E 52   FHdr 'UD.R',0 ; ( d numdigits -- )
000D8F  1  04 0D 68     
000D92  1                  ; Print an unsigned double number d right aligned in a field n chars wide.
000D92  1  95 81        UDDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000D94  1  B5 A2        	STAX SW,ModBMRB,0
000D96  1  79 0C F3     	JSRD BDigs		; begin collecting string
000D99  1  7B BC        	JSRR HashS		; do all digits
000D9B  1  73 DF        	JMPR DDotR7
000D9D  1               
000D9D  1               
000D9D  1  55 44 2E 03   FHdr 'UD.',0 ; ( d -- )
000DA1  1  0D 92        
000DA3  1  79 0C F3     UDDot:	JSRD BDigs		; begin collecting string
000DA6  1  7B AF        	JSRR HashS		; do all digits
000DA8  1  79 0D 10     	JSRD EDigs		; end collecting string
000DAB  1  79 0C AB     	JSRD Type
000DAE  1  71 0C 8B     	JMPD Space
000DB1  1               
000DB1  1               
000DB1  1  44 2E 02 0D   FHdr 'D.',0 ; ( d -- )  Print a signed double number from a 32 bit two's complement value.
000DB5  1  A3           
000DB6  1                  ; The high-order 16 bits are most accessable on the stack.  Conversion is
000DB6  1                  ; performed according to the current BASE .  A blank follows.
000DB6  1                  ; https://forth-standard.org/standard/double/Dd
000DB6  1  79 09 E5     DDot:	JSRD Zero		; push min # of digits
000DB9  1  7B AD        	JSRR DDotR		; do D.R
000DBB  1  71 0C 8B     	JMPD Space		; type a space, & return
000DBE  1               
000DBE  1               
000DBE  1  2E 52 02 0D   FHdr '.R',0 ; ( n numdigits -- )
000DC2  1  B6           
000DC3  1                  ; https://forth-standard.org/standard/core/DotR
000DC3  1  95 81        DotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000DC5  1  B5 A2        	STAX SW,ModBMRB,0
000DC7  1  79 06 37     	JSRD SToD		; convert n to double
000DCA  1  73 A0        	JMPR DDotR3		; do D.R, & return
000DCC  1               
000DCC  1               
000DCC  1  55 2E 52 03   FHdr 'U.R',0 ; ( u numdigits -- )
000DD0  1  0D C3        
000DD2  1                  ; https://forth-standard.org/standard/core/UDotR
000DD2  1  95 81        UDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000DD4  1  B5 A2        	STAX SW,ModBMRB,0
000DD6  1  3A           	CLA			; convert u to double
000DD7  1  B5 82        	STAX ZW,ModBMRB,0
000DD9  1  73 91        	JMPR DDotR3		; do D.R, & return
000DDB  1               
000DDB  1               
000DDB  1  55 2E 02 0D   FHdr 'U.',0 ; ( u -- )
000DDF  1  D2           
000DE0  1                  ; https://forth-standard.org/standard/core/Ud
000DE0  1  79 09 E5     UDot:	JSRD Zero
000DE3  1  7B ED        	JSRR UDotR
000DE5  1  71 0C 8B     	JMPD Space
000DE8  1               
000DE8  1               
000DE8  1  2E 01 0D E0   FHdr '.',0 ; ( n -- )  Print a number from a signed 16 bit two's complement value,
000DEC  1                  ; converted according to the numeric BASE.  A traling blank follows.
000DEC  1                  ; https://forth-standard.org/standard/core/d
000DEC  1  79 06 37     Dot:	JSRD SToD		; convert n to double
000DEF  1  73 C5        	JMPR DDot		; do D. , & return
000DF1  1               
000DF1  1               
000DF1  1  3F 01 0D EC   FHdr '?',0 ; ( adr -- )  Print the value contained at the address
000DF5  1                  ; in free format according to the current base.
000DF5  1                  ; https://forth-standard.org/standard/tools/q
000DF5  1  79 07 96     Ques:	JSRD At			; fetch the word at addr
000DF8  1  73 F2        	JMPR Dot		; type it, & return
000DFA  1               
000DFA  1               
000DFA  1               	.if 0
000DFA  1                FHdr 'Accept',0 ; ( addr u1 -- u2 )  Receives u1 characters (or until carriage return) from the
000DFA  1                  ; terminal keyboard and stores them, starting at the address.
000DFA  1                  ; The count of received characters is returned.
000DFA  1               	.endif
000DFA  1               
000DFA  1               
000DFA  1  45 78 70 65   FHdr 'Expect',0 ; ( addr count -- )
000DFE  1  63 74 06 0D  
000E02  1  F5           
000E03  1                  ; Transfer chars from the terminal to address, until a "return" or the count of
000E03  1                  ; chars have been received.  One or more nulls area added at the end of the text.
000E03  1  6D A2        Expect:	STXX SW,ModBMRB,0	; push X
000E05  1  32 40        	CLR XW,0		; index=0
000E07  1  79 01 0F     @next:	JSRD KeyA
000E0A  1  D1 70 60     	LDBD VBS		; backspace?
000E0D  1  49           	SABB
000E0E  1  14 20        	BZ @bs
000E10  1  C0 0D        	LDBBL $0D		; return?
000E12  1  49           	SABB
000E13  1  14 0F        	BZ @cr
000E15  1               
000E15  1  D5 88 02     	LDBX ZW,ModNBRB,2
000E18  1  50 42        	ADD BW,XW
000E1A  1  A9           	STABA BW		; store the char
000E1B  1  3E           	INXC			; advance index
000E1C  1  79 0C 61     	JSRD EmitA		; update the terminal
000E1F  1  DC           	LDBA ZW			; at end_of_line?
000E20  1  51 42        	SUB BW,XW
000E22  1  11 E3        	BNL @next
000E24  1               
000E24  1  D5 88 02     @cr:	LDBX ZW,ModNBRB,2	; insert trailing NULLs
000E27  1  50 42        	ADD BW,XW
000E29  1  3A           	CLA
000E2A  1  B9           	STAA BW
000E2B  1  65 A1        	LDXX SW,ModBRPB,0	; pop X
000E2D  1  30 83        	INR ZW,4		; TwoDrop
000E2F  1  09           	RSR
000E30  1               
000E30  1  55 42        @bs:	XFR BW,XW		; at begin_of_line?
000E32  1  14 D3        	BZ @next
000E34  1  3F           	DCX			; back up ptr
000E35  1  80 08        	LDABL $08		; back up terminal
000E37  1  79 0C 61     	JSRD EmitA
000E3A  1  73 CB        	JMPR @next		; next
000E3C  1               
000E3C  1               
000E3C  1  51 75 65 72   FHdr 'Query',0 ; ( -- )
000E40  1  79 05 0E 03  
000E44  1                  ; Input 80 chars of text (or until a "return") from the operators terminal.
000E44  1                  ; Text is positioned at the address contained in TIB with IN set to zero.
000E44  1  3A           Query:	CLA			; IN=0
000E45  1  B1 70 76     	STAD VIn
000E48  1  91 70 68     	LDAD VTIB		; buffer addr
000E4B  1  B5 82        	STAX ZW,ModBMRB,0
000E4D  1  90 00 50     	LDAL 80			; 80 characters from terminal
000E50  1  B5 82        	STAX ZW,ModBMRB,0
000E52  1  73 AF        	JMPR Expect
000E54  1               
000E54  1               
000E54  1  28 41 62 6F   FHdr '(Abort)',0 ;
000E58  1  72 74 29 07  
000E5C  1  0E 44        
000E5E  1               ; Executes after an error when WARNING is -1.  This word normally executes ABORT,
000E5E  1               ; but may be altered (with care) to a user's alternative procedure.
000E5E  1  71 16 DC     PAbort:	JMPD Abort
000E61  1               
000E61  1               
000E61  1  45 72 72 6F   FHdr 'Error',0 ; ( error_number -- in blk )  Execute error notification and restart of the system.
000E65  1  72 05 0E 5E  
000E69  1                  ; WARNING is first examined.  If 1, the text of line n, relative to screen 4 of drive 0 is
000E69  1                  ; printed.  This line number may be positive or negative, and beyond just screen 4.
000E69  1                  ; If WARNING=0, n is just printed as a message number (non disc installation).
000E69  1                  ; If WARNING is -1, the definition (ABORT) is executed, which executes the system ABORT.
000E69  1                  ; The user may cautionsly modify this execute by altering (ABORT) .
000E69  1                  ; fig-FORTH saves the contents of IN and BLK to assist in determinging the location of the error.
000E69  1                  ; Final action is execution of QUIT .
000E69  1  91 70 6C     Error:	LDAD VWarning		; Warning<0?
000E6C  1  16 F0        	BM PAbort
000E6E  1  79 0C 8B     	JSRD Space
000E71  1  79 0B 96     	JSRD Here		; type the interpreted word
000E74  1  79 07 ED     	JSRD Count
000E77  1  79 0C AB     	JSRD Type
000E7A  1  79 13 8B     	JSRD PDotQuote		; type "  ? "
000E7D  1  05 20 20 3F  	.byte 5,'  ?',0,' '	; "?\0 " sequence triggers simulator to stop feeding text from file
000E81  1  00 20        
000E83  1  79 18 ED     	JSRD Message		; type the error
000E86  1  79 02 45     	JSRD EmptyStack		; empty the param stack
000E89  1  79 13 8B     	JSRD PDotQuote		; show text position
000E8C  1  07 20 42 6C  	.byte 7," Block="
000E90  1  6F 63 6B 3D  
000E94  1  91 70 74     	LDAD VBlk
000E97  1  B5 82        	STAX ZW,ModBMRB,0
000E99  1  79 0D EC     	JSRD Dot
000E9C  1  79 13 8B     	JSRD PDotQuote
000E9F  1  07 4F 66 66  	.byte 7,"Offset="
000EA3  1  73 65 74 3D  
000EA7  1  91 70 76     	LDAD VIn
000EAA  1  B5 82        	STAX ZW,ModBMRB,0
000EAC  1  79 0D EC     	JSRD Dot
000EAF  1  71 16 88     	JMPD Quit		; restart the interpreter
000EB2  1               
000EB2  1               
000EB2  1  3F 53 74 61   FHdr '?Stack',0 ; ( -- )  Issue an error message if the stack is out of bounds.
000EB6  1  63 6B 06 0E  
000EBA  1  69           
000EBB  1  90 71 16     QStack:	LDAL TOS+1		; param atack beyond empty?
000EBE  1  51 80        	SUB AW,ZW
000EC0  1  10 08        	BL @underflow
000EC2  1  90 70 9D     	LDAL BOS+6		; param stack beyond full?
000EC5  1  51 80        	SUB AW,ZW
000EC7  1  11 05        	BNL @overflow
000EC9  1  09           	RSR
000ECA  1               
000ECA  1  32 21        @underflow: CLR BW,Err_StackUnderflow
000ECC  1  73 26        	JMPR ErrorY
000ECE  1               
000ECE  1  D0 00 07     @overflow: LDBL Err_StackOverflow
000ED1  1  73 21        	JMPR ErrorY
000ED3  1               
000ED3  1               
000ED3  1  3F 45 72 72   FHdr '?Error',0 ; ( f n -- )  Issue an error message number n, if f is true;
000ED7  1  6F 72 06 0E  
000EDB  1  BB           
000EDC  1  D5 81        QErr:	LDBX ZW,ModBRPB,0	; pop n
000EDE  1  95 81        QErrY:	LDAX ZW,ModBRPB,0	; f true?
000EE0  1  15 14        	BNZ ErrorY2		;   signal error
000EE2  1  09           	RSR			; return
000EE3  1               
000EE3  1               
000EE3  1  3F 43 6F 6D   FHdr '?Comp',0 ; ( -- )  Issue error message if not compiling.
000EE7  1  70 05 0E DC  
000EEB  1  D0 00 11     QComp:	LDBL Err_CompileOnly
000EEE  1  91 70 82     	LDAD VState		; not compiling?
000EF1  1  14 01        	BZ ErrorY		;   signal error
000EF3  1  09           	RSR			; return
000EF4  1               
000EF4  1               ErrorY:				; error code in B
000EF4  1  31 81        	DCR ZW,2
000EF6  1  FC           ErrorY2: STBA ZW
000EF7  1  71 0E 69     	JMPD Error
000EFA  1               
000EFA  1               
000EFA  1  3F 45 78 65   FHdr '?Exec',0 ; ( -- )  Issue an error message if not executing.
000EFE  1  63 05 0E EB  
000F02  1  D0 00 12     QExec:	LDBL Err_ExecuteOnly
000F05  1  91 70 82     	LDAD VState		; compiling?
000F08  1  15 EA        	BNZ ErrorY		;   signal error
000F0A  1  09           	RSR			; return
000F0B  1               
000F0B  1               
000F0B  1  3F 50 61 69   FHdr '?Pairs',0 ; ( n1 n2 -- )  Issue an error message if n1 != n2.
000F0F  1  72 73 06 0F  
000F13  1  02           
000F14  1                  ; The message indicates that compiled conditionals do not match.
000F14  1  95 81        QPairs:	LDAX ZW,ModBRPB,0	; pop n2
000F16  1  D5 81        QPairsA: LDBX ZW,ModBRPB,0	; pop n1
000F18  1  59           	SAB			; n2<>n1?
000F19  1  14 D0        	BZ QComp		; also verify we're compiling
000F1B  1  D0 00 13     	LDBL Err_ConditionalsNotPaired
000F1E  1  73 D6        	JMPR ErrorY2		;   signal error
000F20  1               
000F20  1               
000F20  1  21 43 53 50   FHdr '!CSP',0 ; ( -- )  Save the param stack index in CSP. Used as part of the compiler security.
000F24  1  04 0F 14     
000F27  1  55 80        SCSP:	XFR AW,ZW
000F29  1  B1 70 8A     	STAD VCSP
000F2C  1  09           	RSR
000F2D  1               
000F2D  1               
000F2D  1  3F 43 53 50   FHdr '?CSP',0 ; ( -- )  Issue error message if stack index <> value saved in CSP.
000F31  1  04 0F 27     
000F34  1  D0 00 14     QCSP:	LDBL Err_DefinitionNotFinished
000F37  1  91 70 8A     	LDAD VCSP		; param stack index different than saved?
000F3A  1  51 80        	SUB AW,ZW
000F3C  1  15 B6        	BNZ ErrorY		;   signal error
000F3E  1  09           	RSR			; return
000F3F  1               
000F3F  1               
000F3F  1  3F 4C 6F 61   FHdr '?Loading',0 ; ( -- )  Issue an error message if not loading.
000F43  1  64 69 6E 67  
000F47  1  08 0F 34     
000F4A  1  D0 00 16     QLoad:	LDBL Err_UseOnlyWhenLoading
000F4D  1  91 70 74     	LDAD VBlk		; no block?
000F50  1  14 A2        	BZ ErrorY		;   signal error
000F52  1  09           	RSR			; return
000F53  1               
000F53  1               
000F53  1               	.if 0
000F53  1                FHdr 'Buffer:',0
000F53  1                  ; Compile: ( u "<spaces>name" -- )
000F53  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Create a definition for name, with the execution
000F53  1                  ;   semantics defined below. Reserve u address units at an aligned address.
000F53  1                  ;   Contiguity of this region with any other region is undefined.
000F53  1                  ; name Execution:
000F53  1                  ;   ( -- a-addr )
000F53  1                  ;   a-addr is the address of the space reserved by BUFFER: when it defined name.
000F53  1                  ;   The program is responsible for initializing the contents.
000F53  1                  ; https://forth-standard.org/standard/core/BUFFERColon
000F53  1               BufferColon:
000F53  1               	JSRD Create
000F53  1               	JMPR Allot
000F53  1               	.endif
000F53  1               
000F53  1               
000F53  1  41 6C 6C 6F   FHdr 'Allot',0 ; ( n -- )  Add the signed number to the dictionary pointer DP.
000F57  1  74 05 0F 4A  
000F5B  1                  ; May be used to reserve dictionary space or re-origin memory.
000F5B  1                  ; n is with regard to computer address type (byte or word).
000F5B  1                  ; https://forth-standard.org/standard/core/ALLOT
000F5B  1  95 81        Allot:	LDAX ZW,ModBRPB,0	; pop n
000F5D  1  D1 70 70     AllotA:	LDBD VDP		; add to DP
000F60  1  58           	AAB
000F61  1               AllotCheck:
000F61  1  F1 70 70     	STBD VDP
000F64  1  90 6F BC     	LDAL DictTop-PadSize	; out of space?
000F67  1  59           	SAB
000F68  1  D0 00 02     	LDBL Err_DictionaryFull
000F6B  1  11 87        	BNL ErrorY
000F6D  1  09           	RSR			; return
000F6E  1               
000F6E  1               
000F6E  1  55 6E 75 73   FHdr 'Unused',0 ; ( -- u )  Return the space remaining in the region addressed by HERE, in address units.
000F72  1  65 64 06 0F  
000F76  1  5B           
000F77  1                  ; https://forth-standard.org/standard/core/UNUSED
000F77  1  90 6F BC     Unused:	LDAL DictTop-PadSize
000F7A  1  D1 70 70     	LDBD VDP
000F7D  1  59           	SAB
000F7E  1  F5 82        	STBX ZW,ModBMRB,0
000F80  1  09           	RSR
000F81  1               
000F81  1               
000F81  1               ;----------------------------------------------------------------------
000F81  1               ; Random #s
000F81  1               
000F81  1  52 6E 64 53   FHdr 'RndState',0  ; 2Variable
000F85  1  74 61 74 65  
000F89  1  08 0F 77     
000F8C  1               RndState1:
000F8C  1  90 71 9D     	LDAL RndState
000F8F  1  B5 82        	STAX ZW,ModBMRB,0
000F91  1  09           	RSR
000F92  1               
000F92  1               
000F92  1               	.if 0
000F92  1                FHdr 'SRand',0 ; ( d -- ) set random # state
000F92  1                  ; Pause is also modifying RndState
000F92  1               SRand:	LDBX ZW,ModBRPB,0
000F92  1               	LDAX ZW,ModBRPB,0
000F92  1               	JMPR Rand8
000F92  1               	.endif
000F92  1               
000F92  1               
000F92  1  52 61 6E 64   FHdr 'Rand',0 ; ( -- n )  generate next random #
000F96  1  04 0F 8C     
000F99  1                  ; https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Galois_LFSRs
000F99  1                  ; https://en.wikipedia.org/wiki/Xorshift
000F99  1               Rand: ; 32bit Galois LFSR
000F99  1  91 71 9F     	LDAD 2+RndState		; BA=state
000F9C  1  D1 71 9D     	LDBD 0+RndState
000F9F  1  15 04        	BNZ @39			; fix state=0
000FA1  1  5C           	XAY
000FA2  1  15 01        	BNZ @39
000FA4  1  38           	INA
000FA5  1               @39:
000FA5  1  07           	RL			; BA>>=1
000FA6  1  36 20        	RRR BW,1
000FA8  1  36 00        	RRR AW,1
000FAA  1  11 0E        	BNL @49
000FAC  1               
000FAC  1  55 46        	XFR YW,XW		; save X
000FAE  1  60 D0 00     	LDXL $d000		; BA^=$d0000001
000FB1  1  54 42        	ORE BW,XW
000FB3  1  60 00 01     	LDXL $0001
000FB6  1  54 40        	ORE AW,XW
000FB8  1  55 64        	XFR XW,YW		; restore X
000FBA  1  B5 82        @49:	STAX ZW,ModBMRB,0	; return value
000FBC  1  F1 71 9D     Rand8:	STBD 0+RndState		; save state
000FBF  1  B1 71 9F     	STAD 2+RndState
000FC2  1  09           	RSR
000FC3  1               
000FC3  1               
000FC3  1               	.if 0
000FC3  1                FHdr 'RndTest1',0 ; ( -- d )  test Rand period
000FC3  1               	LDBD 0+RndState		; push original state
000FC3  1               	LDAD 2+RndState
000FC3  1               	STAX SW,ModBMRB,0
000FC3  1               	STBX SW,ModBMRB,0
000FC3  1               	CLA			; 0.
000FC3  1               	STAX ZW,ModBMRB,0
000FC3  1               	STAX ZW,ModBMRB,0
000FC3  1               @3:
000FC3  1               	LDAA ZW			; increment d
000FC3  1               	INA
000FC3  1               	STAA ZW
000FC3  1               	BNZ @19
000FC3  1               	LDAX ZW,ModNBRB,2
000FC3  1               	INA
000FC3  1               	STAX ZW,ModNBRB,2
000FC3  1               	JSRD EX4A
000FC3  1               	JSRD Space
000FC3  1               @19:
000FC3  1               	JSRR Rand		; gen next number
000FC3  1               	INR ZW,2		;   drop result
000FC3  1               	XAY
000FC3  1               	LDAA SW			;  compare
000FC3  1               	SAB
000FC3  1               	BNZ @3
000FC3  1               	LDAX SW,ModNBRB,2
000FC3  1               	SUB AW,YW
000FC3  1               	BNZ @3
000FC3  1               
000FC3  1               	INR SW,4		; rdrop starting state
000FC3  1               	JMPD Swap		; fix count
000FC3  1               	.endif
000FC3  1               
000FC3  1               
000FC3  1  52 61 6E 64   FHdr 'RandM',0 ; ( umod -- u ) random integer between 0 & umod-1
000FC7  1  4D 05 0F 99  
000FCB  1  95 81        RandM:	LDAX ZW,ModBRPB,0	; save umod
000FCD  1  B5 A2        	STAX SW,ModBMRB,0
000FCF  1  7B C8        	JSRR Rand		; get next random #
000FD1  1  F5 A2        	STBX SW,ModBMRB,0	; save hi part
000FD3  1  D5 A1        	LDBX SW,ModBRPB,0
000FD5  1  F5 82        	STBX ZW,ModBMRB,0
000FD7  1  79 06 6F     	JSRD UMSlashMod
000FDA  1  30 81        	INR ZW,2		; drop quotient
000FDC  1  09           	RSR
000FDD  1               
000FDD  1               
000FDD  1  44 65 66 65   FHdr 'Defer',0 ; ( "<spaces>name" -- )  https://forth-standard.org/standard/core/DEFER
000FE1  1  72 05 0F CB  
000FE5  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Create a definition for name with the execution semantics defined below.
000FE5  1                  ; name Execution:
000FE5  1                  ;   ( i * x -- j * x )
000FE5  1                  ;   Execute the xt that name is set to execute. An ambiguous condition exists if name has not been set to execute an xt.
000FE5  1  79 12 14     Defer:	JSRD HeaderComma	; compile word header
000FE8  1  90 16 DC     	LDAL Abort
000FEB  1  71 10 51     	JMPD JmpCommaA
000FEE  1               
000FEE  1               
000FEE  1  44 65 66 65   FHdr 'Defer@',0 ; ( xt1 -- xt2 )  https://forth-standard.org/standard/core/DEFERFetch
000FF2  1  72 40 06 0F  
000FF6  1  E5           
000FF7  1                  ;  xt2 is the execution token xt1 is set to execute. An ambiguous condition exists if xt1 is not the execution token of a word defined by DEFER, or if xt1 has not been set to execute an xt.
000FF7  1               DeferAt:
000FF7  1  9C           	LDAA ZW			; get xt1
000FF8  1               	; check that the xt1 word is a Defer ?
000FF8  1  D5 08 01     	LDBX AW,ModNBRB,1	; get jMPD operand
000FFB  1  FC           	STBA ZW			; store xt2
000FFC  1  09           	RSR
000FFD  1               
000FFD  1               
000FFD  1  44 65 66 65   FHdr 'Defer!',0 ; ( xt2 xt1 -- )  https://forth-standard.org/standard/core/DEFERStore
001001  1  72 21 06 0F  
001005  1  F7           
001006  1                  ; Set the word xt1 to execute xt2. An ambiguous condition exists if xt1 is not for a word defined by DEFER.
001006  1               DeferStore:
001006  1  95 81        	LDAX ZW,ModBRPB,0	; pop xt1
001008  1               	; check that the xt1 word is a Defer ?
001008  1  D5 81        	LDBX ZW,ModBRPB,0	; pop xt2
00100A  1  F5 08 01     	STBX AW,ModNBRB,1	; store xt2 into JMPD operand
00100D  1  09           	RSR
00100E  1               
00100E  1               
00100E  1               	.if 0
00100E  1               
00100E  1                FHdr 'Is',ha_immedate ;
00100E  1                  ; Interpretation:
00100E  1                  ;   ( xt "<spaces>name" -- )
00100E  1                  ;   Skip leading spaces and parse name delimited by a space. Set name to execute xt.
00100E  1                  ;   An ambiguous condition exists if name was not defined by DEFER.
00100E  1                  ; Compilation:
00100E  1                  ;   ( "<spaces>name" -- )
00100E  1                  ;   Skip leading spaces and parse name delimited by a space. Append the run-time semantics given below to the current definition.
00100E  1                  ;   An ambiguous condition exists if name was not defined by DEFER.
00100E  1                  ; Run-time:
00100E  1                  ;   ( xt -- )
00100E  1                  ;   Set name to execute xt.
00100E  1                  ; An ambiguous condition exists if POSTPONE, [COMPILE], ['] or ' is applied to IS.
00100E  1                  ; https://forth-standard.org/standard/core/IS
00100E  1               Is:	JSRD Tick		; look up the name
00100E  1               	LDBD VState		; compiling?
00100E  1               	BZ DeferStore
00100E  1               
00100E  1               	JSRD Swap
00100E  1               	LDABL $90		; LDAL xt
00100E  1               	JSRD CCommaA
00100E  1               	JSRD Comma
00100E  1               	LDABL $b1		; STAD name
00100E  1               	JSRD CCommaA
00100E  1               	JMPD Comma
00100E  1               
00100E  1               
00100E  1                FHdr 'Action-Of',ha_immediate ; https://forth-standard.org/standard/core/ACTION-OF
00100E  1                  ; Interpretation:
00100E  1                  ;   ( "<spaces>name" -- xt )
00100E  1                  ;   Skip leading spaces and parse name delimited by a space. xt is the execution token that name is set to execute.
00100E  1                  ;   An ambiguous condition exists if name was not defined by DEFER, or if the name has not been set to execute an xt.
00100E  1                  ; Compilation:
00100E  1                  ;   ( "<spaces>name" -- )
00100E  1                  ;   Skip leading spaces and parse name delimited by a space. Append the run-time semantics given below to the current definition.
00100E  1                  ;   An ambiguous condition exists if name was not defined by DEFER.
00100E  1                  ; Run-time:
00100E  1                  ;   ( -- xt )
00100E  1                  ;   xt is the execution token that name is set to execute. An ambiguous condition exists if name has not been set to execute an xt.
00100E  1                  ;   An ambiguous condition exists if POSTPONE, [COMPILE], ['] or ' is applied to ACTION-OF.
00100E  1               	JSRD Tick		; look up the inline name
00100E  1               	LDAA ZW			; get name addr
00100E  1               	LDABA AW		; check word 1st opcode
00100E  1               	LDBBL $71		;    for JMPD
00100E  1               	SABB
00100E  1               	BNZ @Abort
00100E  1               
00100E  1               	LDAD VState		; compiling?
00100E  1               	BZ DeferAt
00100E  1               
00100E  1               	LDABL $91		; LDAD name+1
00100E  1               	JSRD CCommaA
00100E  1               	JSRD OnePlus
00100E  1               	JSRD Comma
00100E  1               	JMPD PushAComma		; STAX ZW,ModBMRB,0	; push it
00100E  1               
00100E  1               	.endif
00100E  1               
00100E  1               
00100E  1               	.if 0
00100E  1               
00100E  1                FHdr 'Align',ha_inline ; ( -- )  https://forth-standard.org/standard/core/ALIGN
00100E  1                  ; If the data-space pointer is not aligned, reserve enough space to align it.
00100E  1               	; do nothing, CPU6 doesn't care
00100E  1               	.dbyt INL_End
00100E  1               
00100E  1               
00100E  1                FHdr 'Aligned',ha_inline ; ( addr -- a-addr )  https://forth-standard.org/standard/core/ALIGNED
00100E  1                  ; a-addr is the first aligned address greater than or equal to addr.
00100E  1               		; do nothing, CPU6 doesn't care
00100E  1               	.dbyt INL_End
00100E  1               
00100E  1               	.endif
00100E  1               
00100E  1               
00100E  1               	.if 0
00100E  1                FHdr 'Postpone',0
00100E  1                  ; Interpretation:
00100E  1                  ;   Interpretation semantics for this word are undefined.
00100E  1                  ; Compilation:
00100E  1                  ;   ( "<spaces>name" -- )
00100E  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Find name.
00100E  1                  ;   Append the compilation semantics of name to the current definition.
00100E  1                  ;   An ambiguous condition exists if name is not found.
00100E  1                  ; https://forth-standard.org/standard/core/POSTPONE
00100E  1               	JSRD Abort ;???
00100E  1               	.endif
00100E  1               
00100E  1               
00100E  1               	.if 0
00100E  1                FHdr 'Recurse',ha_immediate
00100E  1                  ; Interpretation:
00100E  1                  ;   Interpretation semantics for this word are undefined.
00100E  1                  ; Compilation:
00100E  1                  ;   ( -- )
00100E  1                  ;   Append the execution semantics of the current definition to the current definition.
00100E  1                  ;   An ambiguous condition exists if RECURSE appears in a definition after DOES>.
00100E  1                  ; https://forth-standard.org/standard/core/RECURSE
00100E  1               	LDBI VCurrent		; start of last word
00100E  1               	JMPD JsrCommaA
00100E  1               	.endif
00100E  1               
00100E  1               
00100E  1               	.if 0
00100E  1                FHdr '[Compile]',ha_immediate  ; https://forth-standard.org/standard/core/BracketCOMPILE
00100E  1                  ; Interpretation:
00100E  1                  ;   Interpretation semantics for this word are undefined.
00100E  1                  ; Compilation:
00100E  1                  ;   ( "<spaces>name" -- )
00100E  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Find name. If name has other than default
00100E  1                  ; compilation semantics, append them to the current definition; otherwise append the execution semantics of name.
00100E  1                  ; An ambiguous condition exists if name is not found.
00100E  1               	JSRD Tick
00100E  1               	JMPR CompileComma
00100E  1               	.endif
00100E  1               
00100E  1               
00100E  1  43 6F 6D 70   FHdr 'Compile,',0 ; ( addr -- ) compile a call to a word
001012  1  69 6C 65 2C  
001016  1  08 10 06     
001019  1                  ; Not quite standard: it expects an nfa so it can look at the ha_inline flag bit
001019  1                  ; https://forth-standard.org/standard/core/COMPILEComma
001019  1               CompileComma:
001019  1  95 81        	LDAX ZW,ModBRPB,0	; pop addr from param stack
00101B  1               CompileCommaA: ; nfa (name field addr, also code addr) in A
00101B  1  C5 08 FD     	LDBBX AW,ModNBRB,$fd	; get flag & length byte
00101E  1  17 1E        	BP JsrCommaA		; not ha_inline, do JSR
001020  1  5C           	XAY			; copy inline bytes until marker
001021  1  9B           @11:	LDAA YW
001022  1  D0 09 09     	LDBL INL_End
001025  1  59           	SAB
001026  1  14 0C        	BZ @19
001028  1  45 01        	XFRB AL,AH
00102A  1  7E 61        	PUSH YH,2
00102C  1  7B 49        	JSRR CCommaA
00102E  1  7F 61        	POP YH,2
001030  1  30 60        	INR YW,1
001032  1  73 ED        	JMPR @11
001034  1  09           @19:	RSR
001035  1               
001035  1               
001035  1  4A 73 72 2C   FHdr 'Jsr,',0 ; ( adr -- )  compile a "JSRD adr" to call a word
001039  1  04 10 19     
00103C  1  95 81        	LDAX ZW,ModBRPB,0	; pop adr
00103E  1               JsrCommaA:
00103E  1  B5 A2        	STAX SW,ModBMRB,0	; save addr
001040  1  80 79        	LDABL $79		; compile "JSRD direct" opcode
001042  1               Compile16:
001042  1  7B 33        	JSRR CCommaA		; compile opcode
001044  1  95 A1        	LDAX SW,ModBRPB,0	; compile 2byte operand, & return
001046  1  73 15        	JMPR CommaA
001048  1               
001048  1               
001048  1  4A 6D 70 2C   FHdr 'Jmp,',0 ; ( adr -- )  compile a "JMPD adr"
00104C  1  04 10 3C     
00104F  1               JmpComma:
00104F  1  95 81        	LDAX ZW,ModBRPB,0
001051  1               JmpCommaA:
001051  1  B5 A2        	STAX SW,ModBMRB,0	; save operand
001053  1  80 71        	LDABL $71		; "JMPD abs" opcode
001055  1  73 EB        	JMPR Compile16
001057  1               
001057  1               
001057  1               
001057  1  2C 01 10 4F   FHdr ',',0 ; ( n -- )  Append n onto the dictionary.
00105B  1                  ; https://forth-standard.org/standard/core/Comma
00105B  1  95 81        Comma:	LDAX ZW,ModBRPB,0	; pop n
00105D  1  D1 70 70     CommaA:	LDBD VDP		; store into dictionary
001060  1  B5 21        	STAX BW,ModBRPB,0
001062  1  3A           Comma2:	CLA			; store 0 (not required, helps in case of interrupted compile)
001063  1  B9           	STAA BW
001064  1  71 0F 61     	JMPD AllotCheck
001067  1               
001067  1               
001067  1  32 2C 02 10   FHdr '2,',0 ; ( d -- )  Append d onto the dictionary
00106B  1  5B           
00106C  1               TwoComma:
00106C  1  7B ED        	JSRR Comma	; do hi word
00106E  1  73 EB        	JMPR Comma	; do lo word, & return
001070  1               
001070  1               
001070  1  43 2C 02 10   FHdr 'C,',0 ; ( n -- )  Append byte n onto the dictionary.
001074  1  6C           
001075  1                  ; https://forth-standard.org/standard/core/CComma
001075  1  95 81        CComma:	LDAX ZW,ModBRPB,0	; pop n
001077  1  D1 70 70     CCommaA: LDBD VDP		; store
00107A  1  A5 21        	STABX BW,ModBRPB,0
00107C  1  73 E4        	JMPR Comma2		; finish & return
00107E  1               
00107E  1               
00107E  1               LdbaComma: ; ( d -- )  compile ldb # & lda #
00107E  1  80 D0        	LDABL $d0		; LDBL n	do hi word
001080  1  7B 06        	JSRR LdComma
001082  1  73 02        	JMPR LdaComma		;		do lo word
001084  1               
001084  1               LdaCommaA: ; compile lda #
001084  1  B5 82        	STAX ZW,ModBMRB,0
001086  1               LdaComma: ; compile lda #
001086  1  80 90        	LDABL $90		; LDAL n
001088  1  7B ED        LdComma: JSRR CCommaA
00108A  1  73 CF        	JMPR Comma
00108C  1               
00108C  1               
00108C  1                 .if 0
00108C  1                FHdr 'Compile',0 ; ( -- )
00108C  1                  ; see Compile,
00108C  1                  ; When the word containing COMPILE executes, the execution address of the word
00108C  1                  ; following COMPILE is copied (compiled) into the dictionary.  This allows
00108C  1                  ; specific compilation situations to be handled in addition to simply compiling
00108C  1                  ; an execution address (which the interpreter already does).
00108C  1               Compile:
00108C  1               	JSRD QComp	; verify we're compiling
00108C  1               	LDAX SW,ModBRPB,0 ; get the word following the call to me
00108C  1               	JMPR CompileCommaA ; compile the call, & return
00108C  1                 .endif
00108C  1               
00108C  1               
00108C  1  42 72 61 6E   FHdr 'Branch,',0 ; ( DestAddr branch_opcode -- ) compile a branch back
001090  1  63 68 2C 07  
001094  1  10 75        
001096  1               BranchComma:
001096  1  95 81        	LDAX ZW,ModBRPB,0	; pop opcode
001098  1               BranchCommaA:
001098  1  B5 A2        	STAX SW,ModBMRB,0	; save branch_opcode
00109A  1  DC           	LDBA ZW			; A=relative displacement of addr
00109B  1  31 21        	DCR BW,2
00109D  1  91 70 70     	LDAD VDP
0010A0  1  51 20        	SUB AW,BW
0010A2  1  D0 00 80     	LDBL $80		; in range of an 8-bit displacement?
0010A5  1  59           	SAB
0010A6  1  11 06        	BNL @Short
0010A8  1  D0 FF 80     	LDBL $ff80
0010AB  1  59           	SAB
0010AC  1  11 09        	BNL @Long
0010AE  1               
0010AE  1  BC           @Short:	STAA ZW			; drop addr, save displacement
0010AF  1  95 A1        	LDAX SW,ModBRPB,0	; compile branch_opcode
0010B1  1  79 10 77     	JSRD CCommaA
0010B4  1  71 10 75     	JMPD CComma		; compile branch displacement, & return
0010B7  1               
0010B7  1  95 A1        @Long:	LDAX SW,ModBRPB,0	; get branch_opcode
0010B9  1  D0 00 73     	LDBL $73		; unconditional branch opcode?
0010BC  1  49           	SABB
0010BD  1  14 90        	BZ JmpComma
0010BF  1  45 10        	XFRB AH,AL		; complement the branch opcode sense
0010C1  1  80 01        	LDABL 1
0010C3  1  44 10        	OREB AH,AL
0010C5  1  80 03        	LDABL 3			; set displacement to 3
0010C7  1  79 10 5D     	JSRD CommaA		; compile the branch
0010CA  1  71 10 4F     	JMPD JmpComma
0010CD  1               
0010CD  1               
0010CD  1               ; FHdr '(0Branch',0 ; ( f A=addr -- )  The run-time procedure to conditionally branch.
0010CD  1               ;PZBranch: ; ( f A=addr -- )  0Branch runtime
0010CD  1               ;	LDBX ZW,ModBRPB,0	; if f is false
0010CD  1               ;	BNZ @9
0010CD  1               ;	XFR XW,BW
0010CD  1               ;@9:	RSR
0010CD  1               
0010CD  1               PZBranchComma: ; ( adr -- ) compile (0Branch)
0010CD  1  90 D5 81     	LDAL $D581		; LDBX ZW,ModBRPB,0 to pop & test flag
0010D0  1  79 10 5D     	JSRD CommaA
0010D3  1  80 14        	LDABL $14		; compile BZ
0010D5  1  73 C1        	JMPR BranchCommaA
0010D7  1               
0010D7  1               
0010D7  1               	.if 0
0010D7  1                FHdr 'Ahead',0
0010D7  1                  ; Interpretation:
0010D7  1                  ;   Interpretation semantics for this word are undefined.
0010D7  1                  ; Compilation:
0010D7  1                  ;   ( C: -- orig )
0010D7  1                  ;   Put the location of a new unresolved forward reference orig onto the control flow stack.
0010D7  1                  ;   Append the run-time semantics given below to the current definition.
0010D7  1                  ;   The semantics are incomplete until orig is resolved (e.g., by THEN).
0010D7  1                  ;
0010D7  1                  ; Run-time:
0010D7  1                  ;   ( -- )
0010D7  1                  ;   Continue execution at the location specified by the resolution of orig.
0010D7  1               Ahead:
0010D7  1               	JSRD Abort ;???
0010D7  1               	.endif
0010D7  1               
0010D7  1               
0010D7  1  49 66 42 10   FHdr 'If',ha_immediate	; ( f -- ) (run-time)
0010DB  1  96           
0010DC  1               			; ( -- addr n ) (compile)
0010DC  1                  ; Occurs in a colon-definition in form:
0010DC  1                  ;	IF (tp) ... ENDIF
0010DC  1                  ;	IF (tp ... ELSE (fp) ... ENDIF
0010DC  1                  ; At run-time, IF selects execution based on a bool flag.  If f is true
0010DC  1                  ; (non-zero), execution continues ahead thru the true part.  If f is false
0010DC  1                  ; (zero), execution skips till just after ELSE to execute the false part.
0010DC  1                  ; After either part, execution resumes after ENDIF . ELSE and its false part
0010DC  1                  ; are optional. If missing, false execution skips to just after ENDIF .
0010DC  1                  ;
0010DC  1                  ; At compile-time IF compiles 0BRANCH and reserves space for an offset at
0010DC  1                  ; addr.  addr and n are used later for resolution of the offset and
0010DC  1                  ; error testing.
0010DC  1                  ; https://forth-standard.org/standard/core/IF
0010DC  1  79 0E EB     If:	JSRD QComp		; verify we're compiling - this is bad news for interpreting
0010DF  1  90 16 DC     	LDAL Abort		; push dest addr
0010E2  1  B5 82        	STAX ZW,ModBMRB,0
0010E4  1  7B E7        	JSRR PZBranchComma	; compile (0Branch)
0010E6  1  79 0B 96     	JSRD Here		; push addr for fixup later
0010E9  1  71 09 F8     If7:	JMPD Two		; push "IF" pairing code, & return
0010EC  1               
0010EC  1               
0010EC  1  45 6C 73 65   FHdr 'Else',ha_immediate ; ( addr1 n1 -- addr2 ) (compiling)
0010F0  1  44 10 DC     
0010F3  1                  ; Occurs within a colon-definition in the form:
0010F3  1                  ;	IF ... ELSE ... ENDIF
0010F3  1                  ; At run-time, ELSE executes after the true part following IF . ELSE forces
0010F3  1                  ; execution to skip over the following false part and resumes execution
0010F3  1                  ; after the ENDIF . It has no stack effects.
0010F3  1                  ;
0010F3  1                  ; At compile-time ELSE replaces BRANCH reserving a branch offset, leaves
0010F3  1                  ; the address addr2 and n2 for error testing.  ELSE also resolves the
0010F3  1                  ; pending forward branch from IF by calculation the offset from addr1
0010F3  1                  ; to HERE and storing at addr1.
0010F3  1                  ; https://forth-standard.org/standard/core/Dotq
0010F3  1  90 16 DC     Else:	LDAL Abort		; compile "jmp abort", addr to be fixed up later
0010F6  1  79 10 51     	JSRD JmpCommaA
0010F9  1  7B 0C        	JSRR Then		; fixup the IF
0010FB  1  79 0B 96     	JSRD Here		; save addr for fixup later
0010FE  1  73 E9        	JMPR If7		; finish
001100  1               
001100  1               
001100  1  54 68 65 6E   FHdr 'Then',ha_immediate ; ( addr n -- ) (compile)
001104  1  44 10 F3     
001107  1                  ; Occurs in a colon-definition in form:
001107  1                  ;	IF ... ENDIF
001107  1                  ;	IF ... ELSE ... THEN
001107  1                  ; At run-time, ENDIF serves only as the destination of a forward branch from
001107  1                  ; IF or ELSE . It marks the conclusion of the conditional structure.
001107  1                  ; THEN is another name for ENDIF.  Both names are supported in fig-FORTH.
001107  1                  ; See also IF and ELSE .
001107  1                  ;
001107  1                  ; At compile-time, ENDIF computes the forward branch offset from addr to
001107  1                  ; HERE and stores it at addr. n is used for error tests.
001107  1                  ; https://forth-standard.org/standard/core/THEN
001107  1  90 00 02     Then:	LDAL 2		; verify we're paired with an IF , & compiling
00110A  1  79 0F 16     	JSRD QPairsA
00110D  1  D5 81        	LDBX ZW,ModBRPB,0	; fixup IF branch addr
00110F  1  91 70 70     	LDAD VDP
001112  1  B5 28 FE     	STAX BW,ModNBRB,$fe
001115  1  09           	RSR		; return
001116  1               
001116  1               
001116  1               	.if 0
001116  1                FHdr 'EndIf',ha_immediate ;  FIG alias
001116  1               	JMPR Then
001116  1               	.endif
001116  1               
001116  1               
001116  1  42 65 67 69   FHdr 'Begin',ha_immediate ;  https://forth-standard.org/standard/core/BEGIN
00111A  1  6E 45 11 07  
00111E  1                  ; Compiling: ( -- addr n )
00111E  1                  ; Occurs in a colon-definition in the form:
00111E  1                  ;	BEGIN ... UNTIL
00111E  1                  ;	BEGIN ... AGAIN
00111E  1                  ;	BEGIN ... WHILE ... REPEAT
00111E  1                  ; At run-time, begin marks the start of a sequence that may be repetetively executed.
00111E  1                  ; It serves as a return point from the corresponding UNTIL , AGAIN or REPEAT .
00111E  1                  ; When executing UNTIL , a return to BEGIN will occur if the top of
00111E  1                  ; the stack is false; for AGAIN and REPEAT a return to BEGIN always occurs.
00111E  1                  ;
00111E  1                  ; At compile time BEGIN leaves its return address and n for compiler error checking.
00111E  1  79 0E EB     Begin:	JSRD QComp	; verify we're compiling
001121  1  79 0B 96     	JSRD Here	; push dictionary addr
001124  1  71 09 EE     	JMPD One	; push "Begin" pairing code, & return
001127  1               
001127  1               
001127  1  55 6E 74 69   FHdr 'Until',ha_immediate ;  (     f -- ) (run-time)
00112B  1  6C 45 11 1E  
00112F  1               			  ;  ( adr n -- ) (compile)
00112F  1                  ; Occurs withing a colon-definition in the form:
00112F  1                  ;	BEGIN .. UNTIL
00112F  1                  ; At run-time, UNTIL controls the conditional branch back to the corresponding
00112F  1                  ; BEGIN .  If f is false, execution returns to just after BEGIN ;
00112F  1                  ; if true, execution continues ahead.
00112F  1                  ;
00112F  1                  ; At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to addr.
00112F  1                  ; n is used for error tests.
00112F  1                  ; https://forth-standard.org/standard/core/UNTIL
00112F  1  90 00 01     Until:	LDAL 1		; varify we're paired with a BEGIN, & compiling
001132  1  79 0F 16     	JSRD QPairsA
001135  1  71 10 CD     	JMPD PZBranchComma ; compile a 0Branch
001138  1               
001138  1               
001138  1  45 6E 64 43   FHdr 'End',ha_immediate ; FIG alias
00113C  1  11 2F        
00113E  1  73 EF        	JMPR Until
001140  1               
001140  1               
001140  1  41 67 61 69   FHdr 'Again',ha_immediate ; ( addr n -- ) (compiling)
001144  1  6E 45 11 3E  
001148  1                  ; Used in a colon-definition in the form:
001148  1                  ;	BEGIN ... AGAIN
001148  1                  ; At run-time, AGAIN forces execution to return to the corresponding BEGIN.
001148  1                  ; Three is no effect on the stack.  Execution cannot leave this loop (unless
001148  1                  ; R> DROP is executed one level below).
001148  1  90 00 01     Again:	LDAL 1		; verify we're paired with a BEGIN, & compiling
00114B  1  79 0F 16     	JSRD QPairsA
00114E  1  80 73        	LDABL $73	; compile "jmpr adr", & return
001150  1  71 10 98     	JMPD BranchCommaA
001153  1               
001153  1               
001153  1  57 68 69 6C   FHdr 'While',ha_immediate ; (    f -- ) (run-time)
001157  1  65 45 11 48  
00115B  1               				  ; ( ad1 n1 -- ad1 n1 ad2 n2 )
00115B  1                  ; Occurs in a colon-definition in the form:
00115B  1                  ;	BEGIN ... WHILE (tp) ... REPEAT
00115B  1                  ; At run-time, WHILE selects conditional executing based on bool flag f.
00115B  1                  ; If f is true (non-zero), WHILE continues execution of the true part thru to
00115B  1                  ; REPEAT , which then branches back to BEGIN .  If f is false (zero), execution
00115B  1                  ; skips to just after REPEAT , exiting the structure.
00115B  1                  ;
00115B  1                  ; At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the reserved
00115B  1                  ; offset.  The stack values will be resolved by REPEAT .
00115B  1                  ; https://forth-standard.org/standard/core/WHILE
00115B  1  71 10 DC     While:	JMPD If
00115E  1               
00115E  1               
00115E  1  52 65 70 65   FHdr 'Repeat',ha_immediate ; ( addr n -- ) (compiling)
001162  1  61 74 46 11  
001166  1  5B           
001167  1                  ; Used withing a colon-definition in the form:
001167  1                  ;	BEGIN ... WHILE ... REPEAT
001167  1                  ; At run-time, REPEAT forces an unconditional branch back to just after
001167  1                  ; the corresponding BEGIN .
001167  1                  ;
001167  1                  ; At compile-time, REPEAT compiles BRANCH and the offset from HERE to addr.
001167  1                  ; n is used for pairing testing.
001167  1                  ; https://forth-standard.org/standard/core/REPEAT
001167  1  79 03 8F     Repeat:	JSRD ToR		; save While info
00116A  1  79 03 8F     	JSRD ToR
00116D  1  7B D9        	JSRR Again		; compile branch to Begin
00116F  1  79 03 85     	JSRD RFrom		; restore While info
001172  1  79 03 85     	JSRD RFrom
001175  1  73 90        	JMPR Then		; fixup While
001177  1               
001177  1               
001177  1               	.if 0
001177  1               
001177  1               ;----------------------------------------------------------------------
001177  1               ; Case
001177  1               ;   9 Of ." JACK" EndOf
001177  1               ;  10 Of ." QUEEN" EndOf
001177  1               ;  11 Of ." KING" EndOf
001177  1               ;  12 Of ." ACE" EndOf
001177  1               ;       Dup 2 + .
001177  1               ;  EndCase
001177  1               
001177  1               
001177  1               	.if 0
001177  1                FHdr 'Case',ha_Immediate ;  http://forth-standard.org/standard/core/CASE
001177  1                  ; Interpretation: Interpretation semantics for this word are undefined.
001177  1                  ; Compilation: ( C: -- case-sys )
001177  1                  ;	Mark the start of the CASE. . .OF. . .ENDOF. . .ENDCASE structure. Append the run-time
001177  1                  ;	semantics given below to the current definition.
001177  1                  ; Run-time: ( -- )
001177  1                  ;	continue execution.
001177  1               Case:	LDAL Case
001177  1               	STAX ZW,ModBMRB,0
001177  1               	JMPD Zero
001177  1               	.endif
001177  1               
001177  1               
001177  1               	.if 0
001177  1                FHdr '?Of',ha_Immediate ; accept flag
001177  1               QOf:	JSRD Abort ;???
001177  1               	lda #@x
001177  1               	jsr CompileInlineA
001177  1               	bra Of3
001177  1               
001177  1               @x:	PopAm
001177  1               	tay
001177  1               	bne @x4
001177  1               	jmp Abort
001177  1               @x4:	.word INL_End
001177  1               	.endif
001177  1               
001177  1               
001177  1                FHdr 'Of',ha_Immediate ;  http://forth-standard.org/standard/core/OF
001177  1                  ; Interpretation: Interpretation semantics for this word are undefined.
001177  1                  ; Compilation: ( C: -- of-sys )
001177  1                  ;	Put of-sys onto the control flow stack. Append the run-time semantics given below to the
001177  1                  ;	current definition. The semantics are incomplete until resolved by a consumer of of-sys
001177  1                  ;	such as ENDOF.
001177  1                  ; Run-time: ( x1 x2 -- | x1 )
001177  1                  ;	If the two values on the stack are not equal, discard the top value and continue execution
001177  1                  ;	at the location specified by the consumer of of-sys, e.g., following the next ENDOF.
001177  1                  ;	Otherwise, discard both values and continue execution in line.
001177  1               Of:	JSRD Abort ;???
001177  1               	lda #OfX
001177  1               	jsr CompileInlineA
001177  1               Of3:	lda #Of
001177  1               	jsr Mark2
001177  1               	lda #$e8e8	; inx inx
001177  1               	jmp CommaA
001177  1               
001177  1               OfX:	PopAm
001177  1               	cmp 0,x
001177  1               	bne *
001177  1               	.word INL_End
001177  1               
001177  1               
001177  1               	.if 0
001177  1               
001177  1                FHdr 'Of>',ha_Immediate
001177  1               OfG:	lda #0 ;???	; (ble)
001177  1               	JSRD Abort ;??? bra of2
001177  1               
001177  1               
001177  1                FHdr 'Of>=',ha_Immediate
001177  1               OfGe:	lda #0 ;???	; (blt)
001177  1               	JSRD Abort ;??? bra of2
001177  1               
001177  1               
001177  1                FHdr 'Of<',ha_Immediate
001177  1               OfL:	lda #0 ;???	; (bge)
001177  1               	JSRD Abort ;??? bra of2
001177  1               
001177  1               
001177  1                FHdr 'Of<=',ha_Immediate
001177  1               OfLe:	lda #0 ;???	; (bgt)
001177  1               	JSRD Abort ;??? bra of2
001177  1               
001177  1               	.endif
001177  1               
001177  1               
001177  1                FHdr 'EndOf',ha_Immediate ;  http://forth-standard.org/standard/core/ENDOF
001177  1                  ; Interpretation: Interpretation semantics for this word are undefined.
001177  1                  ; Compilation: ( C: case-sys1 of-sys -- case-sys2 )
001177  1                  ;	Mark the end of the OF. . .ENDOF part of the CASE structure. The next location for a
001177  1                  ;	transfer of control resolves the reference given by of-sys. Append the run-time semantics
001177  1                  ;	given below to the current definition. Replace case-sys1 with case-sys2 on the controlflow
001177  1                  ;	stack, to be resolved by ENDCASE.
001177  1                  ; Run-time: ( -- )
001177  1                  ;	continue execution at the location specified by the consumer of case-sys2.
001177  1               EndOf:	JSRD Abort ;???
001177  1               	lda 2,x
001177  1               	cmp #Of
001177  1               	bne @90
001177  1               	lda 6,x
001177  1               	cmp #Case
001177  1               	bne @90
001177  1               	lda 4,x
001177  1               	ldy MPtr
001177  1               	sty 4,x
001177  1               	jsr JmpCommaA
001177  1               
001177  1               	lda MPtr	;fix the OF
001177  1               	sec
001177  1               	sbc 0,x		;  calc branch displacement
001177  1               	cmp #$80	;  check range
001177  1               	bcs @range
001177  1               	dec 0,x
001177  1               	sep #pm
001177  1               	sta (0,x)
001177  1               	rep #pm
001177  1               	jmp DDrop
001177  1               
001177  1               ;	ldy 0,x		;fix the OF
001177  1               ;	dey		;  short version in-range?
001177  1               ;	dey
001177  1               ;	dey
001177  1               ;	sty @adr
001177  1               ;	lda mp
001177  1               ;	sec
001177  1               ;	sbc @adr
001177  1               ;	cmp #$80
001177  1               ;	bcs @75
001177  1               ;	dey		;  modify to short version
001177  1               ;	dey
001177  1               ;	sep #pm
001177  1               ;	sta a:1,y	;    store displacement
001177  1               ;	lda a:0,y	;    flip sense of branch
001177  1               ;	eor #$20
001177  1               ;	sta a:0,y
001177  1               ;	lda #$89	;    pad with bit #
001177  1               ;	sta a:2,y
001177  1               ;	rep #pm
001177  1               ;	lda #0
001177  1               ;	sta a:3,y
001177  1               ;	bra @79
001177  1               ;
001177  1               ;@75:	lda mp		; fix long version
001177  1               ;	sta a:1,y
001177  1               ;@79:	jmp DDrop
001177  1               
001177  1               @range:	jsr DotQuoteR
001177  1               	.byte 12," Too large! "
001177  1               @90:	jsr Abort
001177  1               
001177  1               
001177  1                FHdr 'EndCase',ha_Immediate ;  http://forth-standard.org/standard/core/ENDCASE
001177  1                  ; Interpretation: Interpretation semantics for this word are undefined.
001177  1                  ; Compilation: ( C: case-sys -- )
001177  1                  ;	Mark the end of the CASE. . .OF. . .ENDOF. . .ENDCASE structure. Use case-sys to resolve
001177  1                  ;	the entire structure. Append the run-time semantics given below to the current definition.
001177  1                  ; Run-time: ( x -- )
001177  1                  ;	Discard the case selector x and continue execution.
001177  1               EndCase:
001177  1               	lda #$e8e8	; inx; inx  drop selector
001177  1               	jsr CommaA
001177  1               	lda 2,x
001177  1               	cmp #Case
001177  1               	bne @90
001177  1               	ldy 0,x		;fix endof jmp list
001177  1               	beq @19
001177  1               @11:	lda a:1,y
001177  1               	pha
001177  1               	lda MPtr
001177  1               	sta a:1,y
001177  1               	ply
001177  1               	bne @11
001177  1               @19:	jmp DDrop
001177  1               
001177  1               @90:	jsr Abort
001177  1               
001177  1               	.endif
001177  1               
001177  1               
001177  1  44 6F 42 11   FHdr 'Do',ha_immediate	; ( n1 n2 -- ) (execute)
00117B  1  67           
00117C  1               			; ( addr n -- ) (compile)
00117C  1                  ; Occurs in a colon-definition in form:
00117C  1                  ;	DO ... LOOP
00117C  1                  ;	DO ... +LOOP
00117C  1                  ; At run time, DO begins a sequence with repetitive execution controlled by a
00117C  1                  ; loop limit n1 and an index with initial valie n2.  DO removes these from the
00117C  1                  ; stack.  Upon reaching LOOP the index is incremented by one.  Until the new
00117C  1                  ; index equals or exceeds the limit, execution loops back to just after DO ;
00117C  1                  ; otherwise the loop parameters are discarded and execution continues ahead.
00117C  1                  ; Both n1 and n2 are determined at run-time and may be the results of other
00117C  1                  ; operations.  Within a loop 'I' will copy the current value of the index to
00117C  1                  ; the stack.  See I Loop +LOOP LEAVE .
00117C  1                  ; When compiling within the colon-definitions, DO compiles (DO) , leaves the
00117C  1                  ; following addresss addr and n for later error checking.
00117C  1                  ; https://forth-standard.org/standard/core/DO
00117C  1  90 11 88     Do:	LDAL PDo		; compile "jsr PDo"
00117F  1  79 10 3E     	JSRD JsrCommaA
001182  1  79 0B 96     	JSRD Here		; push addr
001185  1  71 0A 02     	JMPD Three		; push DO pairing code, & return
001188  1               
001188  1               PDo: ; runtime
001188  1  71 03 9A     	JMPD TwoToR
00118B  1               ;	LDAX ZW,ModBRPB,0	; pop index
00118B  1               ;	LDBX ZW,ModBRPB,0	; pop limit
00118B  1               ;	STBX SW,ModBMRB,0	; push limit
00118B  1               ;	STAX SW,ModBMRB,0	; push index
00118B  1               ;	RSR			; return
00118B  1               
00118B  1               
00118B  1               	.if 0
00118B  1                FHdr '?DO',ha_immediate
00118B  1                  ; Interpretation:
00118B  1                  ;   Interpretation semantics for this word are undefined.
00118B  1                  ; Compilation:
00118B  1                  ;   ( C: -- do-sys )
00118B  1                  ;   Put do-sys onto the control-flow stack. Append the run-time semantics given below to the current definition.
00118B  1                  ;   The semantics are incomplete until resolved by a consumer of do-sys such as LOOP.
00118B  1                  ;
00118B  1                  ; Run-time:
00118B  1                  ;   ( n1 | u1 n2 | u2 -- ) ( R: -- loop-sys )
00118B  1                  ;   If n1 | u1 is equal to n2 | u2, continue execution at the location given by the consumer of do-sys.
00118B  1                  ;   Otherwise set up loop control parameters with index n2 | u2 and limit n1 | u1 and continue executing immediately following ?DO. Anything already on the return stack becomes unavailable until the loop control parameters are discarded. An ambiguous condition exists if n1 | u1 and n2 | u2 are not both of the same type.
00118B  1                  ; https://forth-standard.org/standard/core/qDO
00118B  1               	.endif
00118B  1               
00118B  1               
00118B  1  4C 65 61 76   FHdr 'Leave',0 ; ( -- )
00118F  1  65 05 11 7C  
001193  1                  ; Force termination of a DO-LOOP at the next opportunity by setting the loop limit
001193  1                  ; equal to the current value of the index.  The index itself remains unchanged, and
001193  1                  ; execution proceeds normally until LOOP or +LOOP is encountered.
001193  1                  ; https://forth-standard.org/standard/core/LEAVE
001193  1  95 A8 02     Leave:	LDAX SW,ModNBRB,2	; limit=index
001196  1  BD           	STAA SW
001197  1  09           	RSR			; return
001198  1               
001198  1               
001198  1               	.if 0
001198  1                FHdr 'Unloop',ha_immedate
001198  1                  ; Interpretation:
001198  1                  ;   Interpretation semantics for this word are undefined.
001198  1                  ; Execution:
001198  1                  ;   ( -- ) ( R: loop-sys -- )
001198  1                  ;   Discard the loop-control parameters for the current nesting level.
001198  1                  ;   An UNLOOP is required for each nesting level before the definition may be EXITed.
001198  1                  ;   An ambiguous condition exists if the loop-control parameters are unavailable.
001198  1               Unloop:	INR SW,4	; rdrop index & limit
001198  1               	RSR
001198  1               	.endif
001198  1               
001198  1               
001198  1  49 01 11 93   FHdr 'I',0 ; ( -- n )
00119C  1                  ; Used within a DO-LOOP to copy the loop index to the stack.
00119C  1                  ; Other use is implementation dependent.
00119C  1                  ; See R .
00119C  1                  ; https://forth-standard.org/standard/core/I
00119C  1  9D           I:	LDAA SW			; get 1st DO index
00119D  1  B5 82        	STAX ZW,ModBMRB,0	; push it
00119F  1  09           	RSR			; return
0011A0  1               
0011A0  1               
0011A0  1  4A 01 11 9C   FHdr 'J',0 ; ( -- n )
0011A4  1                  ; Used within a DO-LOOP to copy the loop limit to the stack.
0011A4  1                  ; Other use is implementation dependent.
0011A4  1                  ; See I .
0011A4  1                  ; https://forth-standard.org/standard/core/J
0011A4  1  95 A8 04     J:	LDAX SW,ModNBRB,4	; get 2nd DO index
0011A7  1  B5 82        	STAX ZW,ModBMRB,0	; push it
0011A9  1  09           	RSR			; return
0011AA  1               
0011AA  1               
0011AA  1  4C 6F 6F 70   FHdr 'Loop',ha_immediate; ( addr n -- ) (compiling)
0011AE  1  44 11 A4     
0011B1  1                  ; Occurs in a colon-definition in form:
0011B1  1                  ;	DO ... LOOP
0011B1  1                  ; At run-time, LOOP selectively controls branching back to the corresponding
0011B1  1                  ; DO based on the loop index and limit.  The loop index is incremented by one
0011B1  1                  ; and compared to the limit.  The branch back to DO occurs until the index >= limit;
0011B1  1                  ; at than time, the parameters are discarded and execution continues ahead.
0011B1  1                  ;
0011B1  1                  ; At compile-time, uses addr to calculate an offset to DO .  n is used for error testing.
0011B1  1                  ; https://forth-standard.org/standard/core/LOOP
0011B1  1  90 00 03     Loop:	LDAL 3			; verify we're paired with a DO, & compiling
0011B4  1  79 0F 16     	JSRD QPairsA
0011B7  1               
0011B7  1  90 11 C2     	LDAL PLoop		; compile "jsr PLoop"
0011BA  1  79 10 3E     Loop7:	JSRD JsrCommaA
0011BD  1  80 16        	LDABL $16		; compile "BM addr", & return
0011BF  1  71 10 98     	JMPD BranchCommaA
0011C2  1               
0011C2  1               ;	FHdr '(Loop)',0 ; ( -- )  LOOP runtime
0011C2  1               PLoop:
0011C2  1  9D           	LDAA SW			; increment index
0011C3  1  38           	INA
0011C4  1  BD           	STAA SW
0011C5  1  D5 A8 02     	LDBX SW,ModNBRB,2	; signed compare to limit
0011C8  1  59           	SAB
0011C9  1  13 01        	BNF @Run2		; if overflow
0011CB  1  3B           	IVA			;   correct sign
0011CC  1               @Run2:
0011CC  1  16 03        	BM @Run9		; if limit reached
0011CE  1  30 A3        	INR SW,4		;   rdrop index & limit
0011D0  1  3A           	CLA			;   clear neg flag to indicate fall thru
0011D1  1  09           @Run9:	RSR			; returns negative flag: clear=fall thru, set=loop back
0011D2  1               
0011D2  1               
0011D2  1  2B 4C 6F 6F   FHdr '+Loop',ha_immediate ; (      n1 -- ) (run)
0011D6  1  70 45 11 B1  
0011DA  1               			   ; ( addr n2 -- ) (compile)
0011DA  1                  ; Used in a colon-definition in the form:
0011DA  1                  ;	DO  ...  n1 +LOOP
0011DA  1                  ; At run-time, +LOOP selectively controls branching back to the corresponding
0011DA  1                  ; DO based on n1, the loop index and the loop limit.  The signed increment
0011DA  1                  ; n1 is added to the index and the total compared to the limit.  The branch
0011DA  1                  ; back to DO occurs until the new index is >= the limit (n1>0), or until the
0011DA  1                  ; new index is <= the limit (n1<0).  Upon exiting the loop, the parameters
0011DA  1                  ; are discarded and execution continues ahead.
0011DA  1                  ;
0011DA  1                  ; At compile time, +LOOP compiles the run-time word (+LOOP) and the branch
0011DA  1                  ; offset from HERE to the address left on the stack by DO.  n2 is used for
0011DA  1                  ; compile time error checking.
0011DA  1                  ; https://forth-standard.org/standard/core/PlusLOOP
0011DA  1               PlusLoop:
0011DA  1  90 00 03     	LDAL 3		; verify we're paired with a DO , & compiling
0011DD  1  79 0F 16     	JSRD QPairsA
0011E0  1  90 11 E5     	LDAL PPlusLoop	; compile "jsr PPlusLoop"
0011E3  1  73 D5        	JMPR Loop7	; & finish
0011E5  1               
0011E5  1               
0011E5  1               ; FHdr '(+Loop)',0 ; ( n -- )  The run-time procecdure compiled by +LOOP,
0011E5  1               		; which increments the loop index by n and tests for loop completion.
0011E5  1               PPlusLoop:
0011E5  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
0011E7  1  5C           	XAY
0011E8  1  DD           	LDBA SW			; add n to index
0011E9  1  58           	AAB
0011EA  1  FD           	STBA SW
0011EB  1  12 0C        	BF @Quit		; if overflow, we're done for sure
0011ED  1  95 A8 02     	LDAX SW,ModNBRB,2	; compare index with limit
0011F0  1  51 20        	SUB AW,BW
0011F2  1  13 01        	BNF @3			; overflow?
0011F4  1  3B           	IVA			;   correct overflowed sign
0011F5  1  54 60        @3:	ORE AW,YW		; take into account the sign of n
0011F7  1  16 03        	BM @9			; if limit reached
0011F9  1  30 A3        @Quit:	INR SW,4		;   rdrop index & limit
0011FB  1  3A           	CLA			;   clear negative flag
0011FC  1  09           @9:	RSR			; returns negative flag: clear=fall thru, set=loop back
0011FD  1               
0011FD  1               
0011FD  1  43 72 65 61   FHdr 'Create',0 ;
001201  1  74 65 06 11  
001205  1  DA           
001206  1                  ; A defining word used in the form:
001206  1                  ;	CREATE cccc
001206  1                  ; by such words as CODE and CONSTANT to create a dictionary header for a Forth
001206  1                  ; definition.  The code field contains the address of the words parameter field.
001206  1                  ; The new word is created in the CURRENT vocabulary.
001206  1                  ; https://forth-standard.org/standard/core/CREATE
001206  1  79 12 14     Create:	JSRD HeaderComma	; compile word header
001209  1  90 12 0F     	LDAL @Run		; compile "jsr @Run", & return
00120C  1  71 10 3E     	JMPD JsrCommaA
00120F  1               
00120F  1  6D 82        @Run:	STXX ZW,ModBMRB,0	; push pfa
001211  1  65 A1        	LDXX SW,ModBRPB,0	; return to my caller's caller
001213  1  09           	RSR
001214  1               
001214  1               
001214  1               ; FHdr 'Header,',0 ( "name" -- )  compile a word header
001214  1                  ; name is next word in input buffer.
001214  1               HeaderComma:
001214  1  79 14 6C     	JSRD DFind		; check for name redefinition
001217  1               				; DFind also stores the name at HERE, including a preceding length
001217  1               				; byte that we don't use, but haven't discarded here yet.
001217  1  95 81        	LDAX ZW,ModBRPB,0	; found an existing word of the same name?
001219  1  14 0E        	BZ @2163
00121B  1  30 81        	INR ZW,2		;   drop flags
00121D  1               ;	JSRD CFA		;   CFA & NFA are the same in this implementation
00121D  1  79 14 FB     	JSRD IdDot		;   type name
001220  1  90 00 04     	LDAL Err_IsntUnique	;   type message
001223  1  79 1A 13     	JSRD MessageA
001226  1  79 0C 8B     	JSRD Space		;   type space
001229  1               @2163:
001229  1  3A           	CLA			; get name length
00122A  1  82 70 70     	LDABI VDP
00122D  1  C0 20        	LDBBL ha_length+1	; name too long?
00122F  1  49           	SABB
001230  1  10 18        	BL @NameTooLong
001232  1  B5 A2        	STAX SW,ModBMRB,0	; save name length on return stack
001234  1               
001234  1  38           	INA			;   ???include the unused leading string char count byte
001235  1  79 0F 5D     	JSRD AllotA		; skip over stored name
001238  1               
001238  1  95 A1        	LDAX SW,ModBRPB,0	; get original length
00123A  1  79 10 77     	JSRD CCommaA		; store flags & length
00123D  1               
00123D  1  92 70 80     	LDAI VCurrent		; store dictionary link
001240  1  79 10 5D     	JSRD CommaA
001243  1  91 70 70     	LDAD VDP		; link into current vocabulary
001246  1  B2 70 80     	STAI VCurrent
001249  1               
001249  1  09           	RSR			; return
00124A  1               
00124A  1               @NameTooLong:
00124A  1  79 16 DC     	JSRD Abort
00124D  1               
00124D  1               
00124D  1  49 6E 6C 69   FHdr 'Inline',0 ; ( -- )
001251  1  6E 65 06 12  
001255  1  06           
001256  1                  ; Mark the most recently made definition so that when encountered at compile time,
001256  1                  ; it will be copied inline instead of JSRd to.
001256  1               Inline:
001256  1  79 13 00     	JSRD Exit		; compile 2nd RSR as an end-of-word marker
001259  1  80 80        	LDABL ha_inline
00125B  1  73 1B        	JMPR XorFlags
00125D  1               
00125D  1               
00125D  1  49 6D 6D 65   FHdr 'Immediate',0 ; ( -- )
001261  1  64 69 61 74  
001265  1  65 09 12 56  
001269  1                  ; Mark the most recently made definition so that when encountered at compile time,
001269  1                  ; it will be executed rather than being compiled.  i.e. the precedence bit in its
001269  1                  ; header is set.  This method allows definitions to handle unusual compiling
001269  1                  ; situations, rather than build them into the fundamental compiler.  The user may
001269  1                  ; force compilation of an immediate definition by preceding it with [COMPILE] .
001269  1                  ; https://forth-standard.org/standard/core/IMMEDIATE
001269  1               Immediate:
001269  1  80 40        	LDABL ha_immediate
00126B  1  73 0B        	JMPR XorFlags
00126D  1               
00126D  1               
00126D  1  53 6D 75 64   FHdr 'Smudge',0 ; ( -- )
001271  1  67 65 06 12  
001275  1  69           
001276  1                  ; Used during word definition to toggle the "smudge bit" in a definitions' name
001276  1                  ; field.  This prevents an uncompleted definition from being found during
001276  1                  ; dictionary searches, until compiling is completed without error.
001276  1  80 20        Smudge:	LDABL ha_smudge
001278  1               XorFlags:
001278  1  5C           	XAY			; Y=bits
001279  1  D2 70 80     	LDBI VCurrent		; B=word ptr
00127C  1  85 28 FD     	LDABX BW,ModNBRB,$fd	; xor flags
00127F  1  44 71        	OREB AL,YL
001281  1  A5 28 FD     	STABX BW,ModNBRB,$fd
001284  1  09           	RSR
001285  1               
001285  1               
001285  1               	.if 0
001285  1                FHdr 'Postpone',0 ; ( "xxx" — ) ???
001285  1                  ; Used in the definition of a compiling word. When the compiling word, in turn, is used in a
001285  1                  ; source definition, the execution token of xxx will be compiled into the dictionary entry so
001285  1                  ; that when the new definition is executed, xxx will be executed.
001285  1                  ;Used in a colon definition, causes the immediate word xxx to be compiled as though it were
001285  1                  ; not immediate; xxx will be executed when the definition is executed.
001285  1               	JSRD Abort ;???
001285  1               	.endif
001285  1               
001285  1               
001285  1  56 61 72 69   FHdr 'Variable',0 ; ( "name" n -- )
001289  1  61 62 6C 65  
00128D  1  08 12 76     
001290  1                  ; A defining word used in the form:
001290  1                  ;	n VARIABLE cccc
001290  1                  ; When VARIABLE is executed, it creates the definition cccc with its parameter field
001290  1                  ; initialized to n.  When cccc is later executed, the address of it's parameter field
001290  1                  ; (containing n) is left on the stack, so that a fetch or store may access this location.
001290  1                  ; https://forth-standard.org/standard/core/VARIABLE
001290  1               Variable:
001290  1  79 12 06     	JSRD Create	; create a word that pushes it's parameter address
001293  1  3A           Varia2:	CLA
001294  1  71 10 5D     	JMPD CommaA	; alloc data space & store initial value
001297  1               
001297  1               
001297  1  32 56 61 72   FHdr '2Variable',0 ; ( "name" n -- )
00129B  1  69 61 62 6C  
00129F  1  65 09 12 90  
0012A3  1                  ; A defining word used in the form:
0012A3  1                  ;	d 2VARIABLE cccc
0012A3  1                  ; When 2VARIABLE is executed, it creates the definition cccc with its parameter field
0012A3  1                  ; initialized to d.  When cccc is later executed, the address of it's parameter field
0012A3  1                  ; (containing d) is left on the stack, so that a fetch or store may access this location.
0012A3  1                  ; https://forth-standard.org/standard/double/TwoVARIABLE
0012A3  1               TwoVariable:
0012A3  1  7B EB        	JSRR Variable		; header & 1st 2 bytes
0012A5  1  73 EC        	JMPR Varia2		; 2nd 2 bytes
0012A7  1               
0012A7  1               
0012A7  1  43 6F 6E 73   FHdr 'Constant',0 ; ( n "name" -- )
0012AB  1  74 61 6E 74  
0012AF  1  08 12 A3     
0012B2  1                  ; A definining word used in the form:
0012B2  1                  ;	n CONSTANT cccc
0012B2  1                  ; to create word cccc.
0012B2  1                  ; When cccc is lated executed, it will push the value of n to the stack.
0012B2  1                  ; https://forth-standard.org/standard/core/CONSTANT
0012B2  1               Constant:
0012B2  1  79 12 14     	JSRD HeaderComma	; compile a word header
0012B5  1  79 15 2B     	JSRD LitComma		; compile "lda #n", "sta (-z)"
0012B8  1  71 13 00     	JMPD Exit		; compile "rsr", & return
0012BB  1               
0012BB  1               
0012BB  1  32 43 6F 6E   FHdr '2Constant',0 ; ( d "name" -- )
0012BF  1  73 74 61 6E  
0012C3  1  74 09 12 B2  
0012C7  1                  ; A definining word used in the form:
0012C7  1                  ;	d 2CONSTANT cccc
0012C7  1                  ; to create word cccc.
0012C7  1                  ; When cccc is lated executed, it will push the value of d to the stack.
0012C7  1                  ; https://forth-standard.org/standard/double/TwoCONSTANT
0012C7  1               TwoConstant:
0012C7  1  79 12 14     	JSRD HeaderComma	; compile a word header
0012CA  1  79 10 7E     	JSRD LdbaComma		; compile "lda #d.lo; ldb #d.hi
0012CD  1  90 02 EE     	LDAL PushBA 		; compile "JMPD PushBA"
0012D0  1  71 10 51     	JMPD JmpCommaA
0012D3  1               
0012D3  1               
0012D3  1               	.if 0
0012D3  1               
0012D3  1                FHdr 'Value',0
0012D3  1                  ; https://forth-standard.org/standard/core/VALUE
0012D3  1               Value:	JMPR Constant
0012D3  1               
0012D3  1               
0012D3  1                FHdr '2Value',0
0012D3  1                  ; https://forth-standard.org/standard/double/TwoVALUE
0012D3  1               TwoValue:
0012D3  1               	JMPR TwoConstant
0012D3  1               
0012D3  1               
0012D3  1                FHdr 'To',0
0012D3  1                  ; Interpretation:
0012D3  1                  ;   ( i * x "<spaces>name" -- )
0012D3  1                  ;   Skip leading spaces and parse name delimited by a space. Perform the "TO name run-time" semantics given in the definition for the defining word of name. An ambiguous condition exists if name was not defined by a word with "TO name run-time" semantics.
0012D3  1                  ;
0012D3  1                  ; Compilation:
0012D3  1                  ; ( "<spaces>name" -- )
0012D3  1                  ;   Skip leading spaces and parse name delimited by a space. Append the "TO name run-time" semantics given
0012D3  1                  ;   in the definition for the defining word of name to the current definition.
0012D3  1                  ;   An ambiguous condition exists if name was not defined by a word with "TO name run-time" semantics.
0012D3  1                  ; https://forth-standard.org/standard/core/TO
0012D3  1               To:	JSRD Abort ;???
0012D3  1               
0012D3  1               	.endif
0012D3  1               
0012D3  1               
0012D3  1  3A 41 12 C7   FHdr ':',ha_immediate ; ( "name" -- )  Start compiling a word
0012D7  1                  ; Used in the form:
0012D7  1                  ;	: ccc  ...  ;
0012D7  1                  ; Creates a dictionary entry defining ccc as equivalent to the following
0012D7  1                  ; sequence of Forth word definitions '...' until the next ';' or ';CODE'.
0012D7  1                  ; The compiling process is done by the text interpreter as long as STATE is
0012D7  1                  ; non-zero.  Other details are that the CONTEXT vocabulary is set to the CURRENT
0012D7  1                  ; vocabulary and that WORDS with the precedence bit set (P) are executed
0012D7  1                  ; rather that being compiled.
0012D7  1                  ; https://forth-standard.org/standard/core/Colon
0012D7  1  79 12 14     Colon:	JSRD HeaderComma	; compile word header
0012DA  1  79 12 76     	JSRD Smudge		; smudge the word so we won't find it until done
0012DD  1  79 0F 02     Colon3:	JSRD QExec		; verify we're not already compiling
0012E0  1  79 0F 27     	JSRD SCSP		; save param stack index to compare later
0012E3  1  91 70 80     	LDAD VCurrent		; Context vocabulary = current vocabulary
0012E6  1  B1 70 7E     	STAD VContext
0012E9  1  73 27        	JMPR RBracket		; set compile mode, & return
0012EB  1               
0012EB  1               
0012EB  1  3B 41 12 D7   FHdr ';',ha_immediate ; ( -- )  Terminates a colon-definition and stop further compilation.
0012EF  1                  ; https://forth-standard.org/standard/core/Semi
0012EF  1  79 0F 34     Semi:	JSRD QCSP		; check that param stack index = when we started compiling
0012F2  1  7B 0C        	JSRR Exit		; compile "rsr"
0012F4  1  79 12 76     	JSRD Smudge		; Un-smudge the word header
0012F7  1  73 10        	JMPR LBracket		; set interpret mode, & return
0012F9  1               
0012F9  1               
0012F9  1               	.if 0
0012F9  1                FHdr ':Noname',0 ; ( C: -- colon-sys ) ( S: -- xt )
0012F9  1                  ; Create an execution token xt, enter compilation state and start the current definition, producing colon-sys.
0012F9  1                  ; Append the initiation semantics given below to the current definition.
0012F9  1                  ;
0012F9  1                  ; The execution semantics of xt will be determined by the words compiled into the body of the definition.
0012F9  1                  ; This definition can be executed later by using xt EXECUTE.
0012F9  1                  ;
0012F9  1                  ; If the control-flow stack is implemented using the data stack, colon-sys shall be the topmost item on the data stack.
0012F9  1                  ; See 3.2.3.2 Control-flow stack.
0012F9  1               CNoname:
0012F9  1               	LDABL ha_smudge
0012F9  1               	JSRD CCommaA		; compile flags & length
0012F9  1               	CLA
0012F9  1               	JSRD CommaA		; compile fake dictionary link
0012F9  1               	JSRD Here		; push xt
0012F9  1               	JMPR Colon3
0012F9  1               	.endif
0012F9  1               
0012F9  1               
0012F9  1  45 78 69 74   FHdr 'Exit',ha_immediate ; ( -- ) https://forth-standard.org/standard/core/EXIT
0012FD  1  44 12 EF     
001300  1                  ; Interpretation: Interpretation semantics for this word are undefined.
001300  1                  ; Execution: ( -- ) ( R: nest-sys -- )
001300  1                  ;	Return control to the calling definition specified by nest-sys. Before executing EXIT
001300  1                  ;	within a do-loop, a program shall discard the loop-control parameters by executing UNLOOP.
001300  1  80 09        Exit:	LDABL $09		; compile a RSR ( replaces ;S call )
001302  1  71 10 77     	JMPD CCommaA
001305  1               
001305  1               
001305  1  5B 41 13 00   FHdr '[',ha_immediate ; ( -- )  Suspend compilation.
001309  1                  ; Used in a colon-definition in form:
001309  1                  ;	: xxx  [ words ]  more ;
001309  1                  ; The words after [ are executed, not compiled.  This allows
001309  1                  ; calculation or compilation exceptions before resuming compilation with ] .
001309  1                  ; See LITERAL ]
001309  1                  ; https://forth-standard.org/standard/core/Bracket
001309  1               LBracket:
001309  1  3A           	CLA
00130A  1  B1 70 82     LBrac3:	STAD VState	; set state to interpreting
00130D  1  09           	RSR		; return
00130E  1               
00130E  1               
00130E  1  5D 01 13 09   FHdr ']',0 ; ( -- )  Resume compilation, to the completion of a colon-definition.
001312  1                  ; See [
001312  1               RBracket:
001312  1  32 01        	CLR AW,1	; set state to compiling (store non-zero)
001314  1  73 F4        	JMPR LBrac3
001316  1               
001316  1               
001316  1               	.if 0
001316  1                FHdr 'Synonym',0 ; ( "<spaces>newname" "<spaces>oldname" -- )
001316  1                  ; For both strings skip leading space delimiters. Parse newname and oldname delimited by a space.
001316  1                  ; Create a definition for newname with the semantics defined below.
001316  1                  ; Newname may be the same as oldname; when looking up oldname, newname shall not be found.
001316  1                  ;
001316  1                  ; An ambiguous conditions exists if oldname can not be found or IMMEDIATE is applied to newname.
001316  1                  ; https://forth-standard.org/standard/tools/SYNONYM
001316  1               Synonym:
001316  1               	JSRD Colon	; start a new word
001316  1               	JSRD Tick	; look up old word
001316  1               	LDABL $71	; build JMPD
001316  1               	JSRD CCommaA
001316  1               	JSRD Comma
001316  1               	JMPD Semi	; end new word
001316  1               	.endif
001316  1               
001316  1               
001316  1  3B 43 6F 64   FHdr ';Code',ha_immediate
00131A  1  65 45 13 12  
00131E  1                  ; Used in the form:
00131E  1                  ;	: ccc  ....  ;CODE
00131E  1                  ;		assembly mnemonics
00131E  1                  ; Stop compilation and terminate a new defining word cccc by compiling (;CODE) .
00131E  1                  ; Set the CONTEXT vocabulary to ASSEMBLER, assembling to machine code the following
00131E  1                  ; menmonics.
00131E  1                  ;
00131E  1                  ; When cccc later executes in the form:
00131E  1                  ;	cccc nnnn
00131E  1                  ; the word nnnn will be created with its execution procedure given by the machine
00131E  1                  ; code following cccc.  That is, when nnnn is executed, it does so by jumping to the
00131E  1                  ; code after nnnn.  An existing defining word must exist in cccc prior to ;CODE .
00131E  1                  ; https://forth-standard.org/standard/tools/SemiCODE
00131E  1  79 0F 34     SCode:	JSRD QCSP	; make sure param stack is the same depth as when compile started
001321  1  90 13 2C     	LDAL PSCode	; compile "jsr PSCode"
001324  1  79 10 3E     	JSRD JsrCommaA
001327  1               
001327  1  7B E0        	JSRR LBracket	; state=interpret
001329  1  71 12 76     	JMPD Smudge	; un-smudge the word header
00132C  1               
00132C  1               
00132C  1               ; FHdr '(;Code)',0 ;
00132C  1                  ; The run-time procedure compiled by ;CODE, that rewrites the code field of the
00132C  1                  ; most recently defined word to point to the following machine code sequence.
00132C  1                  ; See ;CODE.
00132C  1  D2 70 80     PSCode: LDBI VCurrent		; B=ptr to current word
00132F  1  6D 28 01     	STXX BW,ModNBRB,1	; store in jsr operand of current word
001332  1  65 A1        	LDXX SW,ModBRPB,0	; pop my caller's addr
001334  1  09           	RSR
001335  1               
001335  1               
001335  1               	.if 0
001335  1                FHdr '<Builds',0 ;
001335  1                  ; Used within a colon-definition:
001335  1                  ;	: cccc <BUILDS ...
001335  1                  ;		DOES> ... ;
001335  1                  ; Each time cccc is executed, <BUILDS defines a new word with a high-level
001335  1                  ; execution procedure.  Executing cccc in the form:
001335  1                  ;	cccc nnnn
001335  1                  ; uses <BUILDS to create a dictionary entry for nnnn with a call to the DOES>
001335  1                  ; part for nnnn.  When nnnn is later executed, it has the address of its
001335  1                  ; parameter area on the stack and executes the words after DOES> in cccc.
001335  1                  ; <BUILDS and DOES> allow run-time procedures to be written in high-level
001335  1                  ; rather than in assembler code (as required by ;CODE ).
001335  1               Builds:	JMPD Create		; start a word with jsr, "jsr" address will be patched later
001335  1               	.endif
001335  1               
001335  1               
001335  1  44 6F 65 73   FHdr 'Does>',ha_immediate ;
001339  1  3E 45 13 1E  
00133D  1                  ; A word which defines the run-time action withing a high-level defining word.
00133D  1                  ; DOES> alters the code field and first parameter of the new word to execute
00133D  1                  ; the sequence of compiled word addresses following DOES> .
00133D  1                  ; Used in combination with <BUILDS . When the DOES> part executes it begins with the
00133D  1                  ; address of the first parameter of the new word on the stack.
00133D  1                  ; This allows interpretation using this area or its contents.
00133D  1                  ; Typical uses include the Forth assembler, multidimensional arrays, and compiler generation.
00133D  1                  ; https://forth-standard.org/standard/core/DOES
00133D  1  90 13 2C     DoesG:	LDAL PSCode
001340  1  79 10 3E     	JSRD JsrCommaA
001343  1               
001343  1  90 6D 82     	LDAL $6D82	; compile "STXX ZW,ModBMRB,0" to push PFA
001346  1  79 10 5D     	JSRD CommaA
001349  1  90 65 A1     	LDAL $65A1	; compile "LDXX SW,ModBRPB,0" to fix return stack
00134C  1  71 10 5D     	JMPD CommaA
00134F  1               
00134F  1               
00134F  1  2E 28 42 13   FHdr '.(',ha_immediate ;  https://forth-standard.org/standard/core/Dotp
001353  1  3D           
001354  1                  ; Compilation:
001354  1                  ;   Perform the execution semantics given below.
001354  1                  ; Execution:
001354  1                  ;   ( "ccc<paren>" -- )
001354  1                  ; Parse and display ccc delimited by ) (right parenthesis). .( is an immediate word.
001354  1  D0 00 29     DotP:	LDBL ')'		; push ')'
001357  1  F5 82        DotP3:	STBX ZW,ModBMRB,0
001359  1  79 08 B8     	JSRD Word		; get counted string
00135C  1  79 0B 96     	JSRD Here		; push counted string addr
00135F  1  79 07 ED     	JSRD Count		; convert to addr & len
001362  1  71 0C AB     	JMPD Type		; type it & return
001365  1               
001365  1               
001365  1  2E 22 42 13   FHdr '."',ha_immediate ;
001369  1  54           
00136A  1                  ; Used in the form
00136A  1                  ;	." cccc"
00136A  1                  ; Compiles an in-line string cccc (delimited by the trailing ") with an
00136A  1                  ; execution procedure to transmit the text to the selected output device.
00136A  1                  ; If execute outside a definition, ." will immediately print the text until
00136A  1                  ; the final ".  The maximum number of chars may be an installation depended
00136A  1                  ; value.  See (.") .
00136A  1                  ; https://forth-standard.org/standard/core/Dotq
00136A  1  D0 00 22     DotQ:	LDBL '"'
00136D  1  91 70 82     	LDAD VState		; interpreting?
001370  1  14 E5        	BZ DotP3
001372  1               
001372  1  90 13 8B     	LDAL PDotQuote		; compile "jsr PDotQuote"
001375  1  79 10 3E     	JSRD JsrCommaA
001378  1  73 00        	JMPR CountedStringComma
00137A  1               
00137A  1               
00137A  1               CountedStringComma: ; compile a counted string
00137A  1  90 00 22     	LDAL '"'		; push '"'
00137D  1  B5 82        	STAX ZW,ModBMRB,0
00137F  1  79 08 B8     	JSRD Word		; get counted string
001382  1  D1 70 70     	LDBD VDP		; alloc the space the string is using, & return
001385  1  3A           	CLA
001386  1  89           	LDABA BW
001387  1  38           	INA
001388  1  71 0F 5D     	JMPD AllotA
00138B  1               
00138B  1               
00138B  1               ; FHdr '(.")',0 ; ( -- )
00138B  1                  ; The run-time procedure, compiled by ." which transmits the following
00138B  1                  ; in-line text to the selected output device.  See ."
00138B  1               PDotQuote:
00138B  1  3A           	CLA		; get length
00138C  1  85 41        	LDABX XW,ModBRPB,0
00138E  1  6D 82        	STXX ZW,ModBMRB,0 ; push adr for TYPE
001390  1  B5 82        	STAX ZW,ModBMRB,0 ; push length for TYPE
001392  1  50 04        	ADD XW,AW	; fix my return addr
001394  1  71 0C AB     	JMPD Type	; Type & return
001397  1               
001397  1               
001397  1               	.if 0
001397  1                FHdr 'SLiteral',0
001397  1                  ; Interpretation:
001397  1                  ;    Interpretation semantics for this word are undefined.
001397  1                  ; Compilation:
001397  1                  ;   ( c-addr1 u -- )
001397  1                  ;   Append the run-time semantics given below to the current definition.
001397  1                  ;
001397  1                  ; Run-time:
001397  1                  ;   ( -- c-addr2 u )
001397  1                  ;   Return c-addr2 u describing a string consisting of the characters specified by c-addr1 u
001397  1                  ;   during compilation. A program shall not alter the returned string.
001397  1                  ; https://forth-standard.org/standard/string/SLITERAL
001397  1               SLiteral:
001397  1               	JSRD Abort ;???
001397  1               	.endif
001397  1               
001397  1               
001397  1  53 22 42 13   FHdr 'S"',ha_immediate ; “s-quote” https://forth-standard.org/standard/core/Seq
00139B  1  6A           
00139C  1                  ; Modified to append a null to the string, so it's also zero-terminated.
00139C  1                  ; Interpretation: ( "string" -- addr len )
00139C  1                  ; Compilation: ( “ccc(quote)” -- )
00139C  1                  ;	Parse ccc delimited by " (double-quote). Append the run-time semantics given below to
00139C  1                  ;	the current definition.
00139C  1                  ; Run-time: ( -- c-addr u )
00139C  1                  ;	Return c-addr and u describing a string consisting of the characters ccc. A program shall
00139C  1                  ;	not alter the returned string.
00139C  1  91 70 82     SQuote:	LDAD VState		; compiling?
00139F  1  14 06        	BZ @19
0013A1  1  90 13 C9     	LDAL SQuoteR		;   compile JSRD
0013A4  1  79 10 3E     	JSRD JsrCommaA
0013A7  1               @19:
0013A7  1               
0013A7  1  90 00 22     	LDAL '"'		; get the counted string to VDP
0013AA  1  B5 82        	STAX ZW,ModBMRB,0
0013AC  1  79 08 B8     	JSRD Word
0013AF  1  D1 70 70     	LDBD VDP
0013B2  1  3A           	CLA
0013B3  1  85 21        	LDABX BW,ModBRPB,0
0013B5  1  F5 82        	STBX ZW,ModBMRB,0	; push addr
0013B7  1  B5 82        	STAX ZW,ModBMRB,0	; push length
0013B9  1  38           	INA			; allocate the space, & return
0013BA  1  79 0F 5D     	JSRD AllotA
0013BD  1  3A           	CLA			; append a null
0013BE  1  79 10 77     	JSRD CCommaA
0013C1  1               
0013C1  1  91 70 82     	LDAD VState		; compiling?
0013C4  1  14 02        	BZ @39
0013C6  1  30 83        	INR ZW,4		;   drop addr & length
0013C8  1               @39:
0013C8  1  09           	RSR
0013C9  1               
0013C9  1               
0013C9  1               ; FHdr '(S")',0 ; ( -- c-addr u )	run-time code for S"
0013C9  1  3A           SQuoteR: CLA			; get length byte
0013CA  1  85 41        	LDABX XW,ModBRPB,0
0013CC  1  6D 82        	STXX ZW,ModBMRB,0	; push addr
0013CE  1  B5 82        	STAX ZW,ModBMRB,0	; push length
0013D0  1  50 04        	ADD XW,AW		; advance over the string data
0013D2  1  3E           	INXC			; also skip the trailing null
0013D3  1  09           	RSR
0013D4  1               
0013D4  1               
0013D4  1               	.if 0
0013D4  1                FHdr 'S\"',0
0013D4  1                  ; Interpretation:
0013D4  1                  ;   Interpretation semantics for this word are undefined.
0013D4  1                  ; Compilation:
0013D4  1                  ;   ( "ccc<quote>" -- )
0013D4  1                  ;   Parse ccc delimited by " (double-quote), using the translation rules below. Append the run-time semantics
0013D4  1                  ;   given below to the current definition.
0013D4  1               	JSRD Abort ;???
0013D4  1               	.endif
0013D4  1               
0013D4  1               
0013D4  1               	.if 0
0013D4  1                FHdr 'Environment?',0 ; ( c-addr u -- false | i * x true )
0013D4  1               EnvironmentQ:
0013D4  1               	JSRD Abort ;???
0013D4  1               	.endif
0013D4  1               
0013D4  1               
0013D4  1  28 46 69 6E   FHdr '(Find)',0 ; ( addr1 addr2 -- cfa b true ) (found)
0013D8  1  64 29 06 13  
0013DC  1  9C           
0013DD  1               		; ( addr1 addr2 --      false ) (notfound)
0013DD  1                  ; Searches the dictionary starting at the code address addr2,
0013DD  1                  ; matching to the counted string at addr1.
0013DD  1                  ; Returns name address (= code address), length byte of name field and boolean true for a good match.
0013DD  1                  ; If not match is found, only a boolean false is left.
0013DD  1               PFind:
0013DD  1  6D A2        	STXX SW,ModBMRB,0	; push X
0013DF  1               @addr2 = 0	; current word addr; must be offset 0
0013DF  1               @charlen = 2
0013DF  1               @nameadr = 4	; * last char of pattern name
0013DF  1               @len	= 6
0013DF  1               @zw	= 8
0013DF  1  55 80        	XFR AW,ZW
0013E1  1  B5 A2        	STAX SW,ModBMRB,0	; @zw
0013E3  1  65 88 02     	LDXX ZW,ModNBRB,2	; get addr1
0013E6  1  3A           	CLA			; get length
0013E7  1  85 41        	LDABX XW,ModBRPB,0
0013E9  1  B5 A2        	STAX SW,ModBMRB,0	; @len
0013EB  1  5D           	XAB
0013EC  1  50 42        	ADD BW,XW
0013EE  1  F5 A2        	STBX SW,ModBMRB,0	; @nameadr
0013F0  1  C5 28 FF     	LDBBX BW,ModNBRB,$ff	; get last char of name
0013F3  1  45 30        	XFRB AH,BL
0013F5  1  B5 A2        	STAX SW,ModBMRB,0	; @charlen
0013F7  1  55 80        	XFR AW,ZW		; @addr2
0013F9  1  30 01        	INR AW,2
0013FB  1  B5 A2        	STAX SW,ModBMRB,0
0013FD  1               
0013FD  1  65 A0        @21:	LDXX SW,ModBRB,@addr2	; reload word ptr
0013FF  1  95 A8 02     	LDAX SW,ModNBRB,@charlen ; reload constant regs
001402  1  5E           	XAZ
001403  1  90 DF 3F     	LDAL $df*$100+ha_length+ha_smudge
001406  1  65 48 FE     @23:	LDXX XW,ModNBRB,$fe	; follow dictionary link to next word
001409  1  14 4D        	BZ @notfound
00140B  1  D5 48 FC     	LDBX XW,ModNBRB,$fc	; check last char & length
00140E  1  54 82        	ORE BW,ZW		;   saved @charlen
001410  1  5A           	NAB			;   saved bitmask
001411  1  15 F3        	BNZ @23
001413  1  6D A0        	STXX SW,ModBRB,@addr2	; save word ptr
001415  1               
001415  1  31 42        	DCR XW,3		; X=1 + end of name in word
001417  1  95 A8 04     	LDAX SW,ModNBRB,@nameadr ; Y=1 + end of name pattern
00141A  1  5C           	XAY
00141B  1  95 A8 06     	LDAX SW,ModNBRB,@len	; Z=# chars in name
00141E  1  5E           	XAZ
00141F  1  80 DF        	LDABL $df
001421  1  45 18        	XFRB ZH,AL
001423  1               @32:				; for each char
001423  1  21 90        	DCRB ZL			;   decrement length
001425  1  16 1A        	BM @found
001427  1  85 42        	LDABX XW,ModBMRB,0	;   get name char
001429  1  C5 62        	LDBBX YW,ModBMRB,0	;   get pattern char
00142B  1  44 13        	OREB BL,AL		;   compare for exact match
00142D  1  14 F4        	BZ @32
00142F  1  42 83        	ANDB BL,ZH		;   just a case mismatch?
001431  1  15 CA        	BNZ @21
001433  1  42 81        	ANDB AL,ZH		;   cvt char to uppercase
001435  1  C0 41        	LDBBL 'A'		;   >='A'
001437  1  49           	SABB
001438  1  11 C3        	BNL @21
00143A  1  C0 5B        	LDBBL 'Z'+1		;   <='Z'
00143C  1  49           	SABB
00143D  1  11 E4        	BNL @32
00143F  1  73 BC        	JMPR @21
001441  1               
001441  1               @found:
001441  1  65 A0        	LDXX SW,ModBRB,@addr2	; get addr2
001443  1  30 A7        	INR SW,@zw		; rdrop the work area
001445  1  95 A1        	LDAX SW,ModBRPB,0	; restore ZW
001447  1  5E           	XAZ
001448  1  6D 88 02     	STXX ZW,ModNBRB,2	; save cfa
00144B  1  3A           	CLA			; save b
00144C  1  85 48 FD     	LDABX XW,ModNBRB,$fd
00144F  1  BC           	STAA ZW
001450  1  90 00 01     	LDAL 1			; push flag
001453  1  B5 82        	STAX ZW,ModBMRB,0
001455  1  65 A1        	LDXX SW,ModBRPB,0	; pop X
001457  1  09           	RSR
001458  1               
001458  1               @notfound:
001458  1  30 A7        	INR SW,@zw		; rdrop the work area
00145A  1  95 A1        	LDAX SW,ModBRPB,0	; restore ZW
00145C  1  5E           	XAZ
00145D  1  30 81        	INR ZW,2		; drop addr2
00145F  1  3A           	CLA			; set flag false
001460  1  BC           	STAA ZW
001461  1  65 A1        	LDXX SW,ModBRPB,0	; pop X
001463  1  09           	RSR			; return
001464  1               
001464  1               
001464  1               	.if 0
001464  1                FHdr 'Find',0 ; ( c-addr -- c-addr 0 | xt 1 | xt -1 )
001464  1                  ; https://forth-standard.org/standard/core/FIND
001464  1               	JSRD Abort ;???
001464  1               	.endif
001464  1               
001464  1               
001464  1  2D 46 69 6E   FHdr '-Find',0	; ( "name" -- cfa b true  ) (found)
001468  1  64 05 13 DD  
00146C  1               		; ( "name" --       false ) (not found)
00146C  1                  ; Accepts the next text word (delimited by blanks) in the input stream to HERE,
00146C  1                  ; and searches the CONTEXT and then CURRENT vocabularies for a matching entry.
00146C  1                  ; If found, the dictionary entry's name field address (= CFA), its length byte,
00146C  1                  ; and a bool true is left.  Otherwise, only a bool false is left.
00146C  1  79 0A 0D     DFind:	JSRD Bl			; get next word
00146F  1  79 08 B8     	JSRD Word
001472  1               
001472  1               	.if 0  ; debugging
001472  1               	JSRD PDotQuote
001472  1               	.byte 13," found word '"
001472  1               	JSRD Here
001472  1               	JSRD Count
001472  1               	JSRD Type
001472  1               	JSRD PDotQuote
001472  1               	.byte 2,"' "
001472  1               	.endif
001472  1               
001472  1  79 0B 96     	JSRD Here		; search Context
001475  1  92 70 7E     	LDAI VContext
001478  1  B5 82        	STAX ZW,ModBMRB,0
00147A  1  79 13 DD     	JSRD PFind
00147D  1  9C           	LDAA ZW			; if not found
00147E  1  15 0D        	BNZ @2073
001480  1  30 81        	INR ZW,2		;    drop the false
001482  1  79 0B 96     	JSRD Here		;    search Current
001485  1  92 70 80     	LDAI VCurrent
001488  1  B5 82        	STAX ZW,ModBMRB,0
00148A  1  79 13 DD     	JSRD PFind
00148D  1  09           @2073:	RSR
00148E  1               
00148E  1               
00148E  1  27 41 14 6C   FHdr "'",ha_immediate ; ( "name" -- nfa )
001492  1                  ; Used in the form:
001492  1                  ;	' nnnn
001492  1                  ; Leaves the code address of dictionary word nnnn.  As a compiler
001492  1                  ; directive, executes in a colon-definition to compile the address as a
001492  1                  ; literal.  If the word is not found after a search of CONTEXT and CURRENT,
001492  1                  ; an appropriate error message is given.  Pronounced "tick".
001492  1                  ; https://forth-standard.org/standard/core/Tick
001492  1  79 14 6C     Tick:	JSRD DFind		; get name string, search active dictionarys
001495  1  79 05 5F     	JSRD ZEqual		; throw exception if not found
001498  1  32 20        	CLR BW,Err_0
00149A  1  79 0E DE     	JSRD QErrY
00149D  1  30 81        	INR ZW,2		; drop word flags
00149F  1  71 15 25     	JMPD Literal		; handle addr as literal
0014A2  1               
0014A2  1               
0014A2  1  4C 46 41 03   FHdr 'LFA',0 ; ( pfa -- lfa )
0014A6  1  14 92        
0014A8  1                  ; Convert the Parameter Field Address of a word to its Link Field Address.
0014A8  1  9C           LFA:	LDAA ZW
0014A9  1  31 04        	DCR AW,3+2
0014AB  1  BC           	STAA ZW
0014AC  1  09           	RSR
0014AD  1               
0014AD  1               
0014AD  1  43 46 41 03   FHdr 'CFA',0 ; ( pfa -- cfa )
0014B1  1  14 A8        
0014B3  1                  ; Convert the Parameter Field Address of a word to its Code Field Address.
0014B3  1  9C           CFA:	LDAA ZW
0014B4  1  31 02        	DCR AW,3
0014B6  1  BC           	STAA ZW
0014B7  1  09           	RSR
0014B8  1               
0014B8  1               
0014B8  1  4E 46 41 03   FHdr 'NFA',0; ( pfa -- nfa )
0014BC  1  14 B3        
0014BE  1                  ; Convert the Parameter Field Address of a word to its Name Field Address.
0014BE  1  73 F3        NFA:	JMPR CFA		; NFA=CFA in this inplementaion
0014C0  1               
0014C0  1               
0014C0  1  50 46 41 03   FHdr 'PFA',0 ; ( nfa -- pfa )
0014C4  1  14 BE        
0014C6  1                  ; Convert the Name Field Address of a word to its Parameter Field Address.
0014C6  1  9C           PFA:	LDAA ZW			; NFA=CFA in this implementation
0014C7  1  30 02        	INR AW,3
0014C9  1  BC           	STAA ZW
0014CA  1  09           	RSR
0014CB  1               
0014CB  1               
0014CB  1  3E 42 6F 64   FHdr '>Body',0 ; ( xt -- a-addr )
0014CF  1  79 05 14 C6  
0014D3  1                  ; a-addr is the data-field address corresponding to xt.
0014D3  1                  ; An ambiguous condition exists if xt is not for a word defined via CREATE.
0014D3  1                  ; https://forth-standard.org/standard/core/toBODY
0014D3  1  73 F1        ToBody:	JMPR PFA
0014D5  1               
0014D5  1               
0014D5  1               	.if 0
0014D5  1               
0014D5  1                FHdr 'Name>Compile',0 ; ( nt -- x xt )
0014D5  1                  ; x xt represents the compilation semantics of the word nt.
0014D5  1                  ; The returned xt has the stack effect ( i * x x -- j * x ).
0014D5  1                  ; Executing xt consumes x and performs the compilation semantics of the word represented by nt.
0014D5  1                  ; https://forth-standard.org/standard/tools/NAMEtoCOMPILE
0014D5  1               NameToCompile:
0014D5  1               	JSRD Abort ;???
0014D5  1               
0014D5  1               
0014D5  1                FHdr 'Name>Interpret',0 ; ( nt -- xt | 0 )
0014D5  1                  ; xt represents the interpretation semantics of the word nt.
0014D5  1                  ; If nt has no interpretation semantics, NAME>INTERPRET returns 0.
0014D5  1                  ; https://forth-standard.org/standard/tools/NAMEtoINTERPRET
0014D5  1               NameToInterpret:
0014D5  1               	JSRD Abort ;???
0014D5  1               
0014D5  1               	.endif
0014D5  1               
0014D5  1               
0014D5  1  4E 61 6D 65   FHdr 'Name>String',0 ; ( nfa -- c_addr u )
0014D9  1  3E 53 74 72  
0014DD  1  69 6E 67 0B  
0014E1  1  14 D3        
0014E3  1                  ; Get a word's name from its Name Field Address (aka CFA).
0014E3  1                  ;   https://forth-standard.org/standard/tools/NAMEtoSTRING
0014E3  1               NameToString:
0014E3  1  9C           	LDAA ZW		; get nfa
0014E4  1  31 02        	DCR AW,3
0014E6  1  5C           	XAY		; Y=cfa-3 (ptr to length & flags)
0014E7  1  8B           	LDABA YW	; get length
0014E8  1  D0 00 1F     	LDBL ha_length
0014EB  1  52 20        	ANDC AW,BW
0014ED  1  B5 82        	STAX ZW,ModBMRB,0 ; store length
0014EF  1  51 60        	SUB AW,YW	; calc start addr
0014F1  1  B5 88 02     	STAX ZW,ModNBRB,2 ; store addr
0014F4  1  09           	RSR
0014F5  1               
0014F5  1               ;@6:
0014F5  1               ; ???handle limited stored chars
0014F5  1               ;	bit #$80
0014F5  1               ;	beq @3
0014F5  1               ;	bra @7
0014F5  1               ;@6:	lda #'-'
0014F5  1               ;	jsr EmitA
0014F5  1               ;@7:	DCR N
0014F5  1               ;	bpl @6
0014F5  1               
0014F5  1               ;	pla
0014F5  1               ;	jmp Space
0014F5  1               
0014F5  1               
0014F5  1  49 64 2E 03   FHdr 'Id.',0 ; ( nfa -- )  Print a definition's name from its code field address.
0014F9  1  14 E3        
0014FB  1  7B E6        IdDot:	JSRR NameToString
0014FD  1  79 0C AB     	JSRD Type
001500  1  71 0C 8B     	JMPD Space
001503  1               
001503  1               
001503  1  5B 43 6F 6D   FHdr '[Compile]',ha_immediate
001507  1  70 69 6C 65  
00150B  1  5D 49 14 FB  
00150F  1               ; Used in a colon-definition in form:
00150F  1               ;	: xxx [COMPILE] FORTH ;
00150F  1               ; [COMPILE] will force the compilation of an immediate definition, that would otherwise
00150F  1               ; execute during compilation.  The above example will select the FORTH vocabulary when xxx
00150F  1               ; executes, rather than at compile time.
00150F  1               BCompile:
00150F  1  79 13 09     	JSRD LBracket		; dont' have Tick compile it's results
001512  1  79 14 92     	JSRD Tick		; lookup the word
001515  1               ;	JSRR CFA		; CFA=NFA in this implementation
001515  1  79 10 19     	JSRD CompileComma	; compile call
001518  1  71 13 12     	JMPD RBracket		; back to compiling, & return
00151B  1               
00151B  1               
00151B  1  4C 69 74 65   FHdr 'Literal',ha_immediate ; ( n -- ) (compiling)
00151F  1  72 61 6C 47  
001523  1  15 0F        
001525  1               ; If compiling, then compile the stack value n as a 16 bit literal. This
001525  1               ; definition is immediate so that it will execute during a colon definition.
001525  1               ; The intended use is:
001525  1               ;	: xxx [ calculate ] LITERAL ;
001525  1               ; Compilation is suspended for the compile time calculation of a value.
001525  1               ; Compilation is resumed and LITERAL compiles this value.
001525  1               ; https://forth-standard.org/standard/core/LITERAL
001525  1               Literal:
001525  1  91 70 82     	LDAD VState		; interpreting?
001528  1  15 01        	BNZ LitComma
00152A  1  09           	RSR
00152B  1               
00152B  1               LitComma:
00152B  1  79 10 86     	JSRD LdaComma		; compile "LDAL n"
00152E  1               PushAComma:			; compile "sta (-z)"
00152E  1  90 B5 82     	LDAL $B582
001531  1  71 10 5D     	JMPD CommaA
001534  1               
001534  1               
001534  1               
001534  1  32 4C 69 74   FHdr '2Literal',ha_immediate ; ( d -- d ) (executing)
001538  1  65 72 61 6C  
00153C  1  48 15 25     
00153F  1               			     ; ( d --   ) (compiling)
00153F  1                  ; If compiling, compile a stack double number into a literal.  Later execution
00153F  1                  ; of the definition containing the literal will push it to the stack.
00153F  1                  ; If executing, the number will remain on the stack.
00153F  1                  ; https://forth-standard.org/standard/double/TwoLITERAL
00153F  1               TwoLiteral:
00153F  1  91 70 82     	LDAD VState		; interpreting?
001542  1  14 0C        	BZ @2242
001544  1               
001544  1  79 10 7E     	JSRD LdbaComma		; compile "ldy #d.hi" "lda #d.lo"
001547  1  79 15 2E     	JSRD PushAComma		; compile "STAX ZW,ModBMRB,0"
00154A  1  90 F5 82     	LDAL $F582		; compile "STBX ZW,ModBMRB,0"
00154D  1  71 10 5D     	JMPD CommaA
001550  1               
001550  1  09           @2242:	RSR			; return
001551  1               
001551  1               
001551  1  5B 43 68 61   FHdr '[Char]',ha_immediate ; compile a character literal
001555  1  72 5D 46 15  
001559  1  3F           
00155A  1                  ; compile: ( "c" -- )
00155A  1                  ; run: ( -- c )
00155A  1                  ; Also: Number interprets 'c' as a character literal.
00155A  1               ; https://forth-standard.org/standard/core/BracketCHAR
00155A  1  7B 09        BChar:	JSRR Char
00155C  1  73 C7        	JMPR Literal		; make a literal, & return
00155E  1               
00155E  1               
00155E  1  43 68 61 72   FHdr 'Char',0 ; ( "<spaces>name" -- char )  Get value of ASCII char
001562  1  04 15 5A     
001565  1                  ; https://forth-standard.org/standard/core/CHAR
001565  1                  ; Skip leading space delimiters. Parse name delimited by a space. Put the value of its first character onto the stack.
001565  1  79 0A 0D     Char:	JSRD Bl			; get next word
001568  1  79 08 B8     	JSRD Word
00156B  1  D1 70 70     	LDBD VDP		; point at counted string
00156E  1  3A           	CLA			; get 1st char
00156F  1  85 28 01     	LDABX BW,ModNBRB,1
001572  1  B5 82        	STAX ZW,ModBMRB,0	; push it
001574  1  09           	RSR
001575  1               
001575  1               
001575  1  5B 27 5D 43   FHdr "[']",ha_immediate ; compile a word address literal
001579  1  15 65        
00157B  1                  ; https://forth-standard.org/standard/core/BracketTick
00157B  1  79 14 92     BTB:	JSRD Tick
00157E  1  73 A5        	JMPR Literal
001580  1               
001580  1               
001580  1  3B 53 02 15   FHdr ';S',0 ; ( -- )  Stop interpretation of a screen.
001584  1  7B           
001585  1                  ; Not anymore!: ;S was also the run-time word compiled at the
001585  1                  ; end of a colon-defintion which returns execution to the calling procedure.
001585  1  65 A1        SemiS:	LDXX SW,ModBRPB,0 ; drop our RSR addr, so we'll return to Interpret's caller
001587  1  09           	RSR		; return
001588  1               
001588  1               
001588  1  00 41 15 85   FHdr 0,ha_immediate ; ( -- )  end-of-buffer
00158C  1                  ; This is the dictionary entry for a name of one char of ASCII null.
00158C  1                  ; It is the execution procedure to terminate interpretation of a line of text from the terminal
00158C  1                  ; or within a disc buffer, as disk buffers always have a null just beyond the end.
00158C  1  91 70 74     X_:	LDAD VBlk	; terminal?
00158F  1  14 F4        	BZ SemiS
001591  1               
001591  1  3A           	CLA
001592  1  B1 70 76     	STAD VIn	; at the beginning of the Blk
001595  1  91 70 74     	LDAD VBlk	; step to next Blk
001598  1  30 0F        	INR AW
00159A  1  B1 70 74     	STAD VBlk
00159D  1  B5 82        	STAX ZW,ModBMRB,0 ; push Blk
00159F  1  79 09 E5     	JSRD Zero	;   as a double
0015A2  1  79 0A 36     	JSRD BScr	; divide by blocks/screen
0015A5  1  79 06 6F     	JSRD UMSlashMod	;  ( u_rem u_quot )
0015A8  1  30 81        	INR ZW,2	; drop quot
0015AA  1  95 81        	LDAX ZW,ModBRPB,0 ; at end_of_screen?
0015AC  1  15 05        	BNZ @1828
0015AE  1  79 0F 02     	JSRD QExec	;   verify we're interpreting
0015B1  1  65 A1        	LDXX SW,ModBRPB,0 ;   pop my RSR addr, so we'll return to Interpret's caller
0015B3  1  09           @1828:	RSR		; return
0015B4  1               
0015B4  1               
0015B4  1  49 6E 74 65   FHdr 'Interpret',0 ;
0015B8  1  72 70 72 65  
0015BC  1  74 09 15 8C  
0015C0  1                  ; The other text interpreter which sequentially executes or compiles text from the
0015C0  1                  ; input stream (terminal or disc) depending on STATE .  If the word name cannot be
0015C0  1                  ; found after a search of CONTEXT and then CURRENT it is converted to a number
0015C0  1                  ; according to the current base.  That also failing, an error message echoing the
0015C0  1                  ; name with a " ?" will be given.
0015C0  1                  ; Text input will be taken according to the convention for WORD.  If a decimal point
0015C0  1                  ; is found as part of a number, a double number value will be left.  The decimal
0015C0  1                  ; point has no other purpose than to force this action.
0015C0  1                  ; See NUMBER
0015C0  1               Interpret:
0015C0  1  79 0E BB     @2272:	JSRD QStack		; check stack bounds
0015C3  1               
0015C3  1  81 70 90     	LDABD VLineComment	; ignore remainder of line?
0015C6  1  14 19        	BZ @49
0015C8  1  3A           	CLA
0015C9  1  A1 70 90     	STABD VLineComment
0015CC  1  D1 70 74     	LDBD VBlk		; reading from disk?
0015CF  1  15 02        	BNZ @51
0015D1  1  7B B9        	JSRR X_			;  do end-of-line
0015D3  1  91 70 76     @51:	LDAD VIn		; go fwd to next C/L boundary
0015D6  1  D0 00 3F     	LDBL 64-1		; C/L 1-
0015D9  1  58           	AAB
0015DA  1  90 FF C0     	LDAL $FFC0		; C/L Invert
0015DD  1  5A           	NAB
0015DE  1  F1 70 76     	STBD VIn
0015E1  1               @49:
0015E1  1  79 14 6C     	JSRD DFind		; get next word from input & lookup
0015E4  1  95 81        	LDAX ZW,ModBRPB,0	; found?
0015E6  1  14 16        	BZ @2289
0015E8  1  95 81        	LDAX ZW,ModBRPB,0	; get flags & name_length
0015EA  1  D1 70 82     	LDBD VState		; compiling?
0015ED  1  14 0A        	BZ @2284
0015EF  1  C0 40        	LDBBL ha_immediate	; immediate flag set?
0015F1  1  4A           	NABB
0015F2  1  15 05        	BNZ @2284
0015F4  1               ;	JSRD CFA		; pfa to cfa
0015F4  1  79 10 19     	JSRD CompileComma	; compile a jsr to it
0015F7  1  73 C7        	JMPR @2272		; next word
0015F9  1               
0015F9  1               @2284:
0015F9  1               ;	JSRD CFA		; pfa to cfa
0015F9  1  79 07 E3     	JSRD Execute		; execute it
0015FC  1  73 C2        	JMPR @2272		; next word
0015FE  1               
0015FE  1  79 0B 96     @2289:	JSRD Here		; convert it to a number
001601  1  79 09 72     	JSRD Number
001604  1  91 70 86     	LDAD VDPL		; contained a '.'?
001607  1  38           	INA
001608  1  14 05        	BZ @2299
00160A  1  79 15 3F     	JSRD TwoLiteral		; compile a double-cell literal
00160D  1  73 B1        	JMPR @2272		; next word
00160F  1               
00160F  1  30 81        @2299:	INR ZW,2		; convert double-cell number to single-cell (drop hi cell)
001611  1  79 15 25     	JSRD Literal		; compile a single-cell literal
001614  1  73 AA        	JMPR @2272
001616  1               
001616  1               
001616  1  56 6F 63 61   FHdr 'Vocabulary',0 ; ( "name" -- )
00161A  1  62 75 6C 61  
00161E  1  72 79 0A 15  
001622  1  C0           
001623  1                  ; A defining word used in the form:
001623  1                  ;	VOCABULARY cccc
001623  1                  ; to create a vocabulary definition cccc .  Subsequent use of cccc will make it the CONTEXT
001623  1                  ; vocabulary which is searched first by INTERPRET .  The sequence "cccc DEFINITIONS" will
001623  1                  ; also make ccc the CURRENT vocabulary into which new definitions are placed.
001623  1                  ;
001623  1                  ; In fig-FORTH, cccc will be so chained as to include all definitions of the
001623  1                  ; vocabulary in which cccc is itself defined.  All vocabularys ultimately chain back to
001623  1                  ; Forth .  By convention, vocabulary names are to be declared IMMEDIATE .
001623  1                  ; See VOC-LINK
001623  1                  ; See Forth for a sample vocabulary word.
001623  1               Vocabulary:
001623  1  79 12 14     	JSRD HeaderComma	; compile a word header
001626  1  79 12 69     	JSRD Immediate		; make it immediate
001629  1  90 16 41     	LDAL DoVoc		; compile "jsr DoVoc"
00162C  1  79 10 3E     	JSRD JsrCommaA
00162F  1               
00162F  1  92 70 80     	LDAI VCurrent		; compile dictionary anchor
001632  1  79 10 5D     	JSRD CommaA
001635  1  D1 70 70     	LDBD VDP		; link into vocabulary chain
001638  1  91 70 72     	LDAD VVoc_Link
00163B  1  F1 70 72     	STBD VVoc_Link
00163E  1  71 10 5D     	JMPD CommaA
001641  1               
001641  1               
001641  1               DoVoc: ; set Context to this vocabulary
001641  1  69 70 7E     	STXD VContext
001644  1  65 A1        	LDXX SW,ModBRPB,0	; pop pfa
001646  1  09           	RSR			; return
001647  1               
001647  1               
001647  1  46 6F 72 74   FHdr 'Forth',ha_immediate ; The primary vocabulary.
00164B  1  68 45 16 23  
00164F  1                  ; Execution makes FORTH the CONTEXT vocabulary.
00164F  1                  ; Until additional user vocabularies are defined, new user definitions become part
00164F  1                  ; of FORTH .  FORTH is immediate, so it will execute during the creation of a
00164F  1                  ; colon-definition, to select this vocabularty at compile time.
00164F  1  79 16 41     Forth:	JSRD DoVoc	; use direct addressing, so PFA offset looks like other Vocab words
001652  1  00 00        XFor:	.dbyt 0		; points to latest word in this vocabulary
001654  1  00 00        	.dbyt 0		; vocab link, ends at zero
001656  1               
001656  1               
001656  1  44 65 66 69   FHdr 'Definitions',0 ; Set the CURRENT vocabulary to the CONTEXT vocabulary.
00165A  1  6E 69 74 69  
00165E  1  6F 6E 73 0B  
001662  1  16 4F        
001664  1                  ; Used in the form:
001664  1                  ;	cccc DEFINITIONS
001664  1                  ; In the example, executing vocabulary name cccc made it the CONTEXT vocabulary
001664  1                  ; and executing DEFINITIONS made both specify vocabulary cccc .
001664  1                  ; https://forth-standard.org/standard/search/DEFINITIONS
001664  1               Definitions:
001664  1  91 70 7E     	LDAD VContext		; get context dictionary
001667  1  B1 70 80     	STAD VCurrent		; set as current dictionary
00166A  1  09           	RSR
00166B  1               
00166B  1               
00166B  1  28 41 16 64   FHdr '(',ha_immediate ;
00166F  1                  ; Used in the form:
00166F  1                  ;	( cccc)
00166F  1                  ; Ignore a comment that will be delimited by a right parenthesis on the same line.
00166F  1                  ; May occur during execution or in a colon-definition.
00166F  1                  ; A blank after the leading parenthesis is required.
00166F  1                  ; https://forth-standard.org/standard/core/p
00166F  1  90 00 29     OParen:	LDAL ')'	; push ')'
001672  1  B5 82        	STAX ZW,ModBMRB,0
001674  1  71 08 B8     	JMPD Word	; get the string delimited by ')', & return
001677  1               
001677  1               
001677  1  5C 41 16 6F   FHdr '\',ha_immediate ; ignore rest of input line
00167B  1                  ; https://forth-standard.org/standard/block/bs
00167B  1                  ; https://forth-standard.org/standard/core/bs
00167B  1  32 01        	CLR AW,1
00167D  1  A1 70 90     	STABD VLineComment
001680  1  09           	RSR
001681  1               
001681  1               
001681  1               	.if 0
001681  1                FHdr 'Refill',0 ; ( -- flag )
001681  1                  ; Attempt to fill the input buffer from the input source, returning a true flag if successful.
001681  1                  ; When the input source is the user input device, attempt to receive input into the terminal input buffer.
001681  1                  ; If successful, make the result the input buffer, set >IN to zero, and return true.
001681  1                  ; Receipt of a line containing no characters is considered successful.
001681  1                  ; If there is no input available from the current input source, return false.
001681  1                  ;
001681  1                  ; When the input source is a string from EVALUATE, return false and perform no other action.
001681  1                  ; https://forth-standard.org/standard/block/REFILL
001681  1               	JSRD Abort ;???
001681  1               	.endif
001681  1               
001681  1               
001681  1  51 75 69 74   FHdr 'Quit',0 ; ( -- )
001685  1  04 16 7B     
001688  1                  ; Clear the return stack, stop compilation, and return control to the operators
001688  1                  ; terminal.  No message is given.
001688  1                  ; https://forth-standard.org/standard/core/QUIT
001688  1  3A           Quit:	CLA
001689  1  A1 70 90     	STABD VLineComment	; disable line ignore
00168C  1  B1 70 74     	STAD VBlk		; input from console
00168F  1  B1 70 82     	STAD VState		; interpret mode
001692  1               @2388:				; begin
001692  1  79 02 31     	JSRD EmptyRStack	;   empty return stack
001695  1  79 0C 76     	JSRD CR			;   newline
001698  1  79 0E 44     	JSRD Query		;   get string to TIB
00169B  1  79 15 C0     	JSRD Interpret		;   interpret words in the string
00169E  1  91 70 82     	LDAD VState		;   compiling?
0016A1  1  15 07        	BNZ @2399
0016A3  1  79 13 8B     	JSRD PDotQuote		;     type " OK"
0016A6  1  03 20 4F 4B  	.byte 3,' OK'
0016AA  1               @2399:
0016AA  1  73 E6        	JMPR @2388		;  again
0016AC  1               
0016AC  1               
0016AC  1  41 62 6F 72   FHdr 'Abort"',ha_immediate ; Abort with inline message
0016B0  1  74 22 46 16  
0016B4  1  88           
0016B5  1                  ; compile: ( "string" -- )
0016B5  1                  ; run: ( f -- )
0016B5  1  79 0E EB     AbortQ:	JSRD QComp		; verify we're compiling
0016B8  1  90 16 C1     	LDAL @Run		; compile JSR
0016BB  1  79 10 3E     	JSRD JsrCommaA
0016BE  1  71 13 7A     	JMPD CountedStringComma
0016C1  1               
0016C1  1               @Run: ; runtime
0016C1  1  3A           	CLA			; get inline string length
0016C2  1  85 41        	LDABX XW,ModBRPB,0
0016C4  1  D5 81        	LDBX ZW,ModBRPB,0	; pop f
0016C6  1  15 03        	BNZ @RunErr
0016C8  1  50 04        	ADD XW,AW		; skip inline string
0016CA  1  09           	RSR
0016CB  1               
0016CB  1  F5 82        @RunErr: STBX ZW,ModBMRB,0	; push string addr
0016CD  1  B5 82        	STAX ZW,ModBMRB,0	; push string length
0016CF  1  79 0C AB     	JSRD Type		; type it
0016D2  1  73 08        	JMPR Abort		; abort
0016D4  1               
0016D4  1               
0016D4  1  41 62 6F 72   FHdr 'Abort',0 ;
0016D8  1  74 05 16 B5  
0016DC  1                  ; Clears the stacks and enter the execution state.  Return control to the
0016DC  1                  ; operators terminal, printing a message appropriate to the installation.
0016DC  1  79 02 45     Abort:	JSRD EmptyStack		; empty the param stack
0016DF  1  79 03 7C     	JSRD RAt		; type address that called us
0016E2  1  79 1C 5C     	JSRD EX4
0016E5  1  79 0C D4     	JSRD Decimal		; set base to decimal
0016E8  1  79 18 02     	JSRD DR0		; select disc drive 0
0016EB  1  79 0C 76     	JSRD CR			; newline
0016EE  1  79 13 8B     	JSRD PDotQuote		; type literal
0016F1  1  19 66 69 67  	.byte 25,'fig-FORTH CPU6 subroutine'
0016F5  1  2D 46 4F 52  
0016F9  1  54 48 20 43  
0016FD  1  50 55 36 20  
001701  1  73 75 62 72  
001705  1  6F 75 74 69  
001709  1  6E 65        
00170B  1  79 16 4F     	JSRD Forth		; make Forth vocabulary current
00170E  1  79 16 64     	JSRD Definitions	;   & definitions
001711  1  71 16 88     	JMPD Quit		; restart the interpreter
001714  1               
001714  1               
001714  1  43 6F 6C 64   FHdr 'Cold',0 ;	Cold start the system.
001718  1  04 16 DC     
00171B  1                  ; May be called from the terminal to remove application programs and restart.
00171B  1               Cold:
00171B  1               ;	LDABL $40	; Add & link test 1
00171B  1               ;	LDBBL $80
00171B  1               ;	AABB
00171B  1               ;	BNL @11
00171B  1               ;	HLT
00171B  1               ;@11:
00171B  1               
00171B  1               ;	LDABL $40	; Add & link test 2
00171B  1               ;	LDBBL $fe
00171B  1               ;	AABB
00171B  1               ;	BL @12
00171B  1               ;	HLT
00171B  1               ;@12:
00171B  1               
00171B  1               ;	LDBBL $40	; Sub & link test 1
00171B  1               ;	LDABL 2
00171B  1               ;	SABB
00171B  1               ;	BNL @13		;   no borrow
00171B  1               ;	HLT
00171B  1               ;@13:
00171B  1               
00171B  1               ;	LDBBL $40		; Sub & link test 2
00171B  1               ;	LDABL $42
00171B  1               ;	SABB
00171B  1               ;	BL @14			;   borrow
00171B  1               ;	HLT
00171B  1               ;@14:
00171B  1               
00171B  1               ;	LDAL $c000
00171B  1               ;	XAS
00171B  1               ;	LDAL $8800		; to diag ROM CPU test
00171B  1               ;	XAZ
00171B  1               ;	JMPD $8849
00171B  1               
00171B  1  3A           	CLA			; disable RAM disk
00171C  1  B1 70 5C     	STAD RamDiskCount
00171F  1               
00171F  1  91 02 0C     	LDAD ORIG+$0C		; Initialize Forth vocabulary
001722  1  B1 16 52     	STAD XFor
001725  1  80 16        	LDABL 2+VVoc_Link-VUser	; user variables to initialize
001727  1  73 02        	JMPR L2433
001729  1               
001729  1               Warm: ; warm start the system
001729  1  80 10        	LDABL 2+VWarning-VUser	; user variaboles to initialize
00172B  1               L2433:
00172B  1  60 02 0C     	LDXL ORIG+$0c		; init some user variables from cold start area
00172E  1  D0 70 5E     	LDBL VUser
001731  1  55 26        	XFR YW,BW
001733  1  C5 41        @2437:	LDBBX XW,ModBRPB,0
001735  1  E5 61        	STBBX YW,ModBRPB,0
001737  1  29           	DCAB
001738  1  17 F9        	BP @2437
00173A  1               
00173A  1  79 02 31     	JSRD EmptyRStack	; empty return stack
00173D  1               
00173D  1  79 02 45     	JSRD EmptyStack		; empty param stack
001740  1  79 0C D4     	JSRD Decimal
001743  1               ;	JSRD UMStarTest1
001743  1               ;	JSRD UMSlashModTest1
001743  1               ;	JSRD MSlashModTest1
001743  1               
001743  1               ;	LDAL 12345		; test decimal print
001743  1               ;	STAX ZW,ModBMRB,0
001743  1               ;	JSRD Dot
001743  1               
001743  1  71 16 DC     	JMPD Abort		; And off we go!
001746  1               
001746  1               
001746  1               	.if 0
001746  1                FHdr 'Using',0 ; ( "filename" -- )  Open a block file
001746  1               Using:	JSRD Bl
001746  1               	JSRD Word
001746  1               	HLT ; open the filename as a block file
001746  1               	RSR
001746  1               	.endif
001746  1               
001746  1               
001746  1  55 73 65 03   FHdr 'Use',0 ; ( -- addr )  variable:
00174A  1  17 1B        
00174C  1  90 70 00     Use:	LDAL VUse
00174F  1  B5 82        	STAX ZW,ModBMRB,0
001751  1  09           	RSR
001752  1               
001752  1               
001752  1  50 72 65 76   FHdr 'Prev',0 ; ( -- adr )  variable:
001756  1  04 17 4C     
001759  1  90 70 02     Prev:	LDAL VPrev
00175C  1  B5 82        	STAX ZW,ModBMRB,0
00175E  1  09           	RSR
00175F  1               
00175F  1               
00175F  1  46 69 72 73   FHdr 'First',0 ; ( -- adr )  constant: address of the first (lowest) block buffer.
001763  1  74 05 17 59  
001767  1  90 71 A1     First:	LDAL DArea
00176A  1  B5 82        	STAX ZW,ModBMRB,0
00176C  1  09           	RSR
00176D  1               
00176D  1               
00176D  1  4C 69 6D 69  FHdr 'Limit',0 ; ( -- adr )  constant: address just above the highest memory available
001771  1  74 05 17 67  
001775  1               		; for a disc buffer.
001775  1  90 75 B1     Limit:	LDAL DAreaEnd
001778  1  B5 82        	STAX ZW,ModBMRB,0
00177A  1  09           	RSR
00177B  1               
00177B  1               
00177B  1  2B 42 75 66   FHdr '+Buf',0 ; ( addr1 -- addr2 f )
00177F  1  04 17 75     
001782  1               ; Advance the disc buffer address addr1 to the address of the next buffer addr2.
001782  1               ; Bool f is false when addr2 is the buffer presently pointed to by variable PREV.
001782  1  90 01 04     PBuf:	LDAL 2+SectorSize+2	 ; hold block #, one sector, ??? two num
001785  1  DC           	LDBA ZW
001786  1  50 20        	ADD AW,BW
001788  1  D1 17 76     	LDBD Limit+1
00178B  1  59           	SAB
00178C  1  10 03        	BL @2691
00178E  1  91 17 68     	LDAD First+1
001791  1  BC           @2691:	STAA ZW
001792  1  D1 70 02     	LDBD VPrev
001795  1  54 20        	ORE AW,BW
001797  1  B5 82        	STAX ZW,ModBMRB,0
001799  1  09           	RSR
00179A  1               
00179A  1               
00179A  1  55 70 64 61   FHdr 'Update',0 ; ( -- )
00179E  1  74 65 06 17  
0017A2  1  82           
0017A3  1                  ; Marks the most recently referenced block (pointed to by PREV ) as altered.
0017A3  1                  ; The block will subsequently be transferred automatically to disc should its
0017A3  1                  ; buffer be required for storage of a different block.
0017A3  1                  ; https://forth-standard.org/standard/block/UPDATE
0017A3  1  D0 80 00     Update:	LDBL $8000	; set the hi bit of the block # in the PREV block
0017A6  1  91 70 02     	LDAD VPrev
0017A9  1  5C           	XAY
0017AA  1  9B           	LDAA YW
0017AB  1  53 20        	ORI AW,BW
0017AD  1  BB           	STAA YW
0017AE  1  09           	RSR
0017AF  1               
0017AF  1               
0017AF  1               	.if 0
0017AF  1                FHdr 'Save-Buffers',0 ; ( -- )  Transfer the contents of each UPDATEd block buffer to mass storage. Mark all buffers as unmodified.
0017AF  1                  ; https://forth-standard.org/standard/block/SAVE-BUFFERS
0017AF  1               Save_Buffers:
0017AF  1               	JSRD Abort ;???
0017AF  1               	.endif
0017AF  1               
0017AF  1               
0017AF  1  46 6C 75 73   FHdr 'Flush',0 ; ( -- )  Flush modified blocks back to disk
0017B3  1  68 05 17 A3  
0017B7  1                  ; https://forth-standard.org/standard/block/FLUSH
0017B7  1  91 17 68     Flush:	LDAD First+1		; for each available block buffer
0017BA  1  B5 A2        @2835:	STAX SW,ModBMRB,0
0017BC  1  90 7F FF     	LDAL $7FFF		;   alloc a buffer for block $7fff
0017BF  1  B5 82        	STAX ZW,ModBMRB,0	;     ( removing the existing contents )
0017C1  1  79 18 1B     	JSRD Buffer
0017C4  1  30 81        	INR ZW,2		;   drop the addr
0017C6  1  95 A1        	LDAX SW,ModBRPB,0	;  next available block buffer
0017C8  1  D0 01 04     	LDBL SectorSize+4
0017CB  1  50 20        	ADD AW,BW
0017CD  1  D1 17 76     	LDBD Limit+1
0017D0  1  59           	SAB
0017D1  1  11 E7        	BNL @2835
0017D3  1  09           	RSR			; return
0017D4  1               
0017D4  1               
0017D4  1  45 6D 70 74   FHdr "Empty-Buffers",0 ; ( -- )  Mark all block-buffers as empty
0017D8  1  79 2D 42 75  
0017DC  1  66 66 65 72  
0017E0  1  73 0D 17 B7  
0017E4  1                  ; not necessarily affecting the contents.
0017E4  1                  ; Updated blocks are not written to the disc.
0017E4  1                  ; This is also an initialization procedure before first use of the disc.
0017E4  1                  ; https://forth-standard.org/standard/block/EMPTY-BUFFERS
0017E4  1               Empty_Buffers:
0017E4  1  91 17 68     	LDAD First+1		; init Use & Prev
0017E7  1  B1 70 00     	STAD VUse
0017EA  1  B1 70 02     	STAD VPrev
0017ED  1               
0017ED  1  79 17 67     	JSRD First	; zero all the disc buffer bytes, & return
0017F0  1  79 17 75     	JSRD Limit
0017F3  1  79 02 C1     	JSRD Over
0017F6  1  79 04 BC     	JSRD Subtract
0017F9  1  71 0C 22     	JMPD Erase
0017FC  1               
0017FC  1               
0017FC  1  44 52 30 03  	FHdr 'DR0',0 ; ( -- )  select disc drive 0
001800  1  17 E4        
001802  1  3A           DR0:	CLA
001803  1  B1 70 7C     DRA:	STAD VOffset	; Offset=0
001806  1  09           	RSR		; return
001807  1               
001807  1               
001807  1  44 52 31 03  	FHdr 'DR1',0 ; ( -- )  select disc drive 1
00180B  1  18 02        
00180D  1  90 03 20     DR1:	LDAL Sectors	; Offset=sectors	(sectors per drive)
001810  1  73 F1        	JMPR DRA
001812  1               
001812  1               
001812  1  42 75 66 66   FHdr 'Buffer',0 ; ( n -- addr )  Obtain the next memory buffer, assigning it to block n.
001816  1  65 72 06 18  
00181A  1  0D           
00181B  1                  ; If the contents of the buffer is marked as updated, it is written to the disk.
00181B  1                  ; The block is not read from the disc.
00181B  1                  ; The address left is the first cell within the buffer for data storage.
00181B  1                  ; https://forth-standard.org/standard/block/BUFFER
00181B  1  91 70 00     Buffer:	LDAD VUse
00181E  1  B5 82        	STAX ZW,ModBMRB,0
001820  1  79 17 82     @2758:	JSRD PBuf
001823  1  95 81        	LDAX ZW,ModBRPB,0
001825  1  14 F9        	BZ @2758
001827  1               
001827  1  D1 70 00     	LDBD VUse		;modified?
00182A  1  99           	LDAA BW
00182B  1  17 10        	BP @2776
00182D  1  30 21        	INR BW,2		;  write old buffer contents
00182F  1  F5 82        	STBX ZW,ModBMRB,0
001831  1  D0 7F FF     	LDBL $7fff
001834  1  5A           	NAB
001835  1  F5 82        	STBX ZW,ModBMRB,0
001837  1  79 09 E5     	JSRD Zero
00183A  1  79 1A 70     	JSRD RSlashW
00183D  1               @2776:
00183D  1               
00183D  1  95 81        	LDAX ZW,ModBRPB,0	; save this block buffer address
00183F  1  B1 70 00     	STAD VUse
001842  1  5C           	XAY
001843  1               
001843  1  D5 81        	LDBX ZW,ModBRPB,0	; store block #
001845  1  FB           	STBA YW
001846  1  D0 01 02     	LDBL 2+SectorSize	; insert terminating nulls
001849  1  58           	AAB
00184A  1  3A           	CLA
00184B  1  B9           	STAA BW
00184C  1  55 60        	XFR AW,YW
00184E  1  B1 70 02     	STAD VPrev
001851  1               
001851  1  38           	INA			; return data buffer addr
001852  1  38           	INA
001853  1  B5 82        	STAX ZW,ModBMRB,0
001855  1  09           	RSR
001856  1               
001856  1               
001856  1  42 6C 6F 63   FHdr 'Block',0 ; ( n -- addr )  Leave the memory address of the block buffer containing block n.
00185A  1  6B 05 18 1B  
00185E  1                  ; If the block
00185E  1                  ; is not already in memory, it is transferred from disc to which ever buffer was
00185E  1                  ; least recently written.  If the block occupying that buffer has been marked as
00185E  1                  ; updated, it is rewritten to disc before block n is read into the buffer.
00185E  1                  ; See also BUFFER, R/W UPDATE FLUSH
00185E  1                  ; https://forth-standard.org/standard/block/BLOCK
00185E  1  95 81        Block:	LDAX ZW,ModBRPB,0	; calc physical block #
001860  1  D1 70 7C     	LDBD VOffset
001863  1  58           	AAB
001864  1  B5 A2        	STAX SW,ModBMRB,0
001866  1               
001866  1  91 70 02     	LDAD VPrev		; Start at VPrev
001869  1  B5 81        	STAX ZW,ModBRPB,0
00186B  1  9C           	LDAA ZW			; if not block match
00186C  1  98           	LDAA AW
00186D  1  DD           	LDBA SW
00186E  1  54 20        	ORE AW,BW
001870  1  3D           	SLA
001871  1  14 31        	BZ @2830
001873  1               
001873  1               @2805:				;   begin
001873  1  79 17 82     	JSRD PBuf		;     step to next buffer
001876  1  95 81        	LDAX ZW,ModBRPB,0	;     if it is VUse
001878  1  15 1E        	BNZ @2818
00187A  1  30 81        	INR ZW,2		;       drop
00187C  1  79 03 7C     	JSRD RAt		;       allocate buffer
00187F  1  79 18 1B     	JSRD Buffer
001882  1  79 02 DE     	JSRD Dup		;       read contents
001885  1  79 03 7C     	JSRD RAt
001888  1  79 09 EE     	JSRD One
00188B  1  79 1A 70     	JSRD RSlashW
00188E  1  DC           	LDBA ZW			;       point at header
00188F  1  31 21        	DCR BW,2
001891  1  FC           	STBA ZW
001892  1  90 01 02     	LDAL 2+SectorSize	;       insert terminating nulls
001895  1  58           	AAB
001896  1  3A           	CLA
001897  1  B9           	STAA BW
001898  1               @2818:				;      then
001898  1  9C           	LDAA ZW			;    until block match
001899  1  98           	LDAA AW
00189A  1  DD           	LDBA SW
00189B  1  54 20        	ORE AW,BW
00189D  1  3D           	SLA
00189E  1  15 D3        	BNZ @2805
0018A0  1  9C           	LDAA ZW			;   set VPrev
0018A1  1  B1 70 02     	STAD VPrev
0018A4  1               
0018A4  1               @2830:				;  then
0018A4  1  30 A1        	INR SW,2		; rdrop
0018A6  1  71 04 5E     	JMPD TwoPlus		; point at data
0018A9  1               
0018A9  1               
0018A9  1  28 4C 69 6E   FHdr '(Line)',0 ; ( n_line n_screen -- addr count )
0018AD  1  65 29 06 18  
0018B1  1  5E           
0018B2  1                  ; Convert the line number n_line and the screen n_screen to the disc buffer address
0018B2  1                  ; containing the data.  A count of 64 indicates the full line text length.
0018B2  1  79 03 8F     PLine:	JSRD ToR		; save n_screen
0018B5  1  79 0A 1A     	JSRD CSlashL		; get chars per line
0018B8  1  79 0A 28     	JSRD BBuf		; get bytes per disc buffer
0018BB  1  79 07 56     	JSRD StarSlashMod	; convert n_line to disc block # & offset
0018BE  1  79 03 85     	JSRD RFrom		; get n_screen
0018C1  1  79 0A 36     	JSRD BScr		; get disc blocks per screen
0018C4  1  79 07 20     	JSRD Star		; convert screen to disc blocks
0018C7  1  79 04 7D     	JSRD Plus		; add screen blocks to line blocks
0018CA  1  7B 92        	JSRR Block		; read the disc block
0018CC  1  79 04 7D     	JSRD Plus		; add offset
0018CF  1  71 0A 1A     	JMPD CSlashL		; get chars per line, & return
0018D2  1               
0018D2  1               
0018D2  1  2E 4C 69 6E   FHdr '.Line',0 ; ( n_line n_screen -- )
0018D6  1  65 05 18 B2  
0018DA  1               DotLine:
0018DA  1  79 18 B2     	JSRD PLine
0018DD  1  79 08 21     	JSRD DTrailing
0018E0  1  71 0C AB     	JMPD Type
0018E3  1               
0018E3  1               
0018E3  1  4D 65 73 73   FHdr 'Message',0 ; ( n -- )
0018E7  1  61 67 65 07  
0018EB  1  18 DA        
0018ED  1                  ; Print on the selected output device the text of line n relative to screen 4
0018ED  1                  ; of drive 0.  n may be positive or negative.  MESSAGE may be used to print
0018ED  1                  ; incidental text such as report headers.  If WARNING is zero, the message will
0018ED  1                  ; simply be printed as a number (disc unavailable).
0018ED  1               Message:
0018ED  1  9C           	LDAA ZW		; n=0 gives no message
0018EE  1  14 20        	BZ @2886
0018F0  1  D0 00 17     	LDBL @IndexCount ; built-in message?
0018F3  1  59           	SAB
0018F4  1  11 2A        	BNL @Int
0018F6  1  D1 70 6C     @Ext:	LDBD VWarning	; short messages?
0018F9  1  14 18        	BZ @2888
0018FB  1  90 00 04     	LDAL 4		; messages start in block 4
0018FE  1  B5 82        	STAX ZW,ModBMRB,0
001900  1  91 70 7C     	LDAD VOffset
001903  1  B5 82        	STAX ZW,ModBMRB,0
001905  1  79 0A 36     	JSRD BScr
001908  1  79 07 3E     	JSRD Slash
00190B  1  79 04 BC     	JSRD Subtract
00190E  1  73 CA        	JMPR DotLine	; type the line, & return
001910  1               
001910  1  30 81        @2886:	INR ZW,2	; drop n
001912  1  09           	RSR		; return
001913  1               
001913  1  79 13 8B     @2888:	JSRD PDotQuote	; type literal
001916  1  06 4D 73 67  	.byte 6,'Msg # '
00191A  1  20 23 20     
00191D  1  71 0D EC     	JMPD Dot	; type n, & return
001920  1               
001920  1               
001920  1               @Int:	; internal message text?
001920  1  D0 19 33     	LDBL @Index	; get index
001923  1  58           	AAB
001924  1  3A           	CLA
001925  1  89           	LDABA BW
001926  1  14 CE        	BZ @Ext		; if we don't have one, try external
001928  1  D0 19 4A     	LDBL @Msg
00192B  1  58           	AAB
00192C  1  FC           	STBA ZW
00192D  1  79 07 ED     	JSRD Count
001930  1  71 0C AB     	JMPD Type
001933  1               
001933  1  00 01 0D 00  @Index:	.byte 0,@Msg1-@Msg,@Msg2-@Msg,0
001937  1  1D 00 2A 35  	.byte @Msg4-@Msg,0,@Msg6-@Msg,@Msg7-@Msg
00193B  1  44 00 00 00  	.byte @Msg8-@Msg,0,0,0
00193F  1  00 00 00 00  	.byte 0,0,0,0
001943  1  00 51 5E 6B  	.byte 0,@Msg17-@Msg,@Msg18-@Msg,@Msg19-@Msg
001947  1  83 9B B3     	.byte @Msg20-@Msg,@Msg21-@Msg,@Msg22-@Msg
00194A  1               @IndexCount = *-@Index
00194A  1               
00194A  1  00           @Msg:	.byte 0
00194B  1  0B 45 6D 70  @Msg1:	.byte 11,'Empty stack'
00194F  1  74 79 20 73  
001953  1  74 61 63 6B  
001957  1  0F 44 69 63  @Msg2:	.byte 15,'Dictionary full'
00195B  1  74 69 6F 6E  
00195F  1  61 72 79 20  
001963  1  66 75 6C 6C  
001967  1  0C 49 73 6E  @Msg4:	.byte 12,"Isn't unique"
00196B  1  27 74 20 75  
00196F  1  6E 69 71 75  
001973  1  65           
001974  1  0A 44 69 73  @Msg6:	.byte 10,'Disc range'
001978  1  63 20 72 61  
00197C  1  6E 67 65     
00197F  1  0E 53 74 61  @Msg7:	.byte 14,"Stack overflow"
001983  1  63 6B 20 6F  
001987  1  76 65 72 66  
00198B  1  6C 6F 77     
00198E  1  0C 44 69 73  @Msg8:	.byte 12,"Disk I/O err"
001992  1  6B 20 49 2F  
001996  1  4F 20 65 72  
00199A  1  72           
00199B  1  0C 43 6F 6D  @Msg17:	.byte 12,'Compile only'
00199F  1  70 69 6C 65  
0019A3  1  20 6F 6E 6C  
0019A7  1  79           
0019A8  1  0C 45 78 65  @Msg18:	.byte 12,'Execute only'
0019AC  1  63 75 74 65  
0019B0  1  20 6F 6E 6C  
0019B4  1  79           
0019B5  1  17 43 6F 6E  @Msg19:	.byte 23,'Conditionals not paired'
0019B9  1  64 69 74 69  
0019BD  1  6F 6E 61 6C  
0019C1  1  73 20 6E 6F  
0019C5  1  74 20 70 61  
0019C9  1  69 72 65 64  
0019CD  1  17 44 65 66  @Msg20:	.byte 23,'Definition not finished'
0019D1  1  69 6E 69 74  
0019D5  1  69 6F 6E 20  
0019D9  1  6E 6F 74 20  
0019DD  1  66 69 6E 69  
0019E1  1  73 68 65 64  
0019E5  1  17 49 6E 20  @Msg21:	.byte 23,'In protected dictionary'
0019E9  1  70 72 6F 74  
0019ED  1  65 63 74 65  
0019F1  1  64 20 64 69  
0019F5  1  63 74 69 6F  
0019F9  1  6E 61 72 79  
0019FD  1  15 55 73 65  @Msg22:	.byte 21,'Use only when loading'
001A01  1  20 6F 6E 6C  
001A05  1  79 20 77 68  
001A09  1  65 6E 20 6C  
001A0D  1  6F 61 64 69  
001A11  1  6E 67        
001A13  1               
001A13  1               
001A13  1               MessageA: ; entry with n in A
001A13  1  B5 82        	STAX ZW,ModBMRB,0
001A15  1  71 18 ED     	JMPD Message
001A18  1               
001A18  1               
001A18  1               	.if 0
001A18  1               
001A18  1                FHdr 'Source',0 ; ( -- c-addr u )
001A18  1                  ; c-addr is the address of, and u is the number of characters in, the input buffer.
001A18  1                  ; https://forth-standard.org/standard/core/SOURCE
001A18  1               	JSRD Abort ;???
001A18  1               
001A18  1               
001A18  1                FHdr 'Source-Id',0 ; ( -- 0 | -1 )
001A18  1                  ; Identifies the input source as follows:
001A18  1                  ; SOURCE-ID	Input source
001A18  1                  ;   -1	String (via EVALUATE)
001A18  1                  ;    0	User input device
001A18  1                  ; https://forth-standard.org/standard/core/SOURCE-ID
001A18  1               	JSRD Abort ;???
001A18  1               
001A18  1               
001A18  1                FHdr 'Restore-Input',0 ; ( xn ... x1 n -- flag )
001A18  1                  ; Attempt to restore the input source specification to the state described by x1 through xn.
001A18  1                  ; flag is true if the input source specification cannot be so restored.
001A18  1                  ;
001A18  1                  ; An ambiguous condition exists if the input source represented by the arguments is not the same as the current input source.
001A18  1                  ; https://forth-standard.org/standard/core/RESTORE-INPUT
001A18  1               	JSRD Abort ;???
001A18  1               
001A18  1               
001A18  1                FHdr 'Save-Input',0 ; ( -- xn ... x1 n )
001A18  1                  ; x1 through xn describe the current state of the input source specification for later use by RESTORE-INPUT.
001A18  1                  ; https://forth-standard.org/standard/core/SAVE-INPUT
001A18  1               	JSRD Abort ;???
001A18  1               
001A18  1               
001A18  1                FHdr 'Evaluate',0 ; ( i * x c-addr u -- j * x )
001A18  1                  ; https://forth-standard.org/standard/block/EVALUATE
001A18  1                  ; https://forth-standard.org/standard/core/EVALUATE
001A18  1               Evaluate:
001A18  1               	JSRD Abort ;???
001A18  1               
001A18  1               	.endif
001A18  1               
001A18  1               
001A18  1  4C 6F 61 64   FHdr 'Load',0 ; ( n -- )  Begin interpretation of screen n.
001A1C  1  04 18 ED     
001A1F  1                  ; Loading will terminate at the end of the screen or at ;S .
001A1F  1                  ; See ;S -->
001A1F  1                  ; https://forth-standard.org/standard/block/LOAD
001A1F  1  91 70 74     Load:	LDAD VBlk	; save existing Blk & In
001A22  1  B5 A2        	STAX SW,ModBMRB,0
001A24  1  91 70 76     	LDAD VIn
001A27  1  B5 A2        	STAX SW,ModBMRB,0
001A29  1  3A           	CLA
001A2A  1  B1 70 76     	STAD VIn	; In=0
001A2D  1  79 0A 36     	JSRD BScr	; Blk=n*(blocks_per_screen)
001A30  1  79 07 20     	JSRD Star
001A33  1  95 81        	LDAX ZW,ModBRPB,0
001A35  1  B1 70 74     	STAD VBlk
001A38  1               
001A38  1  79 15 C0     	JSRD Interpret	; interpret the disc block
001A3B  1               
001A3B  1  95 A1        	LDAX SW,ModBRPB,0 ; restore Blk & In
001A3D  1  B1 70 76     	STAD VIn
001A40  1  95 A1        	LDAX SW,ModBRPB,0
001A42  1  B1 70 74     	STAD VBlk
001A45  1  09           	RSR		; return
001A46  1               
001A46  1               
001A46  1  2D 2D 3E 43   FHdr '-->',ha_immediate ; ( -- )  Continue interpretation with the next disc screen.
001A4A  1  1A 1F        
001A4C  1  79 0F 4A     NextB:	JSRD QLoad	; verify that we're LOADing
001A4F  1  3A           	CLA
001A50  1  B1 70 76     	STAD VIn	; offset in block =0
001A53  1  79 0A 36     	JSRD BScr	; move Blk to start of next screen
001A56  1  91 70 74     	LDAD VBlk
001A59  1  B5 82        	STAX ZW,ModBMRB,0
001A5B  1  79 02 C1     	JSRD Over
001A5E  1  79 07 49     	JSRD Mod
001A61  1  79 04 BC     	JSRD Subtract
001A64  1  79 0A BD     	JSRD Blk
001A67  1  71 07 72     	JMPD PlusStore
001A6A  1               
001A6A  1               
001A6A  1               	.if 0
001A6A  1                FHdr 'Thru',0 ; ( i * x u1 u2 -- j * x )
001A6A  1                  ; LOAD the mass storage blocks numbered u1 through u2 in sequence.
001A6A  1                  ; Other stack effects are due to the words LOADed.
001A6A  1                  ; https://forth-standard.org/standard/block/THRU
001A6A  1               Thru:	JSRD Abort ;???
001A6A  1               	.endif
001A6A  1               
001A6A  1               
001A6A  1               	.if 0
001A6A  1                FHdr 'Include',0 ; ( "filename" -- )  Interpret text from the file
001A6A  1               	JSRD Abort ; ???do something
001A6A  1               	RSR
001A6A  1               	.endif
001A6A  1               
001A6A  1               
001A6A  1  52 2F 57 03   FHdr 'R/W',0 ; ( addr blk f -- )  The fig-FORTH standard disc read-write linkage.
001A6E  1  1A 4C        
001A70  1                  ; addr specifies the source or destination block buffer,
001A70  1                  ; blk is the sequential number of the referenced block;
001A70  1                  ; and f is a flag for f=0 write and f=1 read.
001A70  1                  ; R/W determines the location on mass storage, performs the read-write and
001A70  1                  ; performs any error checking.
001A70  1               RSlashW:
001A70  1  D1 70 5C     	LDBD RamDiskCount	; is the RAM disk initialized?
001A73  1  15 03        	BNZ @RD
001A75  1               
001A75  1               	; we have no disk yet!
001A75  1  79 16 DC     @Abort:	JSRD Abort
001A78  1               
001A78  1               @RD: ; Use RAM disk
001A78  1  95 88 02     	LDAX ZW,ModNBRB,2	; block # in range?
001A7B  1  59           	SAB
001A7C  1  10 F7        	BL @Abort
001A7E  1  35 07        	SLR AW,8		; cvt to bytes
001A80  1  D1 70 5A     	LDBD RamDiskStart
001A83  1  58           	AAB
001A84  1  9C           	LDAA ZW			; get f
001A85  1  14 0F        	BZ @RdWrite
001A87  1               
001A87  1               @RdRead:			; move from RAM disk to buffer
001A87  1  95 88 04     	LDAX ZW,ModNBRB,4
001A8A  1  F5 88 04     	STBX ZW,ModNBRB,4
001A8D  1  B5 88 02     	STAX ZW,ModNBRB,2
001A90  1  90 01 00     @Rd2:	LDAL 256
001A93  1  71 0B B3     	JMPD CMove
001A96  1               
001A96  1               @RdWrite:			; move from buffer to RAM disk
001A96  1  F5 88 02     	STBX ZW,ModNBRB,2
001A99  1  73 F5        	JMPR @Rd2
001A9B  1               
001A9B  1               
001A9B  1  52 61 6D 44   FHdr 'RamDisk',0 ; ( n -- )  alloc n blocks of RAM disk, & init
001A9F  1  69 73 6B 07  
001AA3  1  1A 70        
001AA5  1  D1 70 70     	LDBD VDP		; remember where RAM disk starts
001AA8  1  F1 70 5A     	STBD RamDiskStart
001AAB  1  9C           	LDAA ZW
001AAC  1  F5 82        	STBX ZW,ModBMRB,0
001AAE  1  B1 70 5C     	STAD RamDiskCount
001AB1  1  35 07        	SLR AW,8
001AB3  1  BC           	STAA ZW
001AB4  1  B5 82        	STAX ZW,ModBMRB,0
001AB6  1  79 0F 5B     	JSRD Allot
001AB9  1  71 0C 22     	JMPD Erase
001ABC  1               
001ABC  1               
001ABC  1  46 6F 72 67   FHdr 'Forget',0 ; ( "name" -- )
001AC0  1  65 74 06 1A  
001AC4  1  A5           
001AC5  1                  ; https://forth-standard.org/standard/tools/FORGET
001AC5  1                  ; Executed in the form:
001AC5  1                  ;	FORGET cccc
001AC5  1                  ; Deletes definition named cccc from the dictionary with all entries
001AC5  1                  ; physically following it.  In fig-FORTH, an error message will occur
001AC5  1                  ; if the CURRENT and CONTEXT vocabularies are not currently the same.
001AC5  1  79 14 92     Forget:	JSRD Tick		; get "name" text & look up in dictionary
001AC8  1  9C           	LDAA ZW			; check Fence (assumes startup image is below user dictionary space)
001AC9  1  D1 70 6E     	LDBD VFence
001ACC  1  59           	SAB
001ACD  1  10 06        	BL @3
001ACF  1  D0 00 15     	LDBL Err_InProtectedDictionary
001AD2  1  79 0E F4     	JSRD ErrorY
001AD5  1               @3:
001AD5  1               
001AD5  1  9C           @3220:	LDAA ZW			; while addr < latest vocabulary word
001AD6  1  D1 70 72     	LDBD VVoc_Link
001AD9  1  59           	SAB
001ADA  1  10 0F        	BL @3225
001ADC  1  79 16 4F     	JSRD Forth
001ADF  1  79 16 64     	JSRD Definitions
001AE2  1  91 70 72     	LDAD VVoc_Link		;   unlink
001AE5  1  98           	LDAA AW
001AE6  1  B1 70 72     	STAD VVoc_Link
001AE9  1  73 EA        	JMPR @3220
001AEB  1               @3225:
001AEB  1               
001AEB  1  95 81        	LDAX ZW,ModBRPB,0	; pop forgotten word ptr
001AED  1  5C           	XAY
001AEE  1  31 62        	DCR YW,3		; point at flags & length byte
001AF0  1               
001AF0  1  3A           	CLA
001AF1  1  8B           	LDABA YW		; fix VDP
001AF2  1  C0 1F        	LDBBL ha_length
001AF4  1  5A           	NAB
001AF5  1               ;	cmp VWidth		;   name truncated?
001AF5  1               
001AF5  1  51 62        	SUB BW,YW
001AF7  1  31 20        	DCR BW,1		;  -1 for junk name length count
001AF9  1  F1 70 70     	STBD VDP
001AFC  1               
001AFC  1  95 68 01     	LDAX YW,ModNBRB,1	; fix dictionary
001AFF  1  D1 70 72     	LDBD VVoc_Link
001B02  1  B5 28 FE     	STAX BW,ModNBRB,$fe
001B05  1               
001B05  1  09           	RSR
001B06  1               
001B06  1               
001B06  1               	.if 0
001B06  1                FHdr 'Marker',0 ; ( "<spaces>name" -- )
001B06  1                  ;   Skip leading space delimiters. Parse name delimited by a spac'e.
001B06  1                  ;   Create a definition for name with the execution semantics defined below.
001B06  1                  ; name Execution:
001B06  1                  ;   ( -- )
001B06  1                  ;   Restore all dictionary allocation and search order pointers to the state they had just prior to the definition of name.
001B06  1                  ;   Remove the definition of name and all subsequent definitions. Restoration of any structures still existing that could refer to deleted definitions or deallocated data space is not necessarily provided. No other contextual information such as numeric base is affected.
001B06  1               Marker:	JSRD Abort ;???
001B06  1               	.endif
001B06  1               
001B06  1               
001B06  1               	.if 0
001B06  1                FHdr 'TraverseE-WordList',0 ; ( i * x xt wid -- j * x )
001B06  1                  ; Remove wid and xt from the stack. Execute xt once for every word in the wordlist wid, passing the name token nt of the word to xt,
001B06  1                  ; until the wordlist is exhausted or until xt returns false.
001B06  1                  ;
001B06  1                  ; The invoked xt has the stack effect ( k * x nt -- l * x flag ).
001B06  1                  ;
001B06  1                  ; If flag is true, TRAVERSE-WORDLIST will continue with the next name, otherwise it will return.
001B06  1                  ; TRAVERSE-WORDLIST does not put any items other than nt on the stack when calling xt,
001B06  1                  ; so that xt can access and modify the rest of the stack.
001B06  1                  ;
001B06  1                  ; TRAVERSE-WORDLIST may visit words in any order, with one exception: words with the same name are called in the order
001B06  1                  ; newest-to-oldest (possibly with other words in between).
001B06  1                  ;
001B06  1                  ; An ambiguous condition exists if words are added to or deleted from the wordlist wid during the execution of TRAVERSE-WORDLIST.
001B06  1                  ; https://forth-standard.org/standard/tools/TRAVERSE-WORDLIST
001B06  1               Traverse_WordList:
001B06  1               	JSRD Abort ;???
001B06  1               	.endif
001B06  1               
001B06  1               
001B06  1  4C 69 73 74   FHdr 'List',0 ; ( n -- )  Display the ASCII text of screen n on the selected output device.
001B0A  1  04 1A C5     
001B0D  1                  ; SCR contains the screen number during and after this process.
001B0D  1                  ; https://forth-standard.org/standard/block/LIST
001B0D  1  79 0C D4     List:	JSRD Decimal	; Base=decimal
001B10  1  79 0C 76     	JSRD CR		; newline
001B13  1  9C           	LDAA ZW		; Scr=n
001B14  1  B1 70 7A     	STAD VScr
001B17  1  79 13 8B     	JSRD PDotQuote	; type literal
001B1A  1  06 53 43 52  	.byte 6,'SCR # '
001B1E  1  20 23 20     
001B21  1  79 0D EC     	JSRD Dot	; type n
001B24  1  3A           	CLA		; for line=0 to 16
001B25  1  B5 A2        @3620:	STAX SW,ModBMRB,0 ;   save line#
001B27  1  79 0C 76     	JSRD CR		;   newline
001B2A  1  79 03 7C     	JSRD RAt	;   type current line# in 3 chars
001B2D  1  79 0A 02     	JSRD Three
001B30  1  79 0D C3     	JSRD DotR
001B33  1  79 0C 8B     	JSRD Space	;   type a space
001B36  1  79 03 7C     	JSRD RAt	;   type the line
001B39  1  91 70 7A     	LDAD VScr
001B3C  1  B5 82        	STAX ZW,ModBMRB,0
001B3E  1  79 18 DA     	JSRD DotLine
001B41  1  95 A1        	LDAX SW,ModBRPB,0 ;  next line
001B43  1  38           	INA
001B44  1  C0 10        	LDBBL 16
001B46  1  49           	SABB
001B47  1  15 DC        	BNZ @3620
001B49  1  71 0C 76     	JMPD CR		; newline, & return
001B4C  1               
001B4C  1               
001B4C  1  49 6E 64 65   FHdr 'Index',0 ; ( from to -- )  Print the first line of each screen over the range from, to.
001B50  1  78 05 1B 0D  
001B54  1                  ; This is used to view the comment lines of an area on disc screens.
001B54  1  79 0C 76     Index:	JSRD CR		; newline
001B57  1  9C           	LDAA ZW		; to++
001B58  1  38           	INA
001B59  1  BC           	STAA ZW
001B5A  1               @3647:			; for screen#=from to to
001B5A  1  79 0C 76     	JSRD CR		;   newline
001B5D  1  79 02 C1     	JSRD Over	;   type screen# in 3 chars
001B60  1  79 0A 02     	JSRD Three
001B63  1  79 0D C3     	JSRD DotR
001B66  1  79 0C 8B     	JSRD Space	;   type space
001B69  1  79 09 E5     	JSRD Zero	;   type 1st line of screen
001B6C  1  79 02 C1     	JSRD Over
001B6F  1  79 18 DA     	JSRD DotLine
001B72  1  79 0C 4B     	JSRD QTerminalA	;   console key available?
001B75  1  15 0B        	BNZ @break
001B77  1  95 88 02     	LDAX ZW,ModNBRB,2 ;  next
001B7A  1  38           	INA
001B7B  1  B5 88 02     	STAX ZW,ModNBRB,2
001B7E  1  DC           	LDBA ZW
001B7F  1  59           	SAB
001B80  1  10 D8        	BL @3647
001B82  1  30 83        @break:	INR ZW,4	; drop parameters
001B84  1  80 0C        	LDABL $0C	; form feed for printer, & return
001B86  1  71 0C 61     	JMPD EmitA
001B89  1               
001B89  1               
001B89  1  54 72 69 61   FHdr 'Triad',0 ; ( scr -- )
001B8D  1  64 05 1B 54  
001B91  1                  ; Display on the selected output device the three screens which include that numbered
001B91  1                  ; scr, beginning with a screen evenly divisable by 3.  Output is suitable for source text
001B91  1                  ; records, and includes a reference line at the bottom taken from line 15 of screen 4.
001B91  1  79 0A 02     Triad:	JSRD Three	; floor scr to multiple of 3
001B94  1  79 07 3E     	JSRD Slash
001B97  1  79 0A 02     	JSRD Three
001B9A  1  79 07 20     	JSRD Star
001B9D  1  79 0A 02     	JSRD Three	; end=scr+3
001BA0  1  79 02 C1     	JSRD Over
001BA3  1  79 04 7D     	JSRD Plus
001BA6  1  79 02 96     	JSRD Swap
001BA9  1  79 11 88     	JSRD PDo		; (Do)
001BAC  1               @3681:
001BAC  1  79 0C 76     	JSRD CR		;   newline
001BAF  1  79 11 9C     	JSRD I		;   type screen I
001BB2  1  79 1B 0D     	JSRD List
001BB5  1  79 11 C2     	JSRD PLoop	;  (Loop)
001BB8  1  16 F2        	BM @3681
001BBA  1  79 0C 76     	JSRD CR		; newline
001BBD  1  90 00 0F     	LDAL Err_TriadFooter ; type message $F
001BC0  1  79 1A 13     	JSRD MessageA
001BC3  1  79 0C 76     	JSRD CR		; newline
001BC6  1  80 0C        	LDABL $0C	; form feed for printer, & return
001BC8  1  71 0C 61     	JMPD EmitA
001BCB  1               
001BCB  1               
001BCB  1               	.if 0
001BCB  1               
001BCB  1                FHdr 'Parse-Name',0 ; ( "<spaces>name<space>" -- c-addr u )
001BCB  1                  ; Skip leading space delimiters. Parse name delimited by a space.
001BCB  1                  ;
001BCB  1                  ; c-addr is the address of the selected string within the input buffer and u is its length in characters.
001BCB  1                  ; If the parse area is empty or contains only white space, the resulting string has length zero.
001BCB  1                  ; https://forth-standard.org/standard/core/PARSE-NAME
001BCB  1               
001BCB  1               
001BCB  1                FHdr 'Parse',0 ; ( char "ccc<char>" -- c-addr u )  Parse ccc delimited by the delimiter char.
001BCB  1                  ;
001BCB  1                  ; c-addr is the address (within the input buffer) and u is the length of the parsed string.
001BCB  1                  ; If the parse area was empty, the resulting string has a zero length.
001BCB  1                  ; https://forth-standard.org/standard/core/PARSE
001BCB  1               
001BCB  1               	.endif
001BCB  1               
001BCB  1               
001BCB  1  56 4C 69 73   FHdr 'VList',0 ; ( -- )  FIG alias
001BCF  1  74 05 1B 91  
001BD3  1  73 08        	JMPR Words
001BD5  1               
001BD5  1               
001BD5  1  57 6F 72 64   FHdr 'Words',0 ; ( -- )  List the names of the definitions in the context vocabulary.
001BD9  1  73 05 1B D3  
001BDD  1                  ; https://forth-standard.org/standard/tools/WORDS
001BDD  1  92 70 7E     Words:	LDAI VContext	; start at head of dictionary in Context vocabulary
001BE0  1  B5 82        	STAX ZW,ModBMRB,0
001BE2  1  73 09        	JMPR @3710
001BE4  1               
001BE4  1  91 70 78     @3706:	LDAD VOut	; out of screen width?
001BE7  1  D1 0A 1B     	LDBD CSlashL+1
001BEA  1  59           	SAB
001BEB  1  11 07        	BNL @3716
001BED  1  79 0C 76     @3710:	JSRD CR		;   newline
001BF0  1  3A           	CLA
001BF1  1  B1 70 78     	STAD VOut	;   Out=0
001BF4  1               @3716:
001BF4  1  79 02 DE     	JSRD Dup	; type name
001BF7  1  79 14 FB     	JSRD IdDot
001BFA  1  79 0C 8B     	JSRD Space	; type space
001BFD  1  79 0C 4B     	JSRD QTerminalA	; terminal input char?
001C00  1  15 07        	BNZ @9
001C02  1  9C           	LDAA ZW		; goto next dictionary entry
001C03  1  95 08 FE     	LDAX AW,ModNBRB,$fe
001C06  1  BC           	STAA ZW
001C07  1  15 DB        	BNZ @3706	; end of dictionary?
001C09  1  30 81        @9:	INR ZW,2	; drop addr
001C0B  1  09           	RSR		; return
001C0C  1               
001C0C  1               
001C0C  1  42 79 65 03  	FHdr 'Bye',0 ; ( - )  Exit to the system monitor, leaving a re-entry to Forth, if possible.
001C10  1  1B DD        
001C12  1                  ; https://forth-standard.org/standard/tools/BYE
001C12  1               Bye:
001C12  1  00           	HLT		; stop the simulator
001C13  1  09           	RSR		; return
001C14  1               
001C14  1               
001C14  1               ;----------------------------------------------------------------------
001C14  1               ; Additional words
001C14  1               
001C14  1               
001C14  1  2E 53 02 1C   FHdr '.S',0 ; ( ... -- ... ) non-destructive param stack print
001C18  1  12           
001C19  1                  ; https://forth-standard.org/standard/tools/DotS
001C19  1  91 70 64     DotS:	LDAD VS0		;start at top-of-stack
001C1C  1  73 0B        	JMPR @8
001C1E  1               
001C1E  1  D5 02        @1:	LDBX AW,ModBMRB,0	; get next cell value
001C20  1  B5 A2        	STAX SW,ModBMRB,0	; save ptr
001C22  1  F5 82        	STBX ZW,ModBMRB,0	; print value
001C24  1  79 0D EC     	JSRD Dot
001C27  1  95 A1        	LDAX SW,ModBRPB,0	; restore ptr
001C29  1  55 82        @8:	XFR BW,ZW		; done?
001C2B  1  59           	SAB
001C2C  1  15 F0        	BNZ @1
001C2E  1               
001C2E  1  09           	RSR
001C2F  1               
001C2F  1               
001C2F  1               ; FHdr 'EX1',0 ; ( n -- )  type 1 hex digit
001C2F  1  95 81        EX1:	LDAX ZW,ModBRPB,0	; pop n
001C31  1  D0 00 0F     EX1A:	LDBL $f			; get lo 4 bits
001C34  1  52 20        	ANDC AW,BW
001C36  1  C0 0A        	LDBBL 10		; convert to ASCII char
001C38  1  49           	SABB
001C39  1  11 04        	BNL @3
001C3B  1  C0 07        	LDBBL 7
001C3D  1  40 31        	ADDB AL,BL
001C3F  1  C0 30        @3:	LDBBL '0'
001C41  1  40 31        	ADDB AL,BL
001C43  1  71 0C 61     	JMPD EmitA		; type, & return
001C46  1               
001C46  1               
001C46  1  45 58 32 03   FHdr 'EX2',0 ; ( n -- )  type 2 hex digits
001C4A  1  1C 19        
001C4C  1  95 81        EX2:	LDAX ZW,ModBRPB,0
001C4E  1  B5 82        EX2A:	STAX ZW,ModBMRB,0
001C50  1  34 03        	SRR AW,4
001C52  1  7B DD        	JSRR EX1A
001C54  1  73 D9        	JMPR EX1
001C56  1               
001C56  1               
001C56  1  45 58 34 03   FHdr 'EX4',0 ; ( n -- ) type 4 hex digits
001C5A  1  1C 4C        
001C5C  1  8C           EX4:	LDABA ZW		; type hi byte
001C5D  1  7B EF        	JSRR EX2A
001C5F  1  73 EB        	JMPR EX2		; type lo byte, & return
001C61  1               
001C61  1  B5 82        EX4A:	STAX ZW,ModBMRB,0
001C63  1  73 F7        	JMPR EX4
001C65  1               
001C65  1               
001C65  1  44 75 6D 70   FHdr 'Dump',0 ; ( adr len -- )  Dump memory range
001C69  1  04 1C 5C     
001C6C  1                  ; https://forth-standard.org/standard/tools/DUMP
001C6C  1               Dump:
001C6C  1               @11:				; begin
001C6C  1  79 0C 76     	JSRD CR			;   newline
001C6F  1  79 02 C1     	JSRD Over		;   type addr
001C72  1  7B E8        	JSRR EX4
001C74  1  C0 10        	LDBBL 16		;   for each byte in line
001C76  1  E5 A2        @21:	STBBX SW,ModBMRB,0
001C78  1  79 0C 8B     	JSRD Space
001C7B  1  D5 88 02     	LDBX ZW,ModNBRB,2	;     get byte
001C7E  1  85 21        	LDABX BW,ModBRPB,0
001C80  1  F5 88 02     	STBX ZW,ModNBRB,2
001C83  1  7B C9        	JSRR EX2A		;     type byte
001C85  1  C5 A1        	LDBBX SW,ModBRPB,0
001C87  1  9C           	LDAA ZW			;     decrement len
001C88  1  39           	DCA
001C89  1  BC           	STAA ZW
001C8A  1  14 06        	BZ @end
001C8C  1  21 30        	DCRB BL			;    next byte in line
001C8E  1  15 E6        	BNZ @21
001C90  1  73 DA        	JMPR @11		;  next line
001C92  1               
001C92  1  30 83        @end:	INR ZW,4		; drop len & adr
001C94  1  71 0C 8B     	JMPD Space
001C97  1               
001C97  1               
001C97  1  53 65 65 4C   FHdr 'SeeLatest',0 ; ( -- )  dump latest word's code
001C9B  1  61 74 65 73  
001C9F  1  74 09 1C 6C  
001CA3  1               SeeLatest:
001CA3  1  D2 70 80     	LDBI VCurrent		; start of last word
001CA6  1  F5 82        	STBX ZW,ModBMRB,0
001CA8  1  91 70 70     	LDAD VDP		; length
001CAB  1  59           	SAB
001CAC  1  F5 82        	STBX ZW,ModBMRB,0
001CAE  1  73 BC        	JMPR Dump		; dump, & return
001CB0  1               
001CB0  1               
001CB0  1               ; FHdr 'CC@',0 ; ( -- ud )  Get emulator cycle counter
001CB0  1               ;CCAt:	cop?? $f5	; get simulator cycle count in BA
001CB0  1               ;	STAX ZW,ModBMRB,0 ; push it
001CB0  1               ;	STBX ZW,ModBMRB,0
001CB0  1               ;	RSR
001CB0  1               
001CB0  1               
001CB0  1               
001CB0  1               	.if 0
001CB0  1                FHdr 'Modify',0 ; ( adr -- )  \ Centurion TOS-like memory modify
001CB0  1               	JSRD Abort
001CB0  1               @l:
001CB0  1               	JSRD Space
001CB0  1               	LDABX ZW,ModABRB,0	; type existing value
001CB0  1               	JSRD EX2A
001CB0  1               
001CB0  1               	CLR ZW,0    ; get the byte
001CB0  1               	JSRR @HKey
001CB0  1               	BL @9
001CB0  1               	JSRR @HKey
001CB0  1               	BL @9
001CB0  1               
001CB0  1               
001CB0  1               
001CB0  1               
001CB0  1               
001CB0  1               
001CB0  1               
001CB0  1               
001CB0  1               @HKey:	PUSH YW,2
001CB0  1               	JSRD KeyA
001CB0  1               	POP YW,2
001CB0  1               	LDBBL 'A'		; alpha?
001CB0  1               	SABB
001CB0  1               	BNL @HKNum
001CB0  1               	LDABL $5f		; uppercase
001CB0  1               	NABB
001CB0  1               	LDABL 10
001CB0  1               	ADDB AL,BL
001CB0  1               	LDBBL 16
001CB0  1               	SABB
001CB0  1               	BNL @HKOK
001CB0  1               @HKErr:	SL
001CB0  1               	RSR
001CB0  1               
001CB0  1               @HKOK:	SHL YW,4
001CB0  1               	ORIB YL,BL
001CB0  1               	RL
001CB0  1               	RSR
001CB0  1               
001CB0  1               @HkNum:	LDBBL '0'
001CB0  1               	SABB
001CB0  1               	BNL @HKErr
001CB0  1               	XFRB AL,BL
001CB0  1               	LDABL 10
001CB0  1               	SABB
001CB0  1               	BNL @HKOK
001CB0  1               	JMPR @HKErr
001CB0  1               
001CB0  1               	.endif
001CB0  1               
001CB0  1               ;-----------------------------------------------------------------------------
001CB0  1               ; CCDP interface
001CB0  1               ; https://github.com/tergav17/CCDP
001CB0  1               
001CB0  1               ; status
001CB0  1               ;	0: Successful, 0 bytes returned
001CB0  1               ;	1: Successful, 16 bytes returned
001CB0  1               ;	2: Successful, 256 bytes returned
001CB0  1               ;	254: Execution Failure, 0 bytes returned
001CB0  1               ;	255: Communication Failure, 0 bytes returned
001CB0  1               
001CB0  1               combuf		= $1C0  ; command line text
001CB0  1               
001CB0  1  53 79 73 5F   FHdr 'Sys_Done',0 ; ( -- )  Returns to the CCDP command prompt
001CB4  1  44 6F 6E 65  
001CB8  1  08 1C A3     
001CBB  1  71 01 00     	JMPD $100	; return to CCDP (also just RSR)
001CBE  1               
001CBE  1  54 74 79 5F   FHdr 'Tty_PutC',0 ; ( c -- )  Puts a character on the terminal
001CC2  1  50 75 74 43  
001CC6  1  08 1C BB     
001CC9  1               Tty_PutC:
001CC9  1  D5 81        	LDBX ZW,ModBRPB,0	; pop c
001CCB  1               Tty_PutC_A:
001CCB  1  71 01 03     	JMPD $103
001CCE  1               
001CCE  1  54 74 79 5F   FHdr 'Tty_PutB',0 ; ( n -- )  Puts a byte in hex on the terminal
001CD2  1  50 75 74 42  
001CD6  1  08 1C C9     
001CD9  1               Tty_PutB:
001CD9  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n
001CDB  1  71 01 06     	JMPD $106
001CDE  1               
001CDE  1  54 74 79 5F   FHdr 'Tty_PutW',0 ; ( n -- )  Puts a word in hex on the terminal
001CE2  1  50 75 74 57  
001CE6  1  08 1C D9     
001CE9  1               Tty_PutW:
001CE9  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n
001CEB  1  71 01 09     	JMPD $109
001CEE  1               
001CEE  1  54 74 79 5F   FHdr 'Tty_PutS',0 ; ( adr -- )  Puts a string on the terminal (zero terminated)
001CF2  1  50 75 74 53  
001CF6  1  08 1C E9     
001CF9  1               Tty_PutS:
001CF9  1  D5 81        	LDBX ZW,ModBRPB,0	; pop adr
001CFB  1  71 01 0C     	JMPD $10C	; type .asciz string pointed to by BW
001CFE  1               
001CFE  1  54 74 79 5F   FHdr 'Tty_GetC',0 ; ( -- c )  Gets a character from the terminal
001D02  1  47 65 74 43  
001D06  1  08 1C F9     
001D09  1               Tty_GetC_A = $10f
001D09  1               Tty_GetC:
001D09  1  79 01 0F     	JSRD Tty_GetC_A
001D0C  1  22 00        TtPs1:	CLRB AH
001D0E  1  B5 82        	STAX ZW,ModBMRB,0	; push c
001D10  1  09           	RSR
001D11  1               
001D11  1  54 74 79 5F   FHdr 'Tty_GetS',0 ; ( adr len -- )  Gets a line of characters from the terminal
001D15  1  47 65 74 53  
001D19  1  08 1D 09     
001D1C  1               Tty_GetS:
001D1C  1  95 81        	LDAX ZW,ModBRPB,0	; pop len
001D1E  1  39           	DCA
001D1F  1  D5 81        	LDBX ZW,ModBRPB,0	; pop adr
001D21  1  71 01 12     	JMPD $112
001D24  1               
001D24  1  54 74 79 5F   FHdr 'Tty_Next',0 ; ( -- f )  Is there is a character to read?
001D28  1  4E 65 78 74  
001D2C  1  08 1D 1C     
001D2F  1               Tty_Next_A = $12d
001D2F  1               Tty_Next:
001D2F  1  79 01 2D     	JSRD Tty_Next_A
001D32  1  73 D8        	JMPR TtPs1		; push f
001D34  1               
001D34  1  46 73 5F 4F   FHdr 'Fs_Open',0 ; ( fn_addr -- status )  Opens up a file for use, any currently opened file is closed
001D38  1  70 65 6E 07  
001D3C  1  1D 2F        
001D3E  1               Fs_Open:
001D3E  1  DC           	LDBA ZW			; get fn_addr
001D3F  1  79 01 15     	JSRD $115
001D42  1  73 54        	JMPR FsSt1		; store status
001D44  1               
001D44  1  46 73 5F 43   FHdr 'Fs_Close',0 ; ( -- status )
001D48  1  6C 6F 73 65  
001D4C  1  08 1D 3E     
001D4F  1               Fs_Close:
001D4F  1  79 01 18     	JSRD $118
001D52  1  73 B8        	JMPR TtPs1		; push status
001D54  1               
001D54  1  46 73 5F 4D   FHdr 'Fs_Make',0 ; ( fn_addr -- status )  Makes a new file, but does not open it
001D58  1  61 6B 65 07  
001D5C  1  1D 4F        
001D5E  1               Fs_Make:
001D5E  1  DC           	LDBA ZW			; get fn_addr
001D5F  1  79 01 1B     	JSRD $11B
001D62  1  73 34        	JMPR FsSt1		; store status
001D64  1               
001D64  1  46 73 5F 44   FHdr 'Fs_Delete',0 ; ( fn_addr -- status )  Deletes an existing file
001D68  1  65 6C 65 74  
001D6C  1  65 09 1D 5E  
001D70  1               Fs_Delete:
001D70  1  DC           	LDBA ZW			; get fn_addr
001D71  1  79 01 1E     	JSRD $11E
001D74  1  73 22        	JMPR FsSt1		; store status
001D76  1               
001D76  1  46 73 5F 4C   FHdr 'Fs_List',0 ; ( n_entry buf_addr -- status )  Lists a filename and size from the directory
001D7A  1  69 73 74 07  
001D7E  1  1D 70        
001D80  1               Fs_List:
001D80  1  D5 81        	LDBX ZW,ModBRPB,0	; pop buf_adddr
001D82  1  9C           	LDAA ZW			; get n_entry
001D83  1  79 01 21     	JSRD $121
001D86  1  73 10        	JMPR FsSt1		; store status
001D88  1               
001D88  1  46 73 5F 52   FHdr 'Fs_Read',0 ; ( buf_addr block -- status )  Reads a block from a file
001D8C  1  65 61 64 07  
001D90  1  1D 80        
001D92  1               Fs_Read:
001D92  1  95 81        	LDAX ZW,ModBRPB,0	; pop block
001D94  1  DC           	LDBA ZW			; get buf_addr
001D95  1  79 01 24     	JSRD $124
001D98  1  22 00        FsSt1:	CLRB AH			; store status
001D9A  1  BC           	STAA ZW
001D9B  1  09           	RSR
001D9C  1               
001D9C  1  46 73 5F 57   FHdr 'Fs_Write',0 ; ( buf_addr block -- status )  Writes a block to a file
001DA0  1  72 69 74 65  
001DA4  1  08 1D 92     
001DA7  1               Fs_Write:
001DA7  1  95 81        	LDAX ZW,ModBRPB,0	; pop block
001DA9  1  DC           	LDBA ZW			; get buf_addr
001DAA  1  79 01 27     	JSRD $127
001DAD  1  73 E9        	JMPR FsSt1
001DAF  1               
001DAF  1  47 65 6E 5F   FHdr 'Gen_HToL',0 ; ( ascii -- u )  Converts a hex number in ASCII into a value
001DB3  1  48 54 6F 4C  
001DB7  1  08 1D A7     
001DBA  1               Gen_HToL:
001DBA  1  DC           	LDBA ZW		; get ascii
001DBB  1  79 01 2A     	JSRD $12A
001DBE  1  73 D8        	JMPR FsSt1	; store u
001DC0  1               
001DC0  1               ;-----------------------------------------------------------------------------
001DC0  1               ; Assembler & disassembler
001DC0  1               
001DC0  1               
001DC0  1  53 79 6D 03   FHdr 'Sym',0 ; ( adr -- )  Type symbolic version of any adr
001DC4  1  1D BA        
001DC6  1  95 81        Sym:	LDAX ZW,ModBRPB,0
001DC8  1  B5 A2        SymA:	STAX SW,ModBMRB,0
001DCA  1  31 AB        	DCR SW,@adr		; alloc work area
001DCC  1               @adr	 = 12 ; adr to convert
001DCC  1               @voc	 = 10 ;	adr of vocabulary
001DCC  1               @cur	 =  8 ; adr of current word (nfa, cfa)
001DCC  1               @off	 =  6 ; offset this time
001DCC  1               @bestadr =  4 ; adr of best word (nfa, cfa)
001DCC  1               @bestoff =  2 ; offset from best word
001DCC  1               @type	 =  0 ; type of word
001DCC  1               
001DCC  1  90 FF FF     	LDAL .loword(-1)
001DCF  1  B5 A8 02     	STAX SW,ModNBRB,@bestoff
001DD2  1               
001DD2  1  91 70 72     	LDAD VVoc_Link		;for each vocabulary
001DD5  1  B5 A8 0A     @71:	STAX SW,ModNBRB,@voc
001DD8  1               
001DD8  1  95 08 FE     	LDAX AW,ModNBRB,$fe	;  for each word in the vocabulary
001DDB  1  B5 A8 08     @01:	STAX SW,ModNBRB,@cur
001DDE  1  14 25        	BZ @09
001DE0  1  5C           	XAY
001DE1  1               
001DE1  1  D5 A8 0C     	LDBX SW,ModNBRB,@adr	;    check current word
001DE4  1  55 60        	XFR AW,YW
001DE6  1  51 20        	SUB AW,BW
001DE8  1  D5 A8 02     	LDBX SW,ModNBRB,@bestoff
001DEB  1  59           	SAB
001DEC  1  10 0C        	BL @04
001DEE  1  B5 A8 02     	STAX SW,ModNBRB,@bestoff
001DF1  1  55 62        	XFR BW,YW
001DF3  1  F5 A8 04     	STBX SW,ModNBRB,@bestadr
001DF6  1  3A           	CLA
001DF7  1  B5 A8 00     	STAX SW,ModNBRB,@type
001DFA  1               @04:
001DFA  1               
001DFA  1               ;	LDABA YW		;  a special kind of word?
001DFA  1               ;	LDBBL $79		;    (jsrd)
001DFA  1               ;	SABB
001DFA  1               ;	BZ @21
001DFA  1               ;	LDBBL $90		;    (ldal)
001DFA  1               ;	SABB
001DFA  1               ;	BNZ @06
001DFA  1               
001DFA  1               ;	LDAX YW,ModNBRB,3	;  a literal?
001DFA  1               ;	HLT ;LDBL $??		;    STAX ZW,ModBMRB,0
001DFA  1               ;	BNZ @06
001DFA  1               ;	LDABX YW,ModNBRB,5
001DFA  1               ;	LDBBL $09		;    RSR
001DFA  1               ;	SABB
001DFA  1               ;	BNZ @06
001DFA  1               ; HLT ;??	lda @adr		;    check literal value
001DFA  1               ;	sec
001DFA  1               ;	sbc a:1,y
001DFA  1               ;	sec
001DFA  1               ;	bra @27
001DFA  1               
001DFA  1               ;@21:	rep #pm			;  a variable?
001DFA  1               ;	lda a:1,y
001DFA  1               ;	cmp #PCreate
001DFA  1               ;	bne @06
001DFA  1               ;	lda @adr
001DFA  1               ;	sec
001DFA  1               ;	sbc @cur
001DFA  1               ;	dec a
001DFA  1               ;	dec a
001DFA  1               ;	dec a
001DFA  1               
001DFA  1               ;@27:	cmp @bestoff
001DFA  1               ;	bcs @06
001DFA  1               ;	sta @bestoff
001DFA  1               ;	sty @bestadr
001DFA  1               ;	lda #$8000
001DFA  1               ;	sta @type
001DFA  1               
001DFA  1  95 68 FE     @06:	LDAX YW,ModNBRB,$fe	;  next word
001DFD  1  15 DC        	BNZ @01
001DFF  1  D5 A8 0A     	LDBX SW,ModNBRB,@voc	; next vocabulary
001E02  1  99           	LDAA BW
001E03  1  15 D0        	BNZ @71
001E05  1               @09:
001E05  1               ;-------------------
001E05  1  95 A8 02     	LDAX SW,ModNBRB,@bestoff
001E08  1  45 00        	XFRB AH,AH
001E0A  1  15 24        	BNZ @69
001E0C  1               
001E0C  1  79 13 8B     	JSRD PDotQuote
001E0F  1  03 20 7B 20  	.byte 3," { "
001E13  1               
001E13  1               ;	bit @type
001E13  1               ;	bpl @8
001E13  1               ;	JSRD DotQuoteR
001E13  1               ;	.byte 2,"' "
001E13  1               ;@8:
001E13  1  95 A8 04     	LDAX SW,ModNBRB,@bestadr ; type name
001E16  1  B5 82        	STAX ZW,ModBMRB,0
001E18  1  79 14 FB     	JSRD IdDot
001E1B  1               
001E1B  1  95 A8 02     	LDAX SW,ModNBRB,@bestoff
001E1E  1  14 0B        	BZ @7
001E20  1  80 2B        	LDABL '+'
001E22  1  79 0C 61     	JSRD EmitA
001E25  1  95 A8 02     	LDAX SW,ModNBRB,@bestoff
001E28  1  79 1C 61     	JSRD EX4A
001E2B  1               @7:
001E2B  1  79 13 8B     	JSRD PDotQuote
001E2E  1  01 7D        	.byte 1,"}"
001E30  1               @69:
001E30  1               
001E30  1  30 AD        	INR SW,@adr+2		; rdrop work area
001E32  1  09           	RSR
001E33  1               
001E33  1               
001E33  1               	.if 0
001E33  1               
001E33  1                FHdr "See",0 ; ( “(spaces)name” -- )	; https://forth-standard.org/standard/tools/SEE
001E33  1                  ; Display a disassembly of the named word’s definition.
001E33  1               See:	JSRD Tick
001E33  1               	JSRR DisAsm
001E33  1               	INR ZW,2
001E33  1               	RSR
001E33  1               
001E33  1               
001E33  1                FHdr "SeeLatest",0 ; ( -- ) ; disassemble latest word
001E33  1               SeeLatest:
001E33  1               	LDAI VCurrrent
001E33  1               	STAX ZW,ModBMRB,0
001E33  1               @1:	JSRD Disasm1
001E33  1               	LDAA ZW
001E33  1               	LDBD MPtr
001E33  1               	SAB
001E33  1               	BNL @1
001E33  1               	INR ZW,2
001E33  1               	JSRD CR
001E33  1               	JMPD CR
001E33  1               
001E33  1               
001E33  1                FHdr "DisAsm",0 ; ( adr -- adr )	Disasemble a run of code
001E33  1               DisAsm:	LDAL 100
001E33  1               @2:	STAX SW,ModBMRB,0	; Y=adr
001E33  1               	LDAA ZW
001E33  1               	XAY
001E33  1               	LDABA AW		; get opcode
001E33  1               	LDBBL $71		;  JMPD
001E33  1               	SABB
001E33  1               	BZ @jmp
001E33  1               	LDBBL $73		;  JMPR
001E33  1               	SAB
001E33  1               	BZ @4
001E33  1               	LDBBL $09		;  RSR
001E33  1               	SABB
001E33  1               	BZ @4
001E33  1               ;	LDBBL $79		;  JSRD
001E33  1               ;	SABB
001E33  1               ;	BNZ @5
001E33  1               ;	LDAX YW,ModNBRB,1
001E33  1               ;	LDBL FConsR
001E33  1               ;	SAB
001E33  1               ;	BZ @4
001E33  1               ;	jsr PushAddrQ
001E33  1               ;	bne @5
001E33  1               @4:	LDBBL 1
001E33  1               	STBA SW
001E33  1               @5:
001E33  1               	JSRD ADsm
001E33  1               ;	JSRD dsn
001E33  1               	LDAX SW,ModBRPB,0
001E33  1               	DCA
001E33  1               	BNZ @2
001E33  1               	JMPD CR
001E33  1               
001E33  1               @jmp:	LDAX YW,ModNBRB,$fe
001E33  1               	LDBL $fff0
001E33  1               	NAB
001E33  1               	LDABL $1003
001E33  1               	SAB
001E33  1               	BNZ @4
001E33  1               	JMPR @5
001E33  1               
001E33  1               ;---------------------------------------------------------------------------
001E33  1               
001E33  1                FHdr "Disasm1",0 ; ( addr-1 -- addr-2 )  Disassemble 1 CPU6 instruction
001E33  1                  ; Using self contained tables
001E33  1               Disasm1:
001E33  1               	JSRD CR			; new line
001E33  1               	JSRD PDotQuote		; tab over hex part
001E33  1               	.byte 2,9,9
001E33  1               	LDBA ZW			; save starting addr
001E33  1               	STBX SW,ModBMRB,0
001E33  1               
001E33  1               	JSRD @Fetch1		; fetch opcode
001E33  1               	SLA			; get @Code table entry
001E33  1               	LDBL @Code
001E33  1               	AAB
001E33  1               	LDBA BW
001E33  1               	STBX ZW,ModBMRB,0
001E33  1               
001E33  1               	CLA			;type opcode name
001E33  1               	XFR AL,BH
001E33  1               	LDBL @Mnemonics
001E33  1               	AAB
001E33  1               	JMPR @18
001E33  1               @11:	STBX SW,ModBMRB,0
001E33  1               	JSRD EmitA
001E33  1               	LDBX SW,ModBMRB,0
001E33  1               @18:	LDABX BW,ModBRPB,0
001E33  1               	BNZ @11
001E33  1               
001E33  1               	JSRD Space
001E33  1               
001E33  1               	LDAX ZW,ModNBRB,1	; get format entry from @Code entry
001E33  1               	CLRB AH
001E33  1               	LDBL @Formats
001E33  1               	AAB
001E33  1               @FmtN2:	CLA			; get next format char
001E33  1               	LDABX BW,ModBRPB,0
001E33  1               	BZ @Fmt99
001E33  1               	STBX ZW,ModBMRB,0
001E33  1               	LDBBL $20		; a function?
001E33  1               	SABB
001E33  1               	BNL @FEmit
001E33  1               
001E33  1               	LDBL @Formats		; call format routine
001E33  1               	AAB
001E33  1               	JSRX BW,ModBRB,0
001E33  1               @FmtN8:	LDBX ZW,ModBRPB,0	; get fmt ptr
001E33  1               	JMPR @FmtN2
001E33  1               
001E33  1               @FEmit:	JSRD EmitA
001E33  1               	JMPR @FmtN8
001E33  1               
001E33  1               @Fmt99:				; end of format string
001E33  1               
001E33  1               
001E33  1                HLT ;	??pla		;discard opcode
001E33  1               	JSRD PDotQuote	;to begin of line
001E33  1               	.byte 1,$0d
001E33  1               	LDAA ZW		;type addr
001E33  1               	JSRD EX4A
001E33  1               	JSRD Space
001E33  1                HLT ;???	pla
001E33  1               	ldy #5
001E33  1               @22:	phy
001E33  1               	pha
001E33  1               	tay
001E33  1               	lda a:0,y	;type bytes
001E33  1               	jsr EX2A
001E33  1               	pla
001E33  1               	ply
001E33  1               	dey
001E33  1               	beq @28
001E33  1               	ina
001E33  1               	cmp 0,x
001E33  1               	bcc @22
001E33  1               @28:	rts ; jmp CR
001E33  1               
001E33  1               
001E33  1               @Fetch1: ; fetch next byte
001E33  1               	LDBA SW
001E33  1               	CLA
001E33  1               	LDABX BW,ModBRPB,0
001E33  1               	STBA SW
001E33  1               	RSB
001E33  1               
001E33  1               @Fetch2: ; fetch next word
001E33  1               	LDBA SW
001E33  1               	LDAX BW,ModBRPB,0
001E33  1               	STBA SW
001E33  1               	RSB
001E33  1               
001E33  1               
001E33  1               @Formats:
001E33  1               	.dbyt 0,@Fmt1,@Fmt2,@Fmt3
001E33  1               	.dbyt @Fmt4,@Fmt5,@Fmt6,@Fmt7
001E33  1               	.dbyt @Fmt8,@Fmt9,@Fmt10,@Fmt11
001E33  1               	.dbyt @Fmt12,@Fmt13,@Fmt14
001E33  1               
001E33  1               @Fmt1: ; 1 byte literal
001E33  1               	JSRD @Fetch1		; fetch a byte
001E33  1               	JSRD EX2A
001E33  1               	JMPD @FmtNext
001E33  1               
001E33  1               @Fmt2: ; 2 byte literal
001E33  1               	JSRD @Fetch2		; fetch a word
001E33  1               	JSRD EX4A
001E33  1               	JMPD @FmtNext
001E33  1               
001E33  1               @Fmt3: ; 1byte relative
001E33  1               	JSRD @Fetch1		; fetch a signed byte
001E33  1               	XFRB AH,AL
001E33  1               	SRR AW,8
001E33  1               	AAB			; add to location
001E33  1               	JSRD EX4A
001E33  1               	JMPD @FmtNext
001E33  1               
001E33  1               @Fmt4: ; byte register
001E33  1               	JSRD @Fetch1		; fetch a byte
001E33  1               	STABX ZW,ModBMRB,0	; save a copy
001E33  1               	JSRR @RegB		; do dest reg
001E33  1               	LDABL ','
001E33  1               	JSRD EmitA
001E33  1               	LDAX ZW,ModBRPB,0	; do src reg
001E33  1               	SLL AW,4
001E33  1               	JSRD @RegB
001E33  1               	JMPD @FmtNext
001E33  1               
001E33  1               @RegR:	STABX SW,ModBMRB,0	; save
001E33  1               	SRA			; do register letter
001E33  1               	LDAL 7
001E33  1               	NAB
001E33  1               	LDAL @RegRA
001E33  1               	AAB
001E33  1               	LDAA BW
001E33  1               	JSRD EmitA
001E33  1               	LDABX SW,ModBMRB,0	; do register part
001E33  1               	RSR
001E33  1               
001E33  1               @RegRA:	.byte 'ABXYZSCP'
001E33  1               
001E33  1               @RegB:	JSRR @RegR
001E33  1               	SRA
001E33  1               	LDABL 'H'
001E33  1               	BNL @RegB3
001E33  1               	LDABL 'L'
001E33  1               @RegB3:	JMPD EmitA
001E33  1               
001E33  1               @Fmt5: ; word register & constant+1
001E33  1               	HLT ;???
001E33  1               
001E33  1               @Fmt6: ; word register & constant
001E33  1               	HLT ;???
001E33  1               
001E33  1               @Fmt7: ; dest byte registers
001E33  1               	HLT ;???
001E33  1               
001E33  1               @Fmt8: ; src byte register
001E33  1               	HLT ;???
001E33  1               
001E33  1               @Fmt9: ; dest word register
001E33  1               	HLT ;???
001E33  1               
001E33  1               @Fmt10: ; src word register
001E33  1               	HLT ;???
001E33  1               
001E33  1               @Fmt11: ; word indexed
001E33  1               	HLT ;???
001E33  1               
001E33  1               @Fmt12: ; byte indexed
001E33  1               	HLT ;???
001E33  1               
001E33  1               @Fmt13: ; register in opcode
001E33  1               	LDBA SW			; get opcode again
001E33  1               	CLA
001E33  1               	LDABX BW,ModBMRB,0
001E33  1               	SLA
001E33  1               	JSRD @RegR
001E33  1                HLT ;???
001E33  1               
001E33  1               
001E33  1               
001E33  1               ; https://github.com/Nakazoto/CenturionComputer/wiki/Instructions
001E33  1               
001E33  1               
001E33  1               ; Modifier	Note
001E33  1               ;  0 ; (r)	Index
001E33  1               ;  1 ; (r+)	Index; Index returned, incremented by ^
001E33  1               ;  2 ; (-r)	Decrement and Index
001E33  1               ;  4 ; @(r)	Index indirect
001E33  1               ;  5 ; @(r+)	Index indirect; Index returned, incremented by ^
001E33  1               ;  6 ; @(-r)	Decrement and index indirect
001E33  1               ;  8 ; n(r)	Index with displacement
001E33  1               ;  9 ; n(r+)	Index with displacement; Index returned, incremented by ^
001E33  1               ; $A ; n(-r)	Decrement and index with displacement
001E33  1               ; $C ; @n(r)	Index with displacement indirect
001E33  1               ; $D ; @n(r+)	Index with displacement indirect, Index returned, incremented by ^
001E33  1               ; $E ; @n(-r)	Decrement and index with displacement indirect
001E33  1               
001E33  1               @Inh:	.byte 0 ; inherent
001E33  1               @Rel:	.byte " ",3 ; 8bit relative
001E33  1               @RelInd: .byte " (",3,")",0 ; 8bit relative indirect
001E33  1               @BReg:	.byte " ",4,0 ; byte register
001E33  1               @WReg1:	.byte " ",5,0 ; word register & constant+1
001E33  1               @WReg:	.byte " ",6,0 ; word register & constant
001E33  1               @DRB:	.byte " ",7,",",8,0 ; src & dest byte registers
001E33  1               @DRW:	.byte " ",9,",",10,0 ; src & dest word registers (& extensions)
001E33  1               @LitW:	.byte " #",2,0 ; literal word
001E33  1               @LitB:	.byte " #",1,0 ; literal byte
001E33  1               @Direct: .byte " ",2,0 ; direct
001E33  1               @Indirect: .byte " (",2,")",0 ; indirect
001E33  1               @WX:	.byte " ",11,0 ; word indexed
001E33  1               @BX:	.byte " ",12,0 ; byte indexed
001E33  1               @A:	.byte " ",13,0 ; register in opcode
001E33  1               
001E33  1               
001E33  1               @Mnemonics:
001E33  1               @mIll:	.byte "??",0
001E33  1               @mHlt:	.byte "HLT",0
001E33  1               @mNop:	.byte "NOP",0
001E33  1               @mSF:	.byte "SF",0
001E33  1               @mRF:	.byte "RF",0
001E33  1               @mEI:	.byte "EI",0
001E33  1               @mDI:	.byte "DI",0
001E33  1               @mSL:	.byte "SL",0
001E33  1               @mRL:	.byte "RL",0
001E33  1               @mCL:	.byte "CL",0
001E33  1               @mRSR:	.byte "RSR",0
001E33  1               @mRI:	.byte "RI",0
001E33  1               @mRIM:	.byte "RIM",0
001E33  1               @mELO:	.byte "ELO",0
001E33  1               @mPCX:	.byte "PCX",0
001E33  1               @mDLY:	.byte "DLY",0
001E33  1               @mRSys:	.byte "RSYS",0
001E33  1               
001E33  1               @mBL:	.byte "BL",0
001E33  1               @mBNL:	.byte "BNL",0
001E33  1               @mBF:	.byte "BF",0
001E33  1               @mBNF:	.byte "BNF",0
001E33  1               @mBZ:	.byte "BZ",0
001E33  1               @mBNZ:	.byte "BNZ",0
001E33  1               @mBM:	.byte "BM",0
001E33  1               @mBF:	.byte "BF",0
001E33  1               @mBGZ:	.byte "BGZ",0
001E33  1               @mBLE:	.byte "BLE",0
001E33  1               @mBS1:	.byte "BS1",0
001E33  1               @mBS2:	.byte "BS2",0
001E33  1               @mBS3:	.byte "BS3",0
001E33  1               @mBS4:	.byte "BS4",0
001E33  1               @mBTM:	.byte "BTM",0
001E33  1               @mBEP:	.byte "BEP",0
001E33  1               
001E33  1               @mINRB:	.byte "INRB",0
001E33  1               @mDCRB:	.byte "DCRB",0
001E33  1               @mCLRB:	.byte "CLRB",0
001E33  1               @mIVRB:	.byte "IVRB",0
001E33  1               @mSRRB:	.byte "SRRB",0
001E33  1               @mSLRB:	.byte "SLRB",0
001E33  1               @mRRRB:	.byte "RRRB",0
001E33  1               @mRLRB:	.byte "RLRB",0
001E33  1               @mINAB:	.byte "INAB",0
001E33  1               @mDCAB:	.byte "DCAB",0
001E33  1               @mCLAB:	.byte "CLAB",0
001E33  1               @mIVAB:	.byte "IVAB",0
001E33  1               @mSRAB:	.byte "SRAB",0
001E33  1               @mSLAB:	.byte "SLAB",0
001E33  1               
001E33  1               @mINR:	.byte "INR",0
001E33  1               @mDCR:	.byte "DCR",0
001E33  1               @mCLR:	.byte "CLR",0
001E33  1               @mIVR:	.byte "IVR",0
001E33  1               @mSRR:	.byte "SRR",0
001E33  1               @mSLR:	.byte "SLR",0
001E33  1               @mRRR:	.byte "RRR",0
001E33  1               @mRLR:	.byte "RLR",0
001E33  1               @mINA:	.byte "INA",0
001E33  1               @mDCA:	.byte "DCA",0
001E33  1               @mCLA:	.byte "CLA",0
001E33  1               @mIVA:	.byte "IVA",0
001E33  1               @mSRA:	.byte "SRA",0
001E33  1               @mSLA:	.byte "SLA",0
001E33  1               @mINX:	.byte "INX",0
001E33  1               @mDCX:	.byte "DCX",0
001E33  1               
001E33  1               @mADDB:	.byte "ADDB",0
001E33  1               @mSUBB:	.byte "SUBB",0
001E33  1               @mANDB:	.byte "ANDB",0
001E33  1               @mORIB:	.byte "ORIB",0
001E33  1               @mOREB:	.byte "OREB",0
001E33  1               @mXFRB:	.byte "XFRB",0
001E33  1               @mAABB:	.byte "AABB",0
001E33  1               @mSABB:	.byte "SABB",0
001E33  1               @mNABB:	.byte "NABB",0
001E33  1               @mXAXB:	.byte "XAXB",0
001E33  1               @mXAYB:	.byte "XAYB",0
001E33  1               @mXABB:	.byte "XABB",0
001E33  1               @mXAZB:	.byte "XAZB",0
001E33  1               @mXASB:	.byte "XASB",0
001E33  1               
001E33  1               @mADD:	.byte "ADD",0
001E33  1               @mSUB:	.byte "SUB",0
001E33  1               @mAND:	.byte "AND",0
001E33  1               @mORI:	.byte "ORI",0
001E33  1               @mORE:	.byte "ORE",0
001E33  1               @mXFR:	.byte "XFR",0
001E33  1               @mAAB:	.byte "AAB",0
001E33  1               @mSAB:	.byte "SAB",0
001E33  1               @mNAB:	.byte "NAB",0
001E33  1               @mXAX:	.byte "XAX",0
001E33  1               @mXAY:	.byte "XAY",0
001E33  1               @mXAB:	.byte "XAB".0
001E33  1               @mXAZ:	.byte "XAZ",0
001E33  1               @mXAS:	.byte "XAS",0
001E33  1               
001E33  1               @mLDX:	.byte "LDX",0
001E33  1               @mSTX:	.byte "STX",0
001E33  1               @mJMP:	.byte "JMP",0
001E33  1               @mSYSCALL: .byte "SYSCALL",0
001E33  1               @mJSR:	.byte "JSR",0
001E33  1               
001E33  1               @mLDAB:	.byte "LDAB",0
001E33  1               @mLDA:	.byte "LDA",0
001E33  1               
001E33  1               @mSTAB:	.byte "STAB",0
001E33  1               @mSTA:	.byte "STA",0
001E33  1               
001E33  1               @mLDBB:	.byte "LDBB",0
001E33  1               @mLDB:	.byte "LDB",0
001E33  1               
001E33  1               @mSTBB:	.byte "STBB",0
001E33  1               @mSTB:	.byte "STB",0
001E33  1               
001E33  1               @mPUSH:	.byte "PUSH",0
001E33  1               @mPOP:	.byte "POP",0
001E33  1               
001E33  1               @mMUL:	.byte "MUL",0
001E33  1               @mDIV:	.byte "DIV",0
001E33  1               
001E33  1               
001E33  1                 .macro CodeE Mnem,Fmt
001E33  1               	.byte Mnem-@Mnem,Fmt
001E33  1               	.endmacro
001E33  1               
001E33  1               @Code: ; indexed by 1st opcode byte
001E33  1                 CodeE @mHlt,@Inh	;00
001E33  1                 CodeE @mNop,@Inh	;01
001E33  1                 CodeE @mSF,@Inh	;02
001E33  1                 CodeE @mRF,@Inh	;03
001E33  1                 CodeE @mEI,@Inh	;04
001E33  1                 CodeE @mDI,@Inh	;05
001E33  1                 CodeE @mSL,@Imh	;06
001E33  1                 CodeE @mRL,@Inh	;07
001E33  1                 CodeE @mCL,@Inh	;08
001E33  1                 CodeE @mRSR,@Inh	;09
001E33  1                 CodeE @mRI,@Inh	;0a
001E33  1                 CodeE @mRIM,@Inh	;0b
001E33  1                 CodeE @mELO,@Inh	;0c
001E33  1                 CodeE @mPCX,@Inh	;0d
001E33  1                 CodeE @mDLY,@Inh	;0e
001E33  1                 CodeE @mRSys,@Inh	;0f
001E33  1                 CodeE @mBL,@Rel	;10
001E33  1                 CodeE @mBNL,@Rel	;11
001E33  1                 CodeE @mBF,@Rel	;12
001E33  1                 CodeE @mBNF,@Rel	;13
001E33  1                 CodeE @mBZ,@Rel	;14
001E33  1                 CodeE @mBNZ,@Rel	;15 BNZ adr ; Branch if V (Z) flag clear
001E33  1                 CodeE @mBM,@Rel	;16 BM adr ; Branch if Minus flag set
001E33  1                 CodeE @mBF,@Rel	;17 BP adr ; Branch on Positive (Minus flag clear)
001E33  1                 CodeE @mBGZ,@Rel	;18 BGZ adr ; Branch if Greater Than 0 (!V && !Minus)
001E33  1                 CodeE @mBLE,@Rel	;19 BLE adr ; Branch if Less Than or Equal to 0 (V | Minus)
001E33  1                 CodeE @mBS1,@Rel	;1a BS1 adr ; Branch if Sense Switch 1 Set
001E33  1                 CodeE @mBS2,@Rel	;1b BS2 adr ; Branch if Sense Switch 2 Set
001E33  1                 CodeE @mBS3,@Rel	;1c BS3 adr ; Branch if Sense Switch 3 Set
001E33  1                 CodeE @mBS4,@Rel	;1d BS4 adr ; Branch if Sense Switch 4 Set
001E33  1                 CodeE @mBTM,@Rel	;1e BTM Rel ; Branch on TTY Mark (Changed for CPU6?)
001E33  1                 CodeE @mBEP,@Rel	;1f BEP Rel ; Branch on Even Parity (Changed for CPU6?)
001E33  1                 CodeE @mINRB,@BReg	;20 increment register upper byte or lower byte
001E33  1                 CodeE @mDCRB,@BReg	;21 decrement register upper byte or lower byte
001E33  1                 CodeE @mCLRB,@BReg	;22 clear register upper byte or lower byte
001E33  1                 CodeE @mIVRB,@BReg	;23 invert register byte
001E33  1                 CodeE @mSRRB,@BReg	;24 shift register byte right (sign extend)
001E33  1                 CodeE @mSLRB,@BReg	;25 shift register byte left (0 shifted in)
001E33  1                 CodeE @mRRRB,@BReg	;26 rotate register byte right (thru link flag)
001E33  1                 CodeE @mRLRB,@BReg	;27
001E33  1                 CodeE @mINAB,@Inh	;28 Increment AL register
001E33  1                 CodeE @mDCAB,@Inh	;29 Decrement AL register
001E33  1                 CodeE @mCLAB,@Inh	;2a Clear AL register
001E33  1                 CodeE @mIVAB,@Inh	;2b Invert AL register
001E33  1                 CodeE @mSRAB,@Inh	;2c Shift AL register right (sign extend)
001E33  1                 CodeE @mSLAB,@Inh	;2d Shift AL register left (0 shifted in)
001E33  1                 CodeE @mIll,@Inh	;2e Memory mapping
001E33  1                 CodeE @mIll,@Inh	;2f DMA
001E33  1                 CodeE @mINR,@WReg1	;30 increment register word
001E33  1                 CodeE @mDCR,@WReg1	;31 decrement register word
001E33  1                 CodeE @mCLR,@WReg	;32 clear register word
001E33  1                 CodeE @mIVR,@WReg	;33 invert register word
001E33  1                 CodeE @mSRR,@WReg1	;34 shift register right (sign extend)
001E33  1                 CodeE @mSLR,@WReg1	;35 shift register left (0 shifted in)
001E33  1                 CodeE @mRRR,@WReg1	;36 rotate register right (thru link flag)
001E33  1                 CodeE @mRLR,@WReg1	;37 rotate register left (thru link flag)
001E33  1                 CodeE @mINA,@Inh	;38 Increment AW register
001E33  1                 CodeE @mDCA,@Inh	;39 Decrement AW register
001E33  1                 CodeE @mCLA,@Inh	;3a Clear AW register
001E33  1                 CodeE @mIVA,@Inh	;3b Invert AW register
001E33  1                 CodeE @mSRA,@Inh	;3c Shift AW register right (sign extend)
001E33  1                 CodeE @mSLA,@Inh	;3d Shift AW register left (0 shifted in)
001E33  1                 CodeE @mINX,@Inh	;3e Increment XW register
001E33  1                 CoddE @mDCX,@Inh	;3f Decrement XW register
001E33  1                 CodeE @mADDB,@DRB	;40 DestReg,SrcReg ; Add byte Src to Dest
001E33  1                 CodeE @mSUBB,@DRB	;41 DestReg,SrcReg ; Subtract byte Src to Dest
001E33  1                 CodeE @mANDB,@DRB	;42 DestReg,SrcReg ; AND byte Src to Dest
001E33  1                 CodeE @mORIB,@DRB	;43 DestReg,SrcReg ; OR byte Src to Dest
001E33  1                 CodeE @mOREB,@DRB	;44 DestReg,SrcReg ; XOR byte Src to Dest
001E33  1                 CodeE @mXFRB,@DRB	;45 DestReg,SrcReg ; Copy byte of Src register into byte of Dest register
001E33  1                 CodeE @mIll,@Inh	;46
001E33  1                 CodeE @mIll,@Inh	;47
001E33  1                 CodeE @mAABB,@Inh	;48 BL+=AL
001E33  1                 CodeE @mSABB,@Inh	;49 BL=AL-BL
001E33  1                 CodeE.@mNABB,@Inh	;4a BL&=AL
001E33  1                 CodeE @mXAXB,@Inh	;4b XL=AL
001E33  1                 CodeE @mXAYB,@Inh	;4c YL=AL
001E33  1                 CodeE @mXABB,@Inh	;4d BL=AL
001E33  1                 CodeE @mXAZB,@Inh	;4e ZL=AL
001E33  1                 CodeE @mXASL,@Inh	;4f SL=AL
001E33  1                 CodeE @mADD,@DRW	;50 DestReg,SrcReg ; Add word Src to Dest
001E33  1                 CoddE @mSUB,@DRW	;51 DestReg,SrcReg ; Subtract byte Src to Dest
001E33  1                 CodeE @mANDC,@DRW	;52 DestReg,SrcReg ; AND word Src to Dest
001E33  1                 CodeE @mORI,@DRW	;53 DestReg,SrcReg ; OR word Src to Dest
001E33  1                 CodeE @mORE,@DRW	;54 DestReg,SrcReg ; XOR word Src to Dest
001E33  1                 CodeE @mXFR,@DRW	;55 DestReg,SrcReg ; Copy Src register into Dest register
001E33  1                 CodeE @mIll,@Inh	;56 ??
001E33  1                 CodeE @mIll,@Inh	;57 ??
001E33  1                 CodeE @mAAB,@Inh	;58 BW+=AW
001E33  1                 CodeE @mSAB,@Inh	;59 BW=AW-BW
001E33  1                 CodeE @mNAB,@Inh	;5a BW&=AW
001E33  1                 CodeE @mXAX,@Inh	;5b XW=AW
001E33  1                 CodeE @mXAY,@Inh	;5c YW=AW
001E33  1                 CodeE @mXAB,@Inh	;5d BW=AW
001E33  1                 CodeE @mXAZ,@Inh	;5e ZW=AW
001E33  1                 CodeE @mXAS,@Inh	;5f SW=AW
001E33  1                 CodeE @mLDX,@LitW	;60 Load immediate into XW
001E33  1                 CodeE @mLDX,@Direct	;61 Load direct address into XW
001E33  1                 CodeE @mLDX,@Indirect	;62 Load indirect address into XW
001E33  1                 CodeE @mLDX,@Rel	;63 Load direct Program Counter offset by N address into XW
001E33  1                 CodeE @mLDX,@RelInd	;64 Load indirect Program Counter offset by N address into XW
001E33  1                 CodeE @mLDX,@WX	;65 Load indexed mode register into XW
001E33  1                 CodeE @mIll,@Inh	;66 ??
001E33  1                 CodeE @mIll,@Inh	;67 ??
001E33  1                 CodeE @mSTX,@LitW	;68 Store XW into literal address (Not possible?)
001E33  1                 CoddE @mSTX,@Direct	;69 Store XW into direct address
001E33  1                 CodeE @mSTX,@Indirect	;6a Store XW into indirect address
001E33  1                 CodeE @mSTX,@Rel	;6b Store XW into direct Program Counter offset by N address
001E33  1                 CodeE @mSTX,@RelInd	;6c Store XW into indirect Program Counter offset by N address
001E33  1                 CodeE @mSTX,@WX	;6d Store XW into indexed register
001E33  1                 CodeE @mIll,@Inh	;6E ??
001E33  1                 CodeE @mIll,@Inh	;6F ??
001E33  1                 CodeE @mIll,@Inh	;70 ??
001E33  1                 CodeE @mJMP,@Direct	;71 Jump to direct address
001E33  1                 CodeE @mJMP,@Indirect	;72 Jump to indirect address
001E33  1                 CodeE @mJMP,@Rel	;73 Jump to direct Program Counter offset by N address
001E33  1                 CodeE @mJMP,@RelInd	;74 Jump to indirect Program Counter offset by N address
001E33  1                 CodeE @mJMP,@WX	;75 WReg,Mod,Offset ;Jump to indexed mode register
001E33  1                 CodeE @mSYSCALL,@Inh	;76 Call interrupt level 15
001E33  1                 CodeE @mMUL,@Inh	;77	multiply
001E33  1                 CodeE @mDIV,@Inh	;78	divide
001E33  1                 CodeE @mJSR,@Direct	,79
001E33  1                 CodeE @mJSR,@Indirect	;7a
001E33  1                 CodeE @mJSR,@Rel	;7b
001E33  1                 CodeE @mJSR,@RelInd	;7c
001E33  1                 CodeE @mJSR,@WX	;7d	WReg,Mod,Offset ; Jump to subroutine at indexed mode register
001E33  1                 CodeE @mPUSH,@Inh	;7e	RegCountM1
001E33  1                 CodeE @mPOP,@Inh	;7f	RegCountM1
001E33  1                 CodeE @mLDAB,@LitB	;80	Load literal address into AL register
001E33  1                 CodeE @mLDAB,@Direct	;81	Load direct address into AL register
001E33  1                 CodeE @mLDAB,@Indirect ;82	Load indirect address into AL register
001E33  1                 CodeE @mLDAB,@Rel	;83	Load direct Program Counter offset by N address into AL register
001E33  1                 CodeE @mLDAB,@RelInd	;84	Load indirect Program Counter offset by N address into byte of AL register
001E33  1                 CodeE @mLDAB,@BX	;85	WReg,Mod,Offset ; Load indexed register into byte of AL register
001E33  1                 CodeE @mIll,@Inh	;86	??
001E33  1                 CodeE @mIll,@Inh	;87	??
001E33  1                 CodeE @mLDAB,@A	;88	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDAB,@A	;89	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDAB,@A	;8a	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDAB,@A	;8b	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDAB,@A	;8c	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDAB,@A	;8d	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDAB,@A	;8e	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDAB,@A	;8f	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDA,@LitW	;90	Load literal address into full word of AW register
001E33  1                 CodeE @mLDA,@Direct	;91	Load direct address into full word of AW register
001E33  1                 CodeE @mLDA,@Indirect	;92	Load indirect address into full word of AW register
001E33  1                 CodeE @mLDA,@Rel	;93	Load direct Program Counter offset by N address into full word of AW register
001E33  1                 CodeE @mLDA,@RelInd	;94	Load indirect Program Counter offset by N address into full word of AW register
001E33  1                 CodeE @mLDA,@WX	;95	WReg,Mod,Offset ; Load indexed register into full word of AW register
001E33  1                 CodeE @mIll,@Inh	;96	??
001E33  1                 CodeE @mIll,@Inh	;97	??
001E33  1                 CodeE @mLDA,@A	;98	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDA,@A	;99	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDA,@A	;9a	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDA,@A	;9b	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDA,@A	;9c	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDA,@A	;9d	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDA,@A	;9e	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mLDA,@A	;9f	WReg ; Load byte from memory address stored in WReg into AL register
001E33  1                 CodeE @mSTAB,@LitB	;a0	Store byte of AL register into literal address (Not possible?)
001E33  1                 CodeE @mSTAB,@Direct	;a1	Store byte of AL register into direct address
001E33  1                 CodeE @mSTAB,@Indirect ;a2	Store byte of AL register into indirect address
001E33  1                 CodeE @mSTAB,@Rel	;a3	Store byte of AL register into direct Program Counter offset by N address
001E33  1                 CodeE @mSTAB,@RelInd	;a4	Store byte of AL register into indirect Program Counter offset by N address
001E33  1                 CodeE @mSTAB,@BX	;a5	WReg,Mod,Offset ; Store byte of AL register into indexed register
001E33  1                 CodeE @mIll,@Inh	;A6	??
001E33  1                 CodeE @mIll,@Inh	;A7	??
001E33  1                 CodeE @mSTAB,@A	;a8	Store AL register to memory address stored in WReg
001E33  1                 CodeE @mSTAB,@A	;a9	Store AL register to memory address stored in WReg
001E33  1                 CodeE @mSTAB,@A	;aa	Store AL register to memory address stored in WReg
001E33  1                 CodeE @mSTAB,@A	;ab	Store AL register to memory address stored in WReg
001E33  1                 CodeE @mSTAB,@A	;ac	Store AL register to memory address stored in WReg
001E33  1                 CodeE @mSTAB,@A	;ad	Store AL register to memory address stored in WReg
001E33  1                 CodeE @mSTAB,@A	;ae	Store AL register to memory address stored in WReg
001E33  1                 CodeE @mSTAB,@A	;af	Store AL register to memory address stored in WReg
001E33  1                 CodeE @mSTA,@LitW	;b0	Store word of AW register into literal address (Not possible?)
001E33  1                 CodeE @mSTA,@Direct	;b1	Store word of AW register into direct address
001E33  1                 CodeE @mSTA,@Indirect	;b2	Store word of AW register into indirect address
001E33  1                 CodeE @mSTA,@Rel	;b3	Store word of AW register into direct Program Counter offset by N address
001E33  1                 CodeE @mSTA,@RelInd	;b4	Store word of AW register into indirect Program Counter offset by N address
001E33  1                 CodeE @mSTA,@WX	;b5	WReg,Mod,Offset ; Store word of AW register into indexed register
001E33  1                 CodeE @mIll,@Inh	;b6	??
001E33  1                 CodeE @mIll,@Inh	;b7	??
001E33  1                 CodeE @mSTA,@A	;b8	WReg ; Store AW register to memory address stored in WReg
001E33  1                 CodeE @mSTA,@A	;b9	WReg ; Store AW register to memory address stored in WReg
001E33  1                 CodeE @mSTA,@A	;ba	WReg ; Store AW register to memory address stored in WReg
001E33  1                 CodeE @mSTA,@A	;bb	WReg ; Store AW register to memory address stored in WReg
001E33  1                 CodeE @mSTA,@A	;bc	WReg ; Store AW register to memory address stored in WReg
001E33  1                 CodeE @mSTA,@A	;bd	WReg ; Store AW register to memory address stored in WReg
001E33  1                 CodeE @mSTA,@A	;be	WReg ; Store AW register to memory address stored in WReg
001E33  1                 CodeE @mSTA,@A	;bf	WReg ; Store AW register to memory address stored in WReg
001E33  1                 CodeE @mLDBB,@LitB	;c0	Load literal address into BL register
001E33  1                 CodeE @mLDBB,@Direct	;c1	Load direct address into BL register
001E33  1                 CodeE @mLDBB,@Indirect ;c2	Load indirect address into BL register
001E33  1                 CodeE @mLDBB,@Rel	;c3	Load direct Program Counter offset by N address into BL register
001E33  1                 CodeE @mLDBB,@RelInd	;c4	Load indirect Program Counter offset by N address into BL register
001E33  1                 CodeE @mLDBB,@BX	;c5	WReg,Mod,Offset ; Load indexed register into BL register
001E33  1                 CodeE @mIll,@Inh	;C6	??
001E33  1                 CodeE @mIll,@Inh	;C7	??
001E33  1                 CodeE @mLDBB,@A	;c8	Load byte from memory address stored in WReg into BL register
001E33  1                 CodeE @mLDBB,@A	;c9	Load byte from memory address stored in WReg into BL register
001E33  1                 CodeE @mLDBB,@A	;ca	Load byte from memory address stored in WReg into BL register
001E33  1                 CodeE @mLDBB,@A	;cb	Load byte from memory address stored in WReg into BL register
001E33  1                 CodeE @mLDBB,@A	;cc	Load byte from memory address stored in WReg into BL register
001E33  1                 CodeE @mLDBB,@A	;cd	Load byte from memory address stored in WReg into BL register
001E33  1                 CodeE @mLDBB,@A	;ce	Load byte from memory address stored in WReg into BL register
001E33  1                 CodeE @mLDBB,@A	;cf	Load byte from memory address stored in WReg into BL register
001E33  1                 CodeE @mLDB,@LitW	;d0	Load literal address into BW register
001E33  1                 CodeE @mLDB,@Direct	;d1	Load direct address into BW register
001E33  1                 CodeE @mLDB,@Indirect	;d2	Load indirect address into BW register
001E33  1                 CodeE @mLDB,@Rel	;d3	Load direct Program Counter offset by N address into BW register
001E33  1                 CodeE @mLDB,@RelInd	;d4	Load indirect Program Counter offset by N address into BW register
001E33  1                 CodeE @mLDB,@WX	;d5	WReg,Mod,Offset ; Load indexed register into BW register
001E33  1                 CodeE @mIll,@Inh	;D6	??
001E33  1                 CodeE @mIll,@Inh	;D7	??
001E33  1                 CodeE @mLDB,@A	;d8	Load word from memory address stored in WReg into BW register
001E33  1                 CodeE @mLDB,@A	;d9	Load word from memory address stored in WReg into BW register
001E33  1                 CodeE @mLDB,@A	;da	Load word from memory address stored in WReg into BW register
001E33  1                 CodeE @mLDB,@A	;db	Load word from memory address stored in WReg into BW register
001E33  1                 CodeE @mLDB,@A	;dc	Load word from memory address stored in WReg into BW register
001E33  1                 CodeE @mLDB,@A	;dd	Load word from memory address stored in WReg into BW register
001E33  1                 CodeE @mLDB,@A	;de	Load word from memory address stored in WReg into BW register
001E33  1                 CodeE @mLDB,@A	;df	Load word from memory address stored in WReg into BW register
001E33  1                 CodeE @mSTBB,@LitB	;e0	Store byte of BL register into literal address (Not possible?)
001E33  1                 CodeE @mSTBB,@Direct	;e1	Store BL into direct address
001E33  1                 CodeE @mSTBB,@Indirect ;e2	Store BL into indirect address
001E33  1                 CodeE @mSTBB,@Rel	;e3	Store BL into direct Program Counter offset by N address
001E33  1                 CodeE @mSTBB,@RelInd	;e4	Store BL into indirect Program Counter offset by N address
001E33  1                 CodeE @mSTBB,@BX	;e5	WReg,Mod,Offset ; Store BL into indexed register
001E33  1                 CodeE @mIll,@Inh	;E6	??
001E33  1                 CodeE @mIll,@Inh	;E7	??
001E33  1                 CodeE @mSTBB,@A	;e8	Store byte from BL register to memory address stored in WReg
001E33  1                 CodeE @mSTBB,@A	;e9	Store byte from BL register to memory address stored in WReg
001E33  1                 CodeE @mSTBB,@A	;ea	Store byte from BL register to memory address stored in WReg
001E33  1                 CodeE @mSTBB,@A	;eb	Store byte from BL register to memory address stored in WReg
001E33  1                 CodeE @mSTBB,@A	;ec	Store byte from BL register to memory address stored in WReg
001E33  1                 CodeE @mSTBB,@A	;ed	Store byte from BL register to memory address stored in WReg
001E33  1                 CodeE @mSTBB,@A	;ee	Store byte from BL register to memory address stored in WReg
001E33  1                 CodeE @mSTBB,@A	;ef	Store byte from BL register to memory address stored in WReg
001E33  1                 CodeE @mSTB,@LitW	;f0	Store BW into literal address (Not possible?)
001E33  1                 CodeE @mSTB,@Direct	;f1	Store BW into direct address
001E33  1                 CodeE @mSTB,@Indirect	;f2	Store BW into indirect address
001E33  1                 CodeE @mSTB,@Rel	;f3	Store BW into direct Program Counter offset by N address
001E33  1                 CodeE @mSTB,@RelInd	;f4	Store BW into indirect Program Counter offset by N address
001E33  1                 CodeE @mSTB,@WX	;f5	WReg,Mod,Offset ; Store BW into indexed register
001E33  1                 CodeE @mIll,@Inh	;f6	??
001E33  1                 CodeE @mIll,@Inh	;f7	??
001E33  1                 CodeE @mSTB,@A	;f8	Store BW to memory address stored in WReg
001E33  1                 CodeE @mSTB,@A	;f9	Store BW to memory address stored in WReg
001E33  1                 CodeE @mSTB,@A	;fa	Store BW to memory address stored in WReg
001E33  1                 CodeE @mSTB,@A	;fb	Store BW to memory address stored in WReg
001E33  1                 CodeE @mSTB,@A	;fc	Store BW to memory address stored in WReg
001E33  1                 CodeE @mSTB,@A	;fd	Store BW to memory address stored in WReg
001E33  1                 CodeE @mSTB,@A	;fe	Store BW to memory address stored in WReg
001E33  1                 CodeE @mSTB,@A	;ff	Store BW to memory address stored in WReg
001E33  1               
001E33  1               
001E33  1               
001E33  1               ;---------------------------------------
001E33  1               
001E33  1               RegNames: .byte "AABBXXYYZZSSCCPP"
001E33  1               ; AW = $0
001E33  1               ; AH = $0
001E33  1               ; AL = $1
001E33  1                FHdr 'AW',0 ; ( -- n )  word register
001E33  1               	LDABL 0
001E33  1               	JMPR PushA4
001E33  1                FHdr 'AH',0 ; ( -- n )  byte register
001E33  1               	LDABL 0
001E33  1               	JMPR PushA4
001E33  1                FHdr 'AL',0 ; ( -- n )  byte register
001E33  1               	LDABL 1
001E33  1               	JMPR PushA4
001E33  1               
001E33  1                FHdr 'BW',0 ; ( -- n )  word register
001E33  1               	LDABL 2
001E33  1               	JMPR PushA4
001E33  1                FHdr 'BH',0 ; ( -- n )  byte register
001E33  1               	LDABL 2
001E33  1               	JMPR PushA4
001E33  1                FHdr 'BL',0 ; ( -- n )  byte register
001E33  1               	LDABL 3
001E33  1               	JMPR PushA4
001E33  1               
001E33  1                FHdr 'XW',0 ; ( -- n )  word register
001E33  1               	LDABL 4
001E33  1               	JMPR PushA4
001E33  1                FHdr 'XH',0 ; ( -- n )  byte register
001E33  1               	LDABL 4
001E33  1               	JMPR PushA4
001E33  1                FHdr 'XL',0 ; ( -- n )  byte register
001E33  1               	LDABL 5
001E33  1               ;	JMPR PushA4
001E33  1               
001E33  1               PushA4:	LDBBL 0
001E33  1               	XFR AH,BL
001E33  1               	STAX ZW,ModBMRB,0
001E33  1               	RSR
001E33  1               
001E33  1                FHdr 'YW',0 ; ( -- n )  word register
001E33  1               	LDABL 6
001E33  1               	JMPR PushA4
001E33  1                FHdr 'YH',0 ; ( -- n )  byte register
001E33  1               	LDABL 6
001E33  1               	JMPR PushA4
001E33  1                FHdr 'YL',0 ; ( -- n )  byte register
001E33  1               	LDABL 7
001E33  1               	JMPR PushA4
001E33  1               
001E33  1                FHdr 'ZW',0 ; ( -- n )  word register
001E33  1               	LDABL 8
001E33  1               	JMPR PushA4
001E33  1                FHdr 'ZH',0 ; ( -- n )  byte register
001E33  1               	LDABL 8
001E33  1               	JMPR PushA4
001E33  1                FHdr 'ZL',0 ; ( -- n )  byte register
001E33  1               	LDABL 9
001E33  1               	JMPR PushA4
001E33  1               
001E33  1                FHdr 'SW',0 ; ( -- n )  word register
001E33  1               	LDABL 10
001E33  1               	JMPR PushA4
001E33  1               
001E33  1                FHdr 'CW',0 ; ( -- n )  word register
001E33  1               	LDABL 12
001E33  1               	JMPR PushA4
001E33  1               
001E33  1                FHdr 'PW',0 ; ( -- n )  word register
001E33  1               	LDABL 14
001E33  1               	JMPR PushA4
001E33  1               
001E33  1               
001E33  1               ; Addressing Modes
001E33  1               ; Instructions can be either 1-byte, 2-byte or 3-byte depending on the type of instruction.
001E33  1               ; The second or third byte (if present) are related to addressing, or directing the instruction as to which location in memory to act upon.
001E33  1               ; Addressing can be either implicit or explicit.
001E33  1               ; Implicit means that no addressing is specified, and that specific instruction operates on only one specific location.
001E33  1               ; Explicit means the programmer must state which location they will perform the operation on.
001E33  1               
001E33  1               ; In the chart below, the addressing mode and what is expected at each nibble of each operation is shown.
001E33  1               
001E33  1               ; HB = High Byte; MB = Mid Byte; LB = Low Byte
001E33  1               
001E33  1               ; HN = High Nibble; LN = Low Nibble
001E33  1               
001E33  1               ; HB_HN      	HB_LN      	MB_HN  	MB_LN  	LB_HN  	LB_LN  	Note
001E33  1               ; 0	Op (0-F)					Control Operations
001E33  1               ; 1	Op (0-F)	Displace	Displace			Branch Operations
001E33  1               ; 2	Op (0-7)	Source Reg.				Single Register Explicit Byte Operation
001E33  1               ; 2	Op (8-F)					Single Register Implicit Byte Operation
001E33  1               ; 3	Op (0-7)	Source Reg.				Single Register Explicit Word Operation
001E33  1               ; 3	Op (8-F)					Single Register Implicit Word Operation
001E33  1               ; 4	Op (0-7)	Source Reg.	Dest. Reg.			Double Register Explicit Byte Operation
001E33  1               ; 4	Op (8-F)					Double Register Implicit Byte Operation
001E33  1               ; 5	Op (0-7)	Source Reg.	Dest. Reg.			Double Register Explicit Word Operation
001E33  1               ; 5	Op (8-F)					Double Register Implicit Word Operation
001E33  1               ; Op (6-F)	0	Literal	Literal			Literal Memory Address Byte Operation
001E33  1               ; Op (6-F)	0	Literal	Literal	Literal	Literal	Literal Memory Address Word Operation
001E33  1               ; Op (6-F)	1	Direct	Direct	Direct	Direct	Direct Memory Address Operation
001E33  1               ; Op (6-F)	2	Indirect	Indirect	Indirect	Indirect	Indirect Memory Address Operation
001E33  1               ; Op (6-F)	3	Displace	Displace			Relative to Current Location Memory Address Operation
001E33  1               ; Op (6-F)	4	Displace	Displace			Indirect Relative to Current Location Memory Address Operation
001E33  1               ; Op (6-F)	5	Register	Modifier	Displace	Displace	Indexed Addressing (Modifier Table Below)
001E33  1               ; Op (6-F)	8-F					Implicit Indexing (8 - F => A - P Reg.)
001E33  1               
001E33  1               AMode:	.res 1
001E33  1               
001E33  1               AModeSet: ; remember indexed addr mode for next instruction
001E33  1               	; AL=mode
001E33  1               	LDBBD AMode
001E33  1               	BP @AlreadySet
001E33  1               	STABD AMode
001E33  1               	RSB
001E33  1               
001E33  1               @AlreadySet:
001E33  1               	JSRD PDotQuote
001E33  1               	.byte 16,"Mode already set"
001E33  1               	JMPD Abort
001E33  1               
001E33  1                FHdr "(r)",0 ; Index
001E33  1               	LDABL 0
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "(r+)",0 ; Index returned, incremented by ^
001E33  1               	LDABL 1
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "(-r)",0 ; Decrement and Index
001E33  1               	LDABL 2
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "@(r)",0 ; indirect
001E33  1               	LDABL 4
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "@(r+)",0 ; Index returned, incremented by ^
001E33  1               	LDABL 5
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "@(-r)",0 ; Decrement and index indirect
001E33  1               	LDABL 6
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "n(r)",0 ; Index with displacement
001E33  1               	LDABL 8
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "n(r+)",0 ; Index with displacement; Index returned, incremented by ^
001E33  1               	LDABL 9
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "n(-r)",0 ; Decrement and index with displacement
001E33  1               	LDABL $a
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "@n(r)",0 ; Index with displacement indirect
001E33  1               	LDABL $c
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "@n(r+)",0 ; Index with displacement indirect, Index returned, incremented by ^
001E33  1               	LDABL $d
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                FHdr "@n(-r)",0 ; Decrement and index with displacement indirect
001E33  1               	LDABL $e
001E33  1               	JMPR AModeSet
001E33  1               
001E33  1                 .macro ModBytes WReg,Mod,Offset
001E33  1               	.if (WReg&$fff1)<>0
001E33  1               	  .error "WReg must be a word register"
001E33  1               	 .endif
001E33  1               	.if (Mod=ModBRB) | (Mod=ModBRPB) | (Mod=ModBMRB) | (Mod=ModABRB) | (Mod=ModABRPB) | (Mod=ModABMRB)
001E33  1               	  .byte (WReg<<4)|Mod
001E33  1               	 .else
001E33  1               	  .if (Mod=ModNBRB) | (Mod=ModNBRPB) | (Mod=ModNBMRB) | (Mod=ModANBRB) | (Mod=ModANBRPB) | (Mod=ModANBMRB)
001E33  1               	    .byte (WReg<<4)|Mod,Offset ; is offset signed or unsigned???
001E33  1                          .else
001E33  1               	    .error "Unknown Mod"
001E33  1               	   .endif
001E33  1               	 .endif
001E33  1               	.endmacro
001E33  1               
001E33  1               
001E33  1               	.dbyt D_Inherent ; disassembly routine
001E33  1               A_Inherent:
001E33  1               	LDABA XW		; get opcode
001E33  1               	JSRD CCommaA
001E33  1               	LDXX SW,ModBRPB,0	; pop X
001E33  1               	RSB
001E33  1               
001E33  1               
001E33  1                FHdr "HLT,",0 ; Wait for Interrupt (Halt)
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $00
001E33  1               
001E33  1                FHdr "NOP,",0 ; No Operation
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $01
001E33  1               
001E33  1                FHdr "SF,",0 ; Set Fault flag
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $02
001E33  1               
001E33  1                FHdr "RF,",0 ; Reset Fault flag
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $03
001E33  1               
001E33  1                FHdr "EI,",0 ; Enable the Interrupt System (allow interrupts)
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $04
001E33  1               
001E33  1                FHdr "DI,",0 ; Disable the Interrupt System (disable interrupts)
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $05
001E33  1               
001E33  1                FHdr "SL,",0 ; Set the Link (carry) Flag
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $06
001E33  1               
001E33  1                FHdr "RL,",0 ; Reset the Link (carry) Flag
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $07
001E33  1               
001E33  1                FHdr "CL,",0 ; Complement Link flag
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $08
001E33  1               
001E33  1                FHdr "RSR,",0 ; Return from subroutine
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $09
001E33  1               
001E33  1                FHdr "RI,",0 ; Return from interrupt
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $0A
001E33  1               
001E33  1                FHdr "RIM,",0 ; Return from Interrupt Modified
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $0B
001E33  1               
001E33  1                FHdr "ELO,",0 ; Enable Link Out - teletype_tx=Link
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $0C
001E33  1               
001E33  1                FHdr "PCX,",0 ; Transfer PC to X - X=address of next instruction
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $0D
001E33  1               
001E33  1                FHdr "DLY,",0 ; Delay 4.55 ms - for TTY bit timing
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $0E
001E33  1               
001E33  1                FHdr 'RSYS,',0 ; Return from Syscall
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $0F
001E33  1               
001E33  1               	.dbyt D_Relative ; disassembly routine
001E33  1               A_Relative: ; ( adr -- ) do instruction with relative addressing
001E33  1               	LDABA XW		; get opcode
001E33  1               	JSRD CCommaA		; store opcode
001E33  1               	INR BW
001E33  1               	LDAAX ZW,ModBRPB,0	; pop adr
001E33  1               	SUB AW,BW		; calc displacement
001E33  1               	LDBL $80		; < $80
001E33  1               	SAB
001E33  1               	BL @OK
001E33  1               	LDBL $FF80		; > $FF80
001E33  1               	SAB
001E33  1               	BNL @Err
001E33  1               @OK:	JMPD CCommAA
001E33  1               
001E33  1               @Err:	LDBL ERR_OutOfRange	; error
001E33  1               	JSRD ErrorY
001E33  1               
001E33  1               
001E33  1                FHdr "BL,",0  ; ( adr -- ) Branch if Link (Carry) Set
001E33  1               	JSRD A_Relative
001E33  1               	.byte $10
001E33  1               
001E33  1                FHdr "BNL,",0 ; ( adr -- ) Branch if Link (Carry) not Set
001E33  1               	JSRD A_Relative
001E33  1               	.byte $11
001E33  1               
001E33  1                FHdr "BF,",0 ; ( adr -- ) Branch if Fault Set
001E33  1               	JSRD A_Relative
001E33  1               	.byte $12
001E33  1               
001E33  1                FHdr "BNF,",0 ; ( adr -- ) Branch if Fault not Set
001E33  1               	JSRD A_Relative
001E33  1               	.byte $13
001E33  1               
001E33  1                FHdr "BZ,",0 ; ( adr -- ) Branch if V (Z) flag set
001E33  1               	JSRD A_Relative
001E33  1               	.byte $14
001E33  1               
001E33  1                FHdr "BNZ,",0 ; ( adr -- ) Branch if V (Z) flag clear
001E33  1               	JSRD A_Relative
001E33  1               	.byte $15
001E33  1               
001E33  1                FHdr "BM,",0 ; ( adr -- ) Branch if Minus flag set
001E33  1               	JSRD A_Relative
001E33  1               	.byte $16
001E33  1               
001E33  1                FHdr "BP,",0 ; ( adr -- ) Branch on Positive (Minus flag clear)
001E33  1               	JSRD A_Relative
001E33  1               	.byte $17
001E33  1               
001E33  1                FHdr "BGZ,",0 ; ( adr -- ) Branch if Greater Than 0 (!V && !Minus)
001E33  1               	JSRD A_Relative
001E33  1               	.byte $18
001E33  1               
001E33  1                FHdr "BLE,",0 ; ( adr -- ) Branch if Less Than or Equal to 0 (V | Minus)
001E33  1               	JSRD A_Relative
001E33  1               	.byte $19
001E33  1               
001E33  1                FHdr "BS1,",0 ; ( adr -- ) Branch if Sense Switch 1 Set
001E33  1               	JSRD A_Relative
001E33  1               	.byte $1a
001E33  1               
001E33  1                FHdr "BS2,",0 ; ( adr -- ) Branch if Sense Switch 2 Set
001E33  1               	JSRD A_Relative
001E33  1               	.byte $1b
001E33  1               
001E33  1                FHdr "BS3,",0 ; ( adr -- ) Branch if Sense Switch 3 Set
001E33  1               	JSRD A_Relative
001E33  1               	.byte $1c
001E33  1               
001E33  1                FHdr "BS4,",0 ; ( adr -- ) Branch if Sense Switch 4 Set
001E33  1               	JSRD A_Relative
001E33  1               	.byte $1d
001E33  1               
001E33  1               ; FHdr "BTM",0 ; ( adr -- ) Branch on TTY Mark (Changed for CPU6?)
001E33  1               ;	JSRD A_Relative
001E33  1               ;	.byte $1e
001E33  1               
001E33  1                FHdr "RSYS,",0 ; ( adr -- ) Branch on Even Parity (Changed for CPU6?)
001E33  1               	JSRD A_Relative
001E33  1               	.byte $1f
001E33  1               
001E33  1               
001E33  1               	.dbyt Abort ;???  ; disassembly routine
001E33  1               A_RegW: ; ( Reg -- )
001E33  1               	LDABA XW		; get opcode
001E33  1               	JSRD CCommaA
001E33  1               	LDAX ZW,ModBRPB,0	; get Reg
001E33  1               	; test for valid word register?
001E33  1               	SLA
001E33  1               	SLA
001E33  1               	SLA
001E33  1               	SLA
001E33  1               	JMPD CCommaA
001E33  1               
001E33  1               	.dbyt Abort ;???  ; disassembly routine
001E33  1               A_RegB:	JMPR A_RegW
001E33  1               
001E33  1                FHdr "INR,",0 ; ( n WReg -- ) increment register word
001E33  1               	JSRD RegWV
001E33  1               	.byte $30
001E33  1               
001E33  1                FHdr "INRB,",0 ; ( BReg -- ) increment byte register
001E33  1               	JSRD RegB
001E33  1               	.byte $20
001E33  1               
001E33  1                FHdr "INAB,",0 ; ( -- ) Increment AL register
001E33  1               	JSR M_Inherent
001E33  1               	.byte $28
001E33  1               
001E33  1                FHdr "INA,",0 ; ( -- ) Increment AW register
001E33  1               	JSR M_Inherent
001E33  1               	.byte $38
001E33  1               
001E33  1                FHdr "DCR,",0 ; ( n WReg -- ) decrement register word
001E33  1               	JSR RegWV
001E33  1               	.byte $31
001E33  1               
001E33  1                FHdr "DCRB,",0 ; ( BReg -- ) decrement byte register
001E33  1               	JSRD RegB
001E33  1               	.byte $21
001E33  1               
001E33  1                FHdr "DCAB,",0 ; ( -- ) Decrement AL register
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $29
001E33  1               
001E33  1                FHdr "DCA,",0 ; ( -- ) Decrement AW register
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $39
001E33  1               
001E33  1                FHdr "CLR,",0 ; ( n WReg -- ) clear register word
001E33  1               	JSRD RegWV
001E33  1               	.byte $32
001E33  1               
001E33  1                FHdr "CLRB,",0 ; ( BReg -- ) clear byte register
001E33  1               	JSRD RegB
001E33  1               	.byte $22
001E33  1               
001E33  1                FHdr "CLAB,",0 ; ( -- ) Clear AL register
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $2A
001E33  1               
001E33  1                FHdr "CLA,",0 ; ( -- ) Clear AW register
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $3A
001E33  1               
001E33  1                FHdr "IVR,",0 ( n WReg -- ) invert register word
001E33  1               	JSRD RegWV
001E33  1               	.byte $33
001E33  1               
001E33  1                FHdr "IVRB,",0 ( BReg -- ) invert register byte
001E33  1               	JSRD RegB
001E33  1               	.byte $23
001E33  1               
001E33  1                FHdr "IVAB,",0 ; ( -- ) Invert AL register
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $2B
001E33  1               
001E33  1                FHdr "IVA,",0 ; ( -- ) Invert AW register
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $3B
001E33  1               
001E33  1                FHdr "SRR,",0 ; ( n WReg -- ) shift register right (sign extend)
001E33  1               	JSRD RegWVp1
001E33  1               	.byte $34
001E33  1               
001E33  1                FHdr "SRRB,",0 ; ( BReg -- ) shift register byte right (sign extend)
001E33  1               	JSRD RegB
001E33  1               	.byte $24
001E33  1               
001E33  1                FHdr "SRAB,",0 ; ( -- ) Shift AL register right (sign extend)
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $2C
001E33  1               
001E33  1                FHdr "SRA,",0 ; ( -- ) Shift AW register right (sign extend)
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $3C
001E33  1               
001E33  1                FHdr "SLR,",0 ; ( n WReg -- ) shift register left (0 shifted in)
001E33  1               	JSRD RegWVp1
001E33  1               	.byte $35
001E33  1               
001E33  1                FHdr "SLRB,",0 ; ( BReg -- ) shift register byte left (0 shifted in)
001E33  1               	JSRD RegBW
001E33  1               	.byte $25
001E33  1               
001E33  1                FHdr "SLAB,",0 ; ( -- ) Shift AL register left (0 shifted in)
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $2D
001E33  1               
001E33  1                FHdr "SLA,",0 ; ( -- ) Shift AW register left (0 shifted in)
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $3D
001E33  1               
001E33  1                FHdr "RRR,",0 ; ( n WReg -- ) rotate register right (thru link flag)
001E33  1               	JSRD RegWVp1
001E33  1               	.byte $36
001E33  1               
001E33  1                FHdr "RRRB,",0 ; ( BReg -- ) rotate register byte right (thru link flag)
001E33  1               	JSRD RegB
001E33  1               	.byte $26
001E33  1               
001E33  1                FHdr "RLR,",0 ; ( n WReg -- ) rotate register left (thru link flag)
001E33  1               	JSRD RegWVp1
001E33  1               	.byte $37
001E33  1               
001E33  1                FHdr "RLRB,",0 ; ( BReg -- )
001E33  1               	JSRD RegBW
001E33  1               	.byte $27
001E33  1               
001E33  1               ;  .macro ??
001E33  1               ;	.byte $2E ; Memory mapping?
001E33  1               ;	.endmacro
001E33  1               ;  .macro ??
001E33  1               ;	.byte $2F ; DMA?
001E33  1               ;	.endmacro
001E33  1               
001E33  1                FHdr "INX,",0 ; ( -- ) Increment XW register
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $3E
001E33  1               
001E33  1                FHdr "DCX,",0 ; ( -- ) Decrement XW register
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $3F
001E33  1               
001E33  1               
001E33  1               A_RegReg: ; ( DestReg SrcReg -- ) 2 registers
001E33  1               	LDAX ZW,ModBRPB,0	; pop SrcReg
001E33  1               	SLA
001E33  1               	SLA
001E33  1               	SLA
001E33  1               	SLA
001E33  1               	LDBX ZW,ModBRPB,0	; pop DestReg
001E33  1               	ORI BL,AL
001E33  1               	JMPD CCommaA	; ((SrcReg&$f)<<4)+(DestReg&$f)
001E33  1               
001E33  1                FHdr "ADD,",0 ; ( DestReg SrcReg -- ) Add word Src to Dest
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $50
001E33  1                FHdr "ADDB,",0 ; ( DestReg SrcReg -- ) Add byte Src to Dest
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $40
001E33  1                FHdr "AABB,",0 ; ( -- ) BL+=AL
001E33  1               	JSRD A__Inherent
001E33  1               	.byte $48
001E33  1                FHdr "AAB",,0 ; ( -- ) BW+=AW
001E33  1               	JSRD A__Inherent
001E33  1               	.byte $58
001E33  1               
001E33  1                FHdr "SUB,",0 ; ( DestReg SrcReg -- ) Subtract byte Src to Dest
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $51
001E33  1                FHdr "SUBB,",0 ; ( DestReg SrcReg -- ) Subtract byte Src to Dest
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $41
001E33  1                FHdr "SABB,",0 ; ( -- ) BL=AL-BL
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $49
001E33  1                FHdr "SAB,",0 ; ( -- ) BW=AW-BW
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $59
001E33  1               
001E33  1                FHdr "ANDW,",0 ; ( DestReg SrcReg -- ) AND word Src to Dest
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $52
001E33  1                FHdr "ANDB,",0 ; ( DestReg SrcReg -- ) AND byte Src to Dest
001E33  1               	JSRD A_egReg
001E33  1               	.byte $42
001E33  1                FHdr "NABB,",0 ; ( -- ) BL&=AL
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $4A
001E33  1                FHdr "NAB,",0 ; ( -- ) BW&=AW
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $5A
001E33  1               
001E33  1                FHdr "ORI,",0 ; ( DestReg SrcReg -- ) OR word Src to Dest
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $53
001E33  1                FHdr "ORIB,",0 ; ( DestReg SrcReg -- ) OR byte Src to Dest
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $43
001E33  1               
001E33  1                FHdr "ORE,",0 ; ( DestReg SrcReg -- ) XOR word Src to Dest
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $54
001E33  1                FHdr "OREB,",0 ; ( DestReg SrcReg -- ) XOR byte Src to Dest
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $44  ;,((SrcReg&$f)<<4)+(DestReg&$f)
001E33  1               
001E33  1                FHdr "XFR,",0 ; ( DestReg SrcReg -- ) Copy Src register into Dest register
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $55 ;,((SrcReg&$f)<<4)+(DestReg&$f)
001E33  1                FHdr "XFRB,",0 ; ( DestReg SrcReg -- ) Copy byte of Src register into byte of Dest register
001E33  1               	JSRD A_RegReg
001E33  1               	.byte $45 ;,((SrcReg&$f)<<4)+(DestReg&$f)
001E33  1               
001E33  1               ;  .macro ??
001E33  1               ;	.byte $46	; memory block ops
001E33  1               
001E33  1               ;  .macro ?? ; string ops
001E33  1               ;	.byte $47
001E33  1               
001E33  1               
001E33  1                FHdr "XAXB,",0 ; ( -- ) XL=AL  ???
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $4B
001E33  1                FHdr "XAX,",0 ; ( -- ) XW=AW
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $5B
001E33  1                FHdr "XAYB,",0 ; ( -- ) YL=AL
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $4C
001E33  1                FHdr "XAY,",0 ; ( -- ) YW=AW
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $5C
001E33  1                FHdr "XABB,",0 ; ( -- ) BL=AL
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $4D
001E33  1                FHdr "XAB,",0 ; ( -- ) BW=AW
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $5D
001E33  1                FHdr "XAZB,",0 ; ( -- ) ZL=AL
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $4E
001E33  1                FHdr "XAZ,",0 ; ( -- ) ZW=AW
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $5E
001E33  1                FHdr "XASB,",0 ; ( -- ) SL=AL
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $4F
001E33  1                FHdr "XAS,",0 ; ( -- ) SW=AW
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $5F
001E33  1               ;  .macro ??	; 56	0101 0110	??
001E33  1               ;  .macro ??	; 57	0101 0111	??			Execute micro code?
001E33  1               
001E33  1                FHdr "LDABL,",0 ; ( n -- ) Load literal address into AL register
001E33  1               	JSRD A_LitB
001E33  1               	.byte $80
001E33  1                FHdr "LDAL,",0 ; ( n -- ) Load literal address into full word of AW register
001E33  1               	JSRD A_LitW
001E33  1               	.byte $90
001E33  1                FHdr "LDABD,",0 ; ( adr -- ) Load direct address into AL register
001E33  1               	JSRD A_Direct
001E33  1               	.byte $81
001E33  1                FHdr "LDAD,",0 ; ( adr -- ) Load direct address into full word of AW register
001E33  1               	JSRD A_Direct
001E33  1               	.byte $91
001E33  1                FHdr "LDABI,",0 ; ( adr -- ) Load indirect address into AL register
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $82
001E33  1                FHdr "LDAI,",0 ; ( adr -- ) Load indirect address into full word of AW register
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $92
001E33  1                FHdr "LDABR,",0 ; ( adr -- ) Load direct Program Counter offset by N address into AL register
001E33  1               	JSRD A_Relative
001E33  1               	.byte $83
001E33  1                FHdr "LDAR,",0 ; ( adr -- ) Load direct Program Counter offset by N address into full word of AW register
001E33  1               	JSRD A_Relative
001E33  1               	.byte $93
001E33  1                FHdr "LDABRI,",0 ; ( adr -- ) Load indirect Program Counter offset by N address into byte of AL register
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $84
001E33  1                FHdr "LDARI,",0 ; ( adr -- ) Load indirect Program Counter offset by N address into full word of AW register
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $94
001E33  1                FHdr "LDABX,",0 ; ( WReg Mod Offset -- ) Load indexed register into byte of AL register
001E33  1               	JSRD A_IndexB
001E33  1               	.byte $85
001E33  1                FHdr "LDAX,",0 ; ( WReg Mod Offset -- ) Load indexed register into full word of AW register
001E33  1               	JSRD A_IndexW
001E33  1               	.byte $95
001E33  1               ;  .macro ?? ; 86	1000 0110	??
001E33  1               ;  .macro ?? ; 87	1000 0111	??
001E33  1                FHdr "LDABA,",0 ; ( WReg -- ) Load byte from memory address stored in WReg into AL register
001E33  1               	JSRD A_RegIndirect
001E33  1               	.byte $88 ;+((WReg/2)&7)
001E33  1                FHdr "LDAA,",0 ; ( WReg -- ) Load byte from memory address stored in WReg into AL register
001E33  1               	JSRD A_RegIndirect
001E33  1               	.byte $98 ;+((WReg/2)&7)
001E33  1               ;  .macro ?? ; 96	1001 0110	??
001E33  1               ;  .macro ?? ; 97	1001 0111	??
001E33  1               
001E33  1                FHdr "STABL,",0 ; ( n -- ) Store byte of AL register into literal address (Not possible?)
001E33  1               	JSRD A_LitB
001E33  1               	.byte $A0
001E33  1                FHdr "STAL,",0 ; ( n -- ) Store word of AW register into literal address (Not possible?)
001E33  1               	JSRD A_LitW
001E33  1               	.byte $B0
001E33  1                FHdr "STABD,",0 ; ( adr -- ) Store byte of AL register into direct address
001E33  1               	JSRD A_Direct
001E33  1               	.byte $A1
001E33  1                FHdr "STAD,",0 ; ( adr -- ) Store word of AW register into direct address
001E33  1               	JSRD A_Direct
001E33  1               	.byte $B1
001E33  1                FHdr "STABI,",0 ; ( adr -- ) Store byte of AL register into indirect address
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $A2
001E33  1                FHdr "STAI,",0 ; ( adr -- ) Store word of AW register into indirect address
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $B2
001E33  1                FHdr "STABR,",0 ; ( adr -- ) Store byte of AL register into direct Program Counter offset by N address
001E33  1               	JSRD A_Relative
001E33  1               	.byte $a3
001E33  1                FHdr "STAR,",0 ; ( adr -- ) Store word of AW register into direct Program Counter offset by N address
001E33  1               	JSRD A_Relative
001E33  1               	.byte $b3
001E33  1                FHdr "STABRI,",0 ; ( adr -- ) Store byte of AL register into indirect Program Counter offset by N address
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $a4
001E33  1                FHdr "STARI,",0 ; ( adr -- ) Store word of AW register into indirect Program Counter offset by N address
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $b4
001E33  1                FHdr "STABX,",0 ; ( WReg Mod Offset -- ) Store byte of AL register into indexed register
001E33  1               	JSRD A_Index
001E33  1               	.byte $A5
001E33  1                FHdr "STAX,",0 ; ( WReg Mod Offset -- ) Store word of AW register into indexed register
001E33  1               	JSRD A_Index
001E33  1               	.byte $B5
001E33  1               ;  .macro ?? ; A6	1010 0110	??
001E33  1               ;  .macro ?? ; A7	1010 0111	??
001E33  1                FHdr "STABA,",0 ; ( WReg -- ) Store AL register to memory address stored in WReg
001E33  1               	JSRD A_RegA
001E33  1               	.byte $A8 ;+((WReg/2)&7)
001E33  1                FHdr "STAA,",0 ; ( WReg -- ) Store AW register to memory address stored in WReg
001E33  1               	JSRD A_RegA
001E33  1               	.byte $B8 ;+((WReg/2)&7)
001E33  1               ; .macro ?? ; B6	1011 0110	??
001E33  1               ; .macro ?? ; B7	1011 0111	??
001E33  1               
001E33  1                FHdr "LDBBL,",0 ; ( n -- ) Load literal address into BL register
001E33  1               	JSRD A_LitB
001E33  1               	.byte $C0
001E33  1                FHdr "LDBL,",0 ; ( n -- ) Load literal address into BW register
001E33  1               	JSRD A_LitW
001E33  1               	.byte $D0
001E33  1                FHdr "LDBBD,",0 ; ( adr -- ) Load direct address into BL register
001E33  1               	JSRD A_Direct
001E33  1               	.byte $C1
001E33  1                FHdr "LDBD,",0 ; ( adr -- ) Load direct address into BW register
001E33  1               	JSRD A_Direct
001E33  1               	.byte $D1
001E33  1                FHdr "LDBBI,",0 ; ( adr -- ) Load indirect address into BL register
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $C2
001E33  1                FHdr "LDBI,",0 ; ( adr -- ) Load indirect address into BW register
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $D2
001E33  1                FHdr "LDBBR,",0 ; ( adr -- ) Load direct Program Counter offset by N address into BL register
001E33  1               	JSRD A_Relative
001E33  1               	.byte $c3
001E33  1                FHdr "LDBR,",0 ; ( adr -- ) Load direct Program Counter offset by N address into BW register
001E33  1               	JSRD A_Relative
001E33  1               	.byte $d3
001E33  1                FHdr "LDBBRI,",0 ; ( adr -- ) Load indirect Program Counter offset by N address into BL register
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $c4
001E33  1                FHdr "LDBRI,",0 ; ( adr -- ) Load indirect Program Counter offset by N address into BW register
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $d4
001E33  1                FHdr "LDBBX,",0 ; ( WReg Mod Offset -- ) Load indexed register into BL register
001E33  1               	JSRD A_IndexB
001E33  1               	.byte $C5
001E33  1                FHdr "LDBX,",0 ( WReg Mod Offset ) Load indexed register into BW register
001E33  1               	JSRD A_IndexW
001E33  1               	.byte $D5
001E33  1               ;  .macro ?? ; C6	1100 0110	??
001E33  1               ;  .macro ?? ; C7	1100 0111	??
001E33  1               
001E33  1                FHdr "LDBBA,",0 ; ( WReg -- ) Load byte from memory address stored in WReg into BL register
001E33  1               	JSRD A_RegA
001E33  1               	.byte $C8 ;+((WReg/2)&7)
001E33  1                FHdr "LDBA,",0 ; ( WReg -- ) Load word from memory address stored in WReg into BW register
001E33  1               	JSRD A_RegA
001E33  1               	.byte $D8 ;+((WReg/2)&7)
001E33  1               ;  .macro ?? ; D6	1101 0110	??
001E33  1               ;  .macro ?? ; D7	1101 0111	??
001E33  1               
001E33  1                FHdr "STBBL,",0 ; ( n -- ) Store byte of BL register into literal address (Not possible?)
001E33  1               	JSRD A_LitB
001E33  1               	.byte $E0
001E33  1                FHdr "STBL,",0 ; ( n -- ) Store BW into literal address (Not possible?)
001E33  1               	JSRD A_LitW
001E33  1               	.byte $F0
001E33  1                FHdr "STBBD,",0 ; ( adr -- ) Store BL into direct address
001E33  1               	JSRD A_Direct
001E33  1               	.byte $E1
001E33  1                FHdr "STBD,",0 ; ( adr -- ) Store BW into direct address
001E33  1               	JSRD A_Direct
001E33  1               	.byte $F1
001E33  1                FHdr "STBBI,",0 ; ( adr -- ) Store BL into indirect address
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $E2
001E33  1                FHdr "STBI,",0 ; ( adr -- ) Store BW into indirect address
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $F2
001E33  1                FHdr "STBBR,",0 ; ( adr -- ) Store BL into direct Program Counter offset by N address
001E33  1               	JSRD A_Relative
001E33  1               	.byte $e3
001E33  1                FHdr "STBR,",0 ; ( adr -- ) Store BW into direct Program Counter offset by N address
001E33  1               	JSRD A_Relative
001E33  1               	.byte $f3
001E33  1                FHdr "STBBRI,",0 ; ( adr -- ) Store BL into indirect Program Counter offset by N address
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $e4
001E33  1                FHdr "STBRI,",0 ; ( adr -- ) Store BW into indirect Program Counter offset by N address
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $f4
001E33  1                FHdr "STBBX,",0 ; ( WReg Mod Offset -- ) Store BL into indexed register
001E33  1               	JSRD A_Index
001E33  1               	.byte $E5
001E33  1               ;	ModBytes WReg,Mod,Offset
001E33  1                FHdr "STBX,",0 ; ( WReg Mod Offset -- ) ; Store BW into indexed register
001E33  1               	JSRD A_Index
001E33  1               	.byte $F5
001E33  1               ;  .macro ?? ; E6	1110 0110	??
001E33  1               ;  .macro ?? ; E7	1110 0111	??
001E33  1                FHdr "STBBA,",0 ; ( WReg -- ) Store byte from BL register to memory address stored in WReg
001E33  1               	JSRD A_RegB
001E33  1               	.byte $E8 ;+((WReg/2)&7)
001E33  1                FHdr "STBA,",0 ; ( WReg -- ) Store BW to memory address stored in WReg
001E33  1               	JSRD A_RegW
001E33  1               	.byte $F8 ;+((WReg/2)&7)
001E33  1               ;  .macro ?? ; F6	1111 0110	??
001E33  1               ;  .macro ?? ; F7	1111 0111	??
001E33  1               
001E33  1               
001E33  1                FHdr "LDXL,",0 ; ( n -- ) Load immediate into XW
001E33  1               	JSRD A_LitW
001E33  1               	.byte $60
001E33  1                FHdr "LDXD,",0 ; ( adr -- ) Load direct address into XW
001E33  1               	JSRD A_Direct
001E33  1               	.byte $61
001E33  1                FHdr "LDXI,",0 ; ( adr -- ) Load indirect address into XW
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $62
001E33  1                FHdr "LDXR,",0 ; ( adr -- ) Load direct Program Counter offset by N address into XW
001E33  1               	JSRD A_Relative
001E33  1               	.byte $63
001E33  1                FHdr "LDXRI,",0 ; ( adr -- ) Load indirect Program Counter offset by N address into XW
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $64
001E33  1                FHdr "LDXX,",0 ; ( WReg Mod Offset -- ) Load indexed mode register into XW
001E33  1               	JSRD A_Index
001E33  1               	.byte $65
001E33  1               ;  .macro ??	; 66	0110 0110	??
001E33  1               ;  .macro ??	; 67	0110 0111	??
001E33  1                FHdr "STXL,",0 ; ( n -- ) Store XW into literal address (Not possible?)
001E33  1               	JSRD A_LitW
001E33  1               	.byte $68
001E33  1                FHdr "STXD,",0 ; ( adr -- ) Store XW into direct address
001E33  1               	JSRD A_Direct
001E33  1               	.byte $69
001E33  1                FHdr "STXI,",0 ; ( adr -- ) Store XW into indirect address
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $6A
001E33  1                FHdr "STXR,",0 ; ( adr -- ) Store XW into direct Program Counter offset by N address
001E33  1               	JSRD A_Relative
001E33  1               	.byte $6b
001E33  1                FHdr "STXRI,",0 ; ( adr -- ) Store XW into indirect Program Counter offset by N address
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $6c
001E33  1                FHdr "STXX,",0 ; ( WReg Mod Offset -- ) Store XW into indexed register
001E33  1               	JSRD A_Index
001E33  1               	.byte $6D
001E33  1               ;  .macro ??	; 6E	0110 1110	??
001E33  1               ;  .macro ??	; 6F	0110 1111	??
001E33  1               
001E33  1               ;  .macro ??	; $70
001E33  1                FHdr "JMPD,",0 ; ( adr -- ) Jump to direct address
001E33  1               	JSRD A_Direct
001E33  1               	.byte $71
001E33  1                FHdr "JMPI,",0 ; ( adr -- ) Jump to indirect address
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $72
001E33  1                FHdr "JMPR,",0 ; ( adr -- ) Jump to direct Program Counter offset by N address
001E33  1               	JSRD A_Relative
001E33  1               	.byte $73
001E33  1                FHdr "JMPRI,",0 ; ( adr -- ) Jump to indirect Program Counter offset by N address
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $74
001E33  1                FHdr "JMPX,",0 ; ( WReg Mod Offset -- ) Jump to indexed mode register
001E33  1               	JSRD A_Index
001E33  1               	.byte $75
001E33  1                FHdr "SYSCALL,",0 ( -- ) Call interrupt level 15
001E33  1               	JSRD A_Inherent
001E33  1               	.byte $76
001E33  1               ;  .macro ?? ; 77	??
001E33  1               
001E33  1               ;  .macro ?? ; 78 ??
001E33  1                FHdr "JSRD,",0 ; ( adr -- ) Jump to subroutine at direct address
001E33  1               	JSRD A_Direct
001E33  1               	.byte $79
001E33  1                FHdr "JSRI,",0 ; ( adr -- ) Jump to subroutine at indirect address
001E33  1               	JSRD A_Indirect
001E33  1               	.byte $7A
001E33  1                FHdr "JSRR,",0 ; ( adr -- ) Jump to subroutine at Program Counter offset by N address
001E33  1               	JSRD A_Relative
001E33  1               	.byte $7b
001E33  1                FHdr "JSRRI,",0 ; ( adr -- ) Jump to subroutine at indirect Program Counter offset by N address
001E33  1               	JSRD A_RelativeIndirect
001E33  1               	.byte $7c
001E33  1                FHdr "JSRX,",0 ; ( WReg Mod Offset -- ) Jump to subroutine at indexed mode register
001E33  1               	JSRD A_IndexB
001E33  1               	.byte $7D
001E33  1               
001E33  1                FHdr "PUSH,",0 ; ( BReg n -- )  push registers
001E33  1               	JSRD A_ ;???
001E33  1               	.byte $7e
001E33  1                FHdr "POP,",0 ; ( BReg n -- )  pop registers
001E33  1               	JSRD A_ ;???
001E33  1               	.byte $7f
001E33  1               
001E33  1               
001E33  1                .endif ; assembler & disassembler
001E33  1               
001E33  1               	.if 0
001E33  1               ;-------------------------------------------------------------------------
001E33  1               ; 12. The optional Floating-Point word set
001E33  1               ; https://forth-standard.org/standard/float
001E33  1               
001E33  1               
001E33  1               
001E33  1               
001E33  1               	.endif  ; floating point
001E33  1               
001E33  1               NTOP	= DictLink
001E33  1               TOP:
001E33  1               
001E33  1               
001E33  1               ;	.org $fc00 ; bootstrap ROM for simulator ------------------------------------
001E33  1               ;
001E33  1               ;	LDAL ReEnter	; set restart vector
001E33  1               ;	STAD $1a
001E33  1               ;	JMPD Enter	; just jmp to FORTH
001E33  1               
001E33  1               	.end
