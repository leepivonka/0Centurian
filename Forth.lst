ca65 V2.19 - Git d3cd668
Main file   : Forth.txt
Current file: Forth.txt

000000r 1               ; Subroutine threaded version of FIG FORTH for Centurion CPU6.
000000r 1               ;	CPU6 is a follow-on from "Eldorado ee200"
000000r 1               ; https://github.com/Nakazoto/CenturionComputer/
000000r 1               ; See also: "Starting FORTH" https://www.forth.com/starting-forth/
000000r 1               ; See also: https://forth-standard.org
000000r 1               ; See also: http://uefi.org
000000r 1               
000000r 1               ; by Lee Pivonka
000000r 1               
000000r 1               ; Based on FIG FORTH 6502 from http://6502.org/source/ .
000000r 1               
000000r 1               ;			 Through the courtesy of
000000r 1               ;
000000r 1               ;			  FORTH INTEREST GROUP
000000r 1               ;			     P.O. BOX  2154
000000r 1               ;			  OAKLAND, CALIFORNIA
000000r 1               ;				 94621
000000r 1               ;
000000r 1               ;
000000r 1               ;			      Release 1.1
000000r 1               ;
000000r 1               ;			 with compiler security
000000r 1               ;				   and
000000r 1               ;			 variable length names
000000r 1               ;
000000r 1               ;    Further distribution must include the above notice.
000000r 1               ;    The FIG installation Manual is required as it contains
000000r 1               ;    the model of FORTH and glossary of the system.
000000r 1               ;    Available from FIG at the above address for **.** postpaid.
000000r 1               ;
000000r 1               ;    Translated from the FIG model by W.F. Ragsdale with input-
000000r 1               ;    output given for the Rockwell System-65. Transportation to
000000r 1               ;    other systems requires only the alteration of :
000000r 1               ;		  EmitA KeyA QTerminalA RSlashW Mon
000000r 1               
000000r 1               ; This version has 2 major modifications from the FIG version:
000000r 1               ; * Subroutine threaded code.  There is no DoCol or other colon routines - it's all CPU6 code.
000000r 1               ;	There is no PFA or CFA - words start with CPU6 code.
000000r 1               ;	Words that use the CFA PFA model start with a JSR to the code, followed by the parameters.
000000r 1               ; * Word headers are remodeled.  There are no NFA PFA CFA versions - there is a single pointer to the
000000r 1               ;	CPU6 code, & header fields are at negative offsets from that.
000000r 1               
000000r 1               ; This file includes machine code definitions of all of the core words.
000000r 1               ; When this code is running, additional definitions can be typed in or compiled from disk.
000000r 1               
000000r 1               ; Standard CPU6 register usage:
000000r 1               ; A	scratch
000000r 1               ; B	scratch
000000r 1               ; X	CPU6, scratch
000000r 1               ; Y	scratch
000000r 1               ; Z	FORTH parameter stack pointer
000000r 1               ; S	CPU6, FORTH return stack pointer
000000r 1               ; C	CPU6
000000r 1               ; P	CPU6
000000r 1               
000000r 1               ; Compile with ca65 from cc65 - https://cc65.github.io/
000000r 1               
000000r 1               	.list on
000000r 1               	.listbytes unlimited ;include all object bytes in listing (since we load the listing file)
000000r 1               	.feature loose_string_term ; used to put quotes in strings
000000r 1               
000000r 1               	.include "0instructions.txt"  ; define Centurion CPU6 instructions
000000r 2               ; CA65 macro package for Centurion CPU6 (& EE 200) code.
000000r 2               ; https://github.com/Nakazoto/CenturionComputer/wiki/Instructions
000000r 2               
000000r 2               ; per yaros
000000r 2                .feature ubiquitous_idents
000000r 2                .setcpu "none"
000000r 2               
000000r 2               ; There are a few gotchas with this setup:
000000r 2               ;
000000r 2               ; * 6502 opcodes cannot be disabled in CA65.  If a 6502 opcode is used in a CPU6 program,
000000r 2               ;       it'll compile fine, but have strange & bad runtime behavior.
000000r 2               ;	Fortunately there are only a few collisions between 6502 & CPU6 opcodes:
000000r 2               ;		NOP  INX
000000r 2               ;	The CPU6 macro name has an appended C (for Centurion) in these cases.
000000r 2               ;
000000r 2               ; * Relative addresses aren't checked for out-of-range.  i havent' figured out how to
000000r 2               ;	explain this nicely to CA65.  There must be a way, 6502 branches do it nicely.
000000r 2               ;     Currently there are to versions of BRel:
000000r 2               ;     * The 1st one checks the range but generates a bad listing.
000000r 2               ;     * The 2nd one generates a correct listing but doesn't check range.
000000r 2               ;     It is useful to compile with the range check version enabled to check range,
000000r 2               ;	then compile with the other to generate a correct listing.
000000r 2               ;     I assume the object code file is correct in either case, but I'm currently
000000r 2               ;	report scraping the listing file to load it in my simulator.
000000r 2               
000000r 2               ; Instructions
000000r 2               ; This is a list of the available registers, OpCodes / Instructions, and what they mean.
000000r 2               ; These were all reverse engineered by just looking at existing code and recognizing patterns.
000000r 2               ; As such, this list may be incomplete or full of errors.
000000r 2               ; Any resemblance to the mnemonics or syntax used by other processors, such as the 8086, is simply because we borrowed existing syntax where it seemed fit.
000000r 2               ; The processor itself shares no design or architecture with any other documented existing processors we're aware of.
000000r 2               ; It is based upon the CPU4 and CPU5 earlier Warrex designs, and apparently the CD 200 before that, but we have no documentation for those either.
000000r 2               ; See ee 200.
000000r 2               
000000r 2               ; Registers
000000r 2               ; There are eight registers available.
000000r 2               ;	 Name	Usage			Notes
000000r 2               AW = $0 ; A	Primary Accumulator	Primary register, commonly used in implicit operations
000000r 2               AH = $0
000000r 2               AL = $1
000000r 2               BW = $2 ; B	Secondary Accumulator	Primary register, commonly used in implicit operations
000000r 2               BH = $2
000000r 2               BL = $3
000000r 2               XW = $4 ; X	Primary Index		Can only do word operations (Not true for CPU6?)
000000r 2               YW = $6 ; Y	Index or Working	Index registers or working storage registers
000000r 2               YH = $6
000000r 2               YL = $7
000000r 2               ZW = $8 ; Z	Index or Working	Index registers or working storage registers
000000r 2               ZH = $8
000000r 2               ZL = $9
000000r 2               SW = $a ; S	Stack pointer		Global among all interrupt levels
000000r 2               SH = $a
000000r 2               SL = $b
000000r 2               CW = $c ; C	Context			Contains the status condition indicators (fault, link, minus, and value) and preceding interrupt level
000000r 2               PW = $e ; P	Program Counter Base	Contains initial program counter value to be used when starting up or returning from interrupt
000000r 2               
000000r 2               ; Contexts
000000r 2               ; Each register and the flags appears to exist in 16 contexts and these contexts are mapped between 0x0000 and 0x00FF
000000r 2               ; 16 bytes per context starting with context 0 and working upwards.
000000r 2               ; The registers are stored in the memory in the order given above. Writing to the memory of another context updates the registers for that context.
000000r 2               ; Writing to the memory for your own context appears to change the register value except for PC and the unknown extra register.
000000r 2               ; Possibly PC is cached/reloaded on a context switch.
000000r 2               
000000r 2               ; The processor starts in context 0.
000000r 2               ; Context 15 is used by what appears to be a syscall instruction.
000000r 2               ; context 6 is used by the MUX interrupt test.
000000r 2               ; context 1 is used programatically during MMU testing.
000000r 2               
000000r 2               ; Interrupts are processed by a hardware triggered context switch, the execution of code in the new context,
000000r 2               ; and then an RI or RIM instruction.
000000r 2               
000000r 2               ; Instruction Organization
000000r 2               ; Instructions are constructed a nibble at a time, like a Build a Bear. The high nibble of the high byte determines what kind of operation is being executed. It should be noted that the lowest bit of the high nibble determines whether we are doing a byte operation or a word operation (excluding Control, Branch, X register and Jump operations). For example, 0x8 is 1000 in binary and is a byte operation. 0x9 is 1001 in binary and is a word operation. Both operation load the A register, but the low bit being either "0" or "1" is what determines whether we are loading a byte or word.
000000r 2               
000000r 2               ; High nibble	Operation type
000000r 2               ; 0x0	Control instructions
000000r 2               ; 0x1	Conditional branch instructions
000000r 2               ; 0x2	Single Register byte operations
000000r 2               ; 0x3	Single register word operations
000000r 2               ; 0x4	Double register byte operations
000000r 2               ; 0x5	Double register word operations
000000r 2               ; 0x6	X register memory reference operations
000000r 2               ; 0x7	Jump operations
000000r 2               ; 0x8	A register load byte operations
000000r 2               ; 0x9	A register load word operations
000000r 2               ; 0xA	A register store byte operations
000000r 2               ; 0xB	A register store word operations
000000r 2               ; 0xC	B register load byte operations
000000r 2               ; 0xD	B register load word operations
000000r 2               ; 0xE	B register store byte operations
000000r 2               ; 0xF	B register store word operations
000000r 2               
000000r 2               ; Addressing Modes
000000r 2               ; Instructions can be either 1-byte, 2-byte or 3-byte depending on the type of instruction.
000000r 2               ; The second or third byte (if present) are related to addressing, or directing the instruction as to which location in memory to act upon.
000000r 2               ; Addressing can be either implicit or explicit.
000000r 2               ; Implicit means that no addressing is specified, and that specific instruction operates on only one specific location.
000000r 2               ; Explicit means the programmer must state which location they will perform the operation on.
000000r 2               
000000r 2               ; In the chart below, the addressing mode and what is expected at each nibble of each operation is shown.
000000r 2               
000000r 2               ; HB = High Byte; MB = Mid Byte; LB = Low Byte
000000r 2               
000000r 2               ; HN = High Nibble; LN = Low Nibble
000000r 2               
000000r 2               ; HB_HN      	HB_LN      	MB_HN  	MB_LN  	LB_HN  	LB_LN  	Note
000000r 2               ; 0	Op (0-F)					Control Operations
000000r 2               ; 1	Op (0-F)	Displace	Displace			Branch Operations
000000r 2               ; 2	Op (0-7)	Source Reg.				Single Register Explicit Byte Operation
000000r 2               ; 2	Op (8-F)					Single Register Implicit Byte Operation
000000r 2               ; 3	Op (0-7)	Source Reg.				Single Register Explicit Word Operation
000000r 2               ; 3	Op (8-F)					Single Register Implicit Word Operation
000000r 2               ; 4	Op (0-7)	Source Reg.	Dest. Reg.			Double Register Explicit Byte Operation
000000r 2               ; 4	Op (8-F)					Double Register Implicit Byte Operation
000000r 2               ; 5	Op (0-7)	Source Reg.	Dest. Reg.			Double Register Explicit Word Operation
000000r 2               ; 5	Op (8-F)					Double Register Implicit Word Operation
000000r 2               ; Op (6-F)	0	Literal	Literal			Literal Memory Address Byte Operation
000000r 2               ; Op (6-F)	0	Literal	Literal	Literal	Literal	Literal Memory Address Word Operation
000000r 2               ; Op (6-F)	1	Direct	Direct	Direct	Direct	Direct Memory Address Operation
000000r 2               ; Op (6-F)	2	Indirect	Indirect	Indirect	Indirect	Indirect Memory Address Operation
000000r 2               ; Op (6-F)	3	Displace	Displace			Relative to Current Location Memory Address Operation
000000r 2               ; Op (6-F)	4	Displace	Displace			Indirect Relative to Current Location Memory Address Operation
000000r 2               ; Op (6-F)	5	Register	Modifier	Displace	Displace	Indexed Addressing (Modifier Table Below)
000000r 2               ; Op (6-F)	8-F					Implicit Indexing (8 - F => A - P Reg.)
000000r 2               
000000r 2               ; These strange names aren't so strange if you think of the 1st letter of each part
000000r 2               ; of the expression:
000000r 2               ;  ModBRPB is Mod Bracket Register Plus Bracket
000000r 2               ;
000000r 2               ; Modifier	Note
000000r 2               ModBRB    =  0 ; (r)	Index
000000r 2               ModBRPB   =  1 ; (r+)	Index; Index returned, incremented by ^
000000r 2               ModBMRB   =  2 ; (-r)	Decrement and Index
000000r 2               ModABRB   =  4 ; @(r)	Index indirect
000000r 2               ModABRPB  =  5 ; @(r+)	Index indirect; Index returned, incremented by ^
000000r 2               ModABMRB  =  6 ; @(-r)	Decrement and index indirect
000000r 2               ModNBRB   =  8 ; n(r)	Index with displacement
000000r 2               ModNBRPB  =  9 ; n(r+)	Index with displacement; Index returned, incremented by ^
000000r 2               ModNBMRB  = $A ; n(-r)	Decrement and index with displacement
000000r 2               ModANBRB  = $C ; @n(r)	Index with displacement indirect
000000r 2               ModANBRPB = $D ; @n(r+)	Index with displacement indirect, Index returned, incremented by ^
000000r 2               ModANBMRB = $E ; @n(-r)	Decrement and index with displacement indirect
000000r 2               
000000r 2                 .macro ModBytes WReg,Mod,Offset
000000r 2               	.if (WReg&$fff1)<>0
000000r 2               	  .error "WReg must be a word register"
000000r 2               	 .endif
000000r 2               	.if (Mod=ModBRB) | (Mod=ModBRPB) | (Mod=ModBMRB) | (Mod=ModABRB) | (Mod=ModABRPB) | (Mod=ModABMRB)
000000r 2               	  .byte (WReg<<4)|Mod
000000r 2               	 .else
000000r 2               	  .if (Mod=ModNBRB) | (Mod=ModNBRPB) | (Mod=ModNBMRB) | (Mod=ModANBRB) | (Mod=ModANBRPB) | (Mod=ModANBMRB)
000000r 2               	    .byte (WReg<<4)|Mod,Offset ; is offset signed or unsigned???
000000r 2                          .else
000000r 2               	    .error "Unknown Mod"
000000r 2               	   .endif
000000r 2               	 .endif
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro HLT ; Wait for Interrupt (Halt)
000000r 2               	.byte $00
000000r 2               	.endmacro
000000r 2                 .macro NOPC ; No Operation
000000r 2               	.byte $01
000000r 2               	.endmacro
000000r 2                 .macro SF ; Set Fault flag
000000r 2               	.byte $02
000000r 2               	.endmacro
000000r 2                 .macro RF ; Reset Fault flag
000000r 2               	.byte $03
000000r 2               	.endmacro
000000r 2                 .macro EI ; Enable the Interrupt System (allow interrupts)
000000r 2               	.byte $04
000000r 2               	.endmacro
000000r 2                 .macro DI ; Disable the Interrupt System (disable interrupts)
000000r 2               	.byte $05
000000r 2               	.endmacro
000000r 2                 .macro SL ; Set the Link (carry) Flag
000000r 2               	.byte $06
000000r 2               	.endmacro
000000r 2                 .macro RL ; Reset the Link (carry) Flag
000000r 2               	.byte $07
000000r 2               	.endmacro
000000r 2                 .macro CL ; Complement Link flag
000000r 2               	.byte $08
000000r 2               	.endmacro
000000r 2                 .macro RSR ; Return from subroutine
000000r 2               	.byte $09
000000r 2               	.endmacro
000000r 2                 .macro RI ; Return from interrupt
000000r 2               	.byte $0A
000000r 2               	.endmacro
000000r 2                 .macro RIM ; Return from Interrupt Modified
000000r 2               	.byte $0B
000000r 2               	.endmacro
000000r 2                 .macro ELO ; Enable Link Out - teletype_tx=Link
000000r 2               	.byte $0C
000000r 2               	.endmacro
000000r 2                 .macro PCX ; Transfer PC to X - X=address of next instruction
000000r 2               	.byte $0D
000000r 2               	.endmacro
000000r 2                 .macro DLY ; Delay 4.55 ms - for TTY bit timing
000000r 2               	.byte $0E
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; Return from Syscall or similar (pops a byte, then the new value of rt, then a byte, then the new ipl)
000000r 2               ;	.byte $0F
000000r 2               ;	.endmacro
000000r 2               
000000r 2                 .macro BRel op,adr ; Build branch offset byte (correct listing, no range check)
000000r 2               ;	.local @L1
000000r 2               ;@L1	= adr-*		; PC+N
000000r 2               ;	.if L1<-$82 || L1>=$82  ; this chokes on fwd refs, so we can't check the range
000000r 2               ;	  .error "Branch out of range"
000000r 2               ;	 .endif
000000r 2               	.byte op,.lobyte(adr-*-1)
000000r 2               	.endmacro
000000r 2                 .macro BRel3 op,adr ; Build branch offset byte (bad listing, does range check)
000000r 2               	bne adr
000000r 2               	.org *-2  ; this doesn't show up right in the listing (that we load!)
000000r 2               	.byte op
000000r 2               	.org *+1
000000r 2               	.endmacro
000000r 2                 .macro BL adr ; Branch if Link (Carry) Set
000000r 2               	BRel $10,adr
000000r 2               	.endmacro
000000r 2                 .macro BNL adr ; Branch if Link (Carry) not Set
000000r 2               	BRel $11,adr
000000r 2               	.endmacro
000000r 2                 .macro BF adr ; Branch if Fault Set
000000r 2               	BRel $12,adr
000000r 2               	.endmacro
000000r 2                 .macro BNF adr ; Branch if Fault not Set
000000r 2               	BRel $13,adr
000000r 2               	.endmacro
000000r 2                 .macro BZ adr ; Branch if V (Z) flag set
000000r 2               	BRel $14,adr
000000r 2               	.endmacro
000000r 2                 .macro BNZ adr ; Branch if V (Z) flag clear
000000r 2               	BRel $15,adr
000000r 2               	.endmacro
000000r 2                 .macro BM adr ; Branch if Minus flag set
000000r 2               	BRel $16,adr
000000r 2               	.endmacro
000000r 2                 .macro BP adr ; Branch on Positive (Minus flag clear)
000000r 2               	BRel $17,adr
000000r 2               	.endmacro
000000r 2                 .macro BGZ adr ; Branch if Greater Than 0 (!V && !Minus)
000000r 2               	BRel $18,adr
000000r 2               	.endmacro
000000r 2                 .macro BLE adr ; Branch if Less Than or Equal to 0 (V | Minus)
000000r 2               	BRel $19,adr
000000r 2               	.endmacro
000000r 2                 .macro BS1 adr ; Branch if Sense Switch 1 Set
000000r 2               	BRel $1a,adr
000000r 2               	.endmacro
000000r 2                 .macro BS2 adr ; Branch if Sense Switch 2 Set
000000r 2               	BRel $1b,adr
000000r 2               	.endmacro
000000r 2                 .macro BS3 adr ; Branch if Sense Switch 3 Set
000000r 2               	BRel $1c,adr
000000r 2               	.endmacro
000000r 2                 .macro BS4 adr ; Branch if Sense Switch 4 Set
000000r 2               	BRel $1d,adr
000000r 2               	.endmacro
000000r 2                 .macro BTM Rel ; Branch on TTY Mark (Changed for CPU6?)
000000r 2               	BRel $1e,Rel
000000r 2               	.endmacro
000000r 2                 .macro BEP Rel ; Branch on Even Parity (Changed for CPU6?)
000000r 2               	BRel $1f,adr
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro RegW OpWord,Reg,Const
000000r 2               ;	.if (Reg&$fff0)=$40  ; word register?
000000r 2               	  .byte OpWord,((Reg&$f)<<4)+(Const&$f)
000000r 2               ;	 .else
000000r 2               ;	  .error "Strange register"
000000r 2               ;	 .endif
000000r 2               	.endmacro
000000r 2                 .macro RegB OpByte,Reg
000000r 2               ;	.if (Reg&$fff0)=$60  ; byte register?
000000r 2               	  .byte OpByte,(Reg&$f)<<4
000000r 2               ;	 .else
000000r 2               ;	  .error "Strange register"
000000r 2               ;	 .endif
000000r 2               	.endmacro
000000r 2                 .macro INR WReg,Const	; increment register word
000000r 2               	RegW $30,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro INRB BReg	; increment register upper byte or lower byte
000000r 2               	RegB $20,BReg
000000r 2               	.endmacro
000000r 2                 .macro INAB		; Increment AL register
000000r 2               	.byte $28
000000r 2               	.endmacro
000000r 2                 .macro INA		; Increment AW register
000000r 2               	.byte $38
000000r 2               	.endmacro
000000r 2                 .macro DCR WReg,Const	; decrement register word
000000r 2               	RegW $31,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro DCRB BReg	; decrement register upper byte or lower byte
000000r 2               	RegB $21,BReg
000000r 2               	.endmacro
000000r 2                 .macro DCAB		; Decrement AL register
000000r 2               	.byte $29
000000r 2               	.endmacro
000000r 2                 .macro DCA		; Decrement AW register
000000r 2               	.byte $39
000000r 2               	.endmacro
000000r 2                 .macro CLR WReg,Const	; clear register word
000000r 2               	RegW $32,WReg,Const
000000r 2               	.endmacro
000000r 2                 .macro CLRB BReg	; clear register upper byte or lower byte
000000r 2               	RegB $22,BReg
000000r 2               	.endmacro
000000r 2                 .macro CLAB		; Clear AL register
000000r 2               	.byte $2A
000000r 2               	.endmacro
000000r 2                 .macro CLA		; Clear AW register
000000r 2               	.byte $3A
000000r 2               	.endmacro
000000r 2                 .macro IVR WReg,Const	; invert register word
000000r 2               	RegW $33,WReg,Const
000000r 2               	.endmacro
000000r 2                 .macro IVRB BReg	; invert register byte
000000r 2               	RegB $23,BReg
000000r 2               	.endmacro
000000r 2                 .macro IVAB		; Invert AL register
000000r 2               	.byte $2B
000000r 2               	.endmacro
000000r 2                 .macro IVA		; Invert AW register
000000r 2               	.byte $3B
000000r 2               	.endmacro
000000r 2                 .macro SRR WReg,Const	; shift register right (sign extend)
000000r 2               	RegW $34,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro SRRB BReg	; shift register byte right (sign extend)
000000r 2               	RegB $24,BReg
000000r 2               	.endmacro
000000r 2                 .macro SRAB		; Shift AL register right (sign extend)
000000r 2               	.byte $2C
000000r 2               	.endmacro
000000r 2                 .macro SRA		; Shift AW register right (sign extend)
000000r 2               	.byte $3C
000000r 2               	.endmacro
000000r 2                 .macro SLR WReg,Const	; shift register left (0 shifted in)
000000r 2               	RegW $35,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro SLRB BReg	; shift register byte left (0 shifted in)
000000r 2               	RegBW $25,BReg
000000r 2               	.endmacro
000000r 2                 .macro SLAB		; Shift AL register left (0 shifted in)
000000r 2               	.byte $2D
000000r 2               	.endmacro
000000r 2                 .macro SLA		; Shift AW register left (0 shifted in)
000000r 2               	.byte $3D
000000r 2               	.endmacro
000000r 2                 .macro RRR WReg,Const	; rotate register right (thru link flag)
000000r 2               	RegW $36,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro RRRB BReg	; rotate register byte right (thru link flag)
000000r 2               	RegB $26,BReg
000000r 2               	.endmacro
000000r 2                 .macro RLR WReg,Const	; rotate register left (thru link flag)
000000r 2               	RegW $37,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro RLRB BReg
000000r 2               	RegBW $27,BReg
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; Memory mapping?
000000r 2               ;	.byte $2E
000000r 2               ;	.endmacro
000000r 2               ;  .macro ?? ; DMA?
000000r 2               ;	.byte $2F
000000r 2               ;	.endmacro
000000r 2               
000000r 2                 .macro INXC		; Increment XW register
000000r 2               	.byte $3E
000000r 2               	.endmacro
000000r 2                 .macro DCX		; Decrement XW register
000000r 2               	.byte $3F
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ADD DestReg,SrcReg ; Add word Src to Dest
000000r 2               	.byte $50,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro ADDB DestReg,SrcReg ; Add byte Src to Dest
000000r 2               	.byte $40,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro AABB		; BL+=AL
000000r 2               	.byte $48
000000r 2               	.endmacro
000000r 2                 .macro AAB		; BW+=AW
000000r 2               	.byte $58
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro SUB DestReg,SrcReg ; Subtract byte Src to Dest
000000r 2               	.byte $51,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro SUBB DestReg,SrcReg ; Subtract byte Src to Dest
000000r 2               	.byte $41,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro SABB		; BL=AL-BL
000000r 2               	.byte $49
000000r 2               	.endmacro
000000r 2                 .macro SAB		; BW=AW-BW
000000r 2               	.byte $59
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ANDC DestReg,SrcReg ; AND word Src to Dest
000000r 2               	.byte $52,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro ANDB DestReg,SrcReg ; AND byte Src to Dest
000000r 2               	.byte $42,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro NABB		; BL&=AL
000000r 2               	.byte $4A
000000r 2               	.endmacro
000000r 2                 .macro NAB		; BW&=AW
000000r 2               	.byte $5A
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ORI DestReg,SrcReg ; OR word Src to Dest
000000r 2               	.byte $53,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro ORIB DestReg,SrcReg ; OR byte Src to Dest
000000r 2               	.byte $43,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ORE DestReg,SrcReg ; XOR word Src to Dest
000000r 2               	.byte $54,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro OREB DestReg,SrcReg ; XOR byte Src to Dest
000000r 2               	.byte $44,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro XFR DestReg,SrcReg ; Copy Src register into Dest register
000000r 2               	.byte $55,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro XFRB DestReg,SrcReg ; Copy byte of Src register into byte of Dest register
000000r 2               	.byte $45,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ??
000000r 2               ;	.byte $46
000000r 2               ;	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; Execute micro code?
000000r 2               ;	.byte $47
000000r 2               ;	.endmacro
000000r 2               
000000r 2               
000000r 2                 .macro XAXB	; XL=AL  ???
000000r 2               	.byte $4B
000000r 2               	.endmacro
000000r 2                 .macro XAX	; XW=AW
000000r 2               	.byte $5B
000000r 2               	.endmacro
000000r 2                 .macro XAYB	; YL=AL
000000r 2               	.byte $4C
000000r 2               	.endmacro
000000r 2                 .macro XAY	; YW=AW
000000r 2               	.byte $5C
000000r 2               	.endmacro
000000r 2                 .macro XABB	; BL=AL
000000r 2               	.byte $4D
000000r 2               	.endmacro
000000r 2                 .macro XAB	; BW=AW
000000r 2               	.byte $5D
000000r 2               	.endmacro
000000r 2                 .macro XAZB	; ZL=AL
000000r 2               	.byte $4E
000000r 2               	.endmacro
000000r 2                 .macro XAZ	; ZW=AW
000000r 2               	.byte $5E
000000r 2               	.endmacro
000000r 2                 .macro XASB	; SL=AL
000000r 2               	.byte $4F
000000r 2               	.endmacro
000000r 2                 .macro XAS	; SW=AW
000000r 2               	.byte $5F
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro PUSH BeginReg,RegCount
000000r 2               	.byte $7e,(BeginReg<<4)+((RegCount-1)&$f)
000000r 2               	.endmacro
000000r 2                 .macro POP BeginReg,RegCount
000000r 2               	.byte $7f,(BeginReg<<4)+((RegCount-1)&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ??	; 56	0101 0110	??
000000r 2               
000000r 2               ;  .macro ??	; 57	0101 0111	??			Execute micro code?
000000r 2               
000000r 2               
000000r 2                 .macro LDABL Lit ; Load literal address into AL register
000000r 2               	.byte $80,Lit
000000r 2               	.endmacro
000000r 2                 .macro LDAL Lit ; Load literal address into full word of AW register
000000r 2               	.byte $90
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro LDABD Direct ; Load direct address into AL register
000000r 2               	.byte $81
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDAD Direct ; Load direct address into full word of AW register
000000r 2               	.byte $91
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDABI Indirect ; Load indirect address into AL register
000000r 2               	.byte $82
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDAI Indirect ; Load indirect address into full word of AW register
000000r 2               	.byte $92
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDABR Rel ; Load direct Program Counter offset by N address into AL register
000000r 2               	BRel $83,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDAR Rel ; Load direct Program Counter offset by N address into full word of AW register
000000r 2               	BRel $93,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDABRI Rel ; Load indirect Program Counter offset by N address into byte of AL register
000000r 2               	BRel $84,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDARI Rel ; Load indirect Program Counter offset by N address into full word of AW register
000000r 2               	BRel $94,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDABX WReg,Mod,Offset ; Load indexed register into byte of AL register
000000r 2               	.byte $85
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro LDAX WReg,Mod,Offset ; Load indexed register into full word of AW register
000000r 2               	.byte $95
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; 86	1000 0110	??
000000r 2               ;  .macro ?? ; 87	1000 0111	??
000000r 2                 .macro LDABA WReg ; Load byte from memory address stored in WReg into AL register
000000r 2               	.byte $88+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro LDAA WReg ; Load byte from memory address stored in WReg into AL register
000000r 2               	.byte $98+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; 96	1001 0110	??
000000r 2               ;  .macro ?? ; 97	1001 0111	??
000000r 2               
000000r 2                 .macro STABL Lit ; Store byte of AL register into literal address (Not possible?)
000000r 2               	.byte $A0
000000r 2               	.byte Lit
000000r 2               	.endmacro
000000r 2                 .macro STAL Lit ; Store word of AW register into literal address (Not possible?)
000000r 2               	.byte $B0
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro STABD Direct ; Store byte of AL register into direct address
000000r 2               	.byte $A1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STAD Direct ; Store word of AW register into direct address
000000r 2               	.byte $B1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STABI Indirect ; Store byte of AL register into indirect address
000000r 2               	.byte $A2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STAI Indirect ; Store word of AW register into indirect address
000000r 2               	.byte $B2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STABR Rel ; Store byte of AL register into direct Program Counter offset by N address
000000r 2               	BRel $a3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STAR Rel ; Store word of AW register into direct Program Counter offset by N address
000000r 2               	BRel $b3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STABRI Rel ; Store byte of AL register into indirect Program Counter offset by N address
000000r 2               	BRel $a4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STARI Rel ; Store word of AW register into indirect Program Counter offset by N address
000000r 2               	BRel $b4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STABX WReg,Mod,Offset ; Store byte of AL register into indexed register
000000r 2               	.byte $A5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro STAX WReg,Mod,Offset ; Store word of AW register into indexed register
000000r 2               	.byte $B5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; A6	1010 0110	??
000000r 2               ;  .macro ?? ; A7	1010 0111	??
000000r 2                 .macro STABA WReg ; Store AL register to memory address stored in WReg
000000r 2               	.byte $A8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro STAA WReg ; Store AW register to memory address stored in WReg
000000r 2               	.byte $B8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ; .macro ?? ; B6	1011 0110	??
000000r 2               ; .macro ?? ; B7	1011 0111	??
000000r 2               
000000r 2               
000000r 2                 .macro LDBBL Lit ; Load literal address into BL register
000000r 2               	.byte $C0
000000r 2               	.byte Lit
000000r 2               	.endmacro
000000r 2                 .macro LDBL Lit ; Load literal address into BW register
000000r 2               	.byte $D0
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro LDBBD Direct ; Load direct address into BL register
000000r 2               	.byte $C1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDBD Direct ; Load direct address into BW register
000000r 2               	.byte $D1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDBBI Indirect ; Load indirect address into BL register
000000r 2               	.byte $C2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDBI Indirect ; Load indirect address into BW register
000000r 2               	.byte $D2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDBBR Rel ; Load direct Program Counter offset by N address into BL register
000000r 2               	BRel $c3,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBR Rel ; Load direct Program Counter offset by N address into BW register
000000r 2               	BRel $d3,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBBRI Rel ; Load indirect Program Counter offset by N address into BL register
000000r 2               	BRel $c4,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBRI Rel ; Load indirect Program Counter offset by N address into BW register
000000r 2               	BRel $d4,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBBX WReg,Mod,Offset ; Load indexed register into BL register
000000r 2               	.byte $C5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro LDBX WReg,Mod,Offset ; Load indexed register into BW register
000000r 2               	.byte $D5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; C6	1100 0110	??
000000r 2               ;  .macro ?? ; C7	1100 0111	??
000000r 2               
000000r 2                 .macro LDBBA WReg ; Load byte from memory address stored in WReg into BL register
000000r 2               	.byte $C8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro LDBA WReg ; Load word from memory address stored in WReg into BW register
000000r 2               	.byte $D8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; D6	1101 0110	??
000000r 2               ;  .macro ?? ; D7	1101 0111	??
000000r 2               
000000r 2                 .macro STBBL Lit ; Store byte of BL register into literal address (Not possible?)
000000r 2               	.byte $E0
000000r 2               	.byte Lit
000000r 2               	.endmacro
000000r 2                 .macro STBL Lit ; Store BW into literal address (Not possible?)
000000r 2               	.byte $F0
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro STBBD Direct ; Store BL into direct address
000000r 2               	.byte $E1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STBD Direct ; Store BW into direct address
000000r 2               	.byte $F1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STBBI Indirect ; Store BL into indirect address
000000r 2               	.byte $E2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STBI Indirect ; Store BW into indirect address
000000r 2               	.byte $F2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STBBR Rel ; Store BL into direct Program Counter offset by N address
000000r 2               	BRel $e3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBR Rel ; Store BW into direct Program Counter offset by N address
000000r 2               	BRel $f3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBBRI Rel ; Store BL into indirect Program Counter offset by N address
000000r 2               	BRel $e4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBRI Rel ; Store BW into indirect Program Counter offset by N address
000000r 2               	BRel $f4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBBX WReg,Mod,Offset ; Store BL into indexed register
000000r 2               	.byte $E5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro STBX WReg,Mod,Offset ; Store BW into indexed register
000000r 2               	.byte $F5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; E6	1110 0110	??
000000r 2               ;  .macro ?? ; E7	1110 0111	??
000000r 2                 .macro STBBA WReg ; Store byte from BL register to memory address stored in WReg
000000r 2               	.byte $E8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro STBA WReg ; Store BW to memory address stored in WReg
000000r 2               	.byte $F8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; F6	1111 0110	??
000000r 2               ;  .macro ?? ; F7	1111 0111	??
000000r 2               
000000r 2               
000000r 2                 .macro LDXL Lit ; Load immediate into XW
000000r 2               	.byte $60
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro LDXD Direct ;	Load direct address into XW
000000r 2               	.byte $61
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDXI Indirect ; Load indirect address into XW
000000r 2               	.byte $62
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDXR Rel ; Load direct Program Counter offset by N address into XW
000000r 2               	BRel $63,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDXRI Rel ; Load indirect Program Counter offset by N address into XW
000000r 2               	BRel $64,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDXX WReg,Mod,Offset ; Load indexed mode register into XW
000000r 2               	.byte $65
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ??	; 66	0110 0110	??
000000r 2               ;  .macro ??	; 67	0110 0111	??
000000r 2                 .macro STXL Lit ; Store XW into literal address (Not possible?)
000000r 2               	.byte $68
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro STXD Direct ; Store XW into direct address
000000r 2               	.byte $69
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STXI Indirect ; Store XW into indirect address
000000r 2               	.byte $6A
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STXR Rel ; Store XW into direct Program Counter offset by N address
000000r 2               	BRel $6b,Rel
000000r 2               	.endmacro
000000r 2                 .macro STXRI Rel ; Store XW into indirect Program Counter offset by N address
000000r 2               	BRel $6c,Rel
000000r 2               	.endmacro
000000r 2                 .macro STXX WReg,Mod,Offset ; Store XW into indexed register
000000r 2               	.byte $6D
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ??	; 6E	0110 1110	??
000000r 2               ;  .macro ??	; 6F	0110 1111	??
000000r 2               
000000r 2               ;  .macro ??	; $70
000000r 2                 .macro JMPD Direct ; Jump to direct address
000000r 2               	.byte $71
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro JMPI Indirect ; Jump to indirect address
000000r 2               	.byte $72
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro JMPR Rel ; Jump to direct Program Counter offset by N address
000000r 2               	BRel $73,Rel
000000r 2               	.endmacro
000000r 2                 .macro JMPRI Rel ; Jump to indirect Program Counter offset by N address
000000r 2               	BRel $74,Rel
000000r 2               	.endmacro
000000r 2                 .macro JMPX WReg,Mod,Offset ;Jump to indexed mode register
000000r 2               	.byte $75
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro SYSCALL	; Call interrupt level 15
000000r 2               	.byte $76
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; 77	0111 0111	??
000000r 2               
000000r 2               ;  .macro ?? ; 78 ??
000000r 2                 .macro JSRD Direct ; Jump to subroutine at direct address
000000r 2               	.byte $79
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro JSRI Indirect ; Jump to subroutine at indirect address
000000r 2               	.byte $7A
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro JSRR Rel ; Jump to subroutine at Program Counter offset by N address
000000r 2               	BRel $7b,Rel
000000r 2               	.endmacro
000000r 2                 .macro JSRRI Rel ; Jump to subroutine at indirect Program Counter offset by N address
000000r 2               	BRel $7c,Rel
000000r 2               	.endmacro
000000r 2                 .macro JSRX WReg,Mod,Offset ; Jump to subroutine at indexed mode register
000000r 2               	.byte $7D
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro MEMCPY
000000r 2               	.byte $f7
000000r 2               	.endmacro
000000r 2               
000000r 2               
000000r 1               
000000r 1               
000000r 1               ; handy constants
000000r 1               
000000r 1               ; Sector size is a bit of a mess on Centurion.  Many devices use 400 byte sectors.
000000r 1               ;   How to map that to FORTH 1024 byte screens is unfinished.
000000r 1               SectorSize =256		; sector size in bytes
000000r 1               NBUF =1024/SectorSize	; number of buffers desired in RAM
000000r 1               			;     (SectorSize*NBUF >= 1024 bytes)
000000r 1               Sectors	=800		; sectors per drive
000000r 1               			;    forcing high drive to zero
000000r 1               SECTL	=2*Sectors	; sector limit for two drives
000000r 1               
000000r 1               
000000r 1               ; Error, Warning, and other messages - external text starting on on screens 4
000000r 1               Err_0			=  0 ; abort with no message
000000r 1               Err_StackUnderflow	=  1 ; EMPTY STACK
000000r 1               Err_DictionaryFull	=  2 ; DICTIONARY FULL
000000r 1               ; Err_3			=  3 ; HAS INCORRECT ADDRESS MODE
000000r 1               Err_IsntUnique		=  4 ; ISN'T UNIQUE
000000r 1               ;  5
000000r 1               ; Err_06 		=  6 ; DISC RANGE
000000r 1               Err_StackOverflow	=  7 ; stack overflow
000000r 1               Err_8			=  8 ; disk i/o error
000000r 1               ;  9
000000r 1               ; 10
000000r 1               ; 11
000000r 1               ; 12
000000r 1               ; 13
000000r 1               ; 14
000000r 1               Err_TriadFooter		  = 15  ; TRIAD footer message
000000r 1               ; 16
000000r 1               Err_CompileOnly		  = $11 ; COMPILATION ONLY, USE IN DEFINITION
000000r 1               Err_ExecuteOnly		  = $12 ; EXECUTION ONLY
000000r 1               Err_ConditionalsNotPaired = $13 ; CONDITIONALS NOT PAIRED
000000r 1               Err_DefinitionNotFinished = $14 ; DEFINITION NOT FINISHED
000000r 1               Err_InProtectedDictionary = $15 ; IN PROTECTED DICTIONARY
000000r 1               Err_UseOnlyWhenLoading    = $16 ; USE ONLY WHEN LOADING
000000r 1               ; $17
000000r 1               ; $18 DECLARE VOCABULARY
000000r 1               
000000r 1               
000000r 1               	.org $7000 ; more uninitialized RAM
007000  1               
007000  1               DictTop:	; From here downward to the top of the dictionary is free
007000  1               		; space where the user's applications are compiled.
007000  1               
007000  1  xx xx        VUse:	.res 2		; the address of the block buffer to use next, as the least recently written.
007002  1  xx xx        VPrev:	.res 2		; the address of the disc buffer most recently referenced.
007004  1               			;   The UPDATE command marks this buffer to be later written to disc.
007004  1               
007004  1  xx xx xx xx  TIBX:	.res 86		; terminal input buffer
007008  1  xx xx xx xx  
00700C  1  xx xx xx xx  
007010  1  xx xx xx xx  
007014  1  xx xx xx xx  
007018  1  xx xx xx xx  
00701C  1  xx xx xx xx  
007020  1  xx xx xx xx  
007024  1  xx xx xx xx  
007028  1  xx xx xx xx  
00702C  1  xx xx xx xx  
007030  1  xx xx xx xx  
007034  1  xx xx xx xx  
007038  1  xx xx xx xx  
00703C  1  xx xx xx xx  
007040  1  xx xx xx xx  
007044  1  xx xx xx xx  
007048  1  xx xx xx xx  
00704C  1  xx xx xx xx  
007050  1  xx xx xx xx  
007054  1  xx xx xx xx  
007058  1  xx xx        
00705A  1               
00705A  1  xx xx        RamDiskStart: .res 2	; RAM disk: start of memory buffer
00705C  1  xx xx        RamDiskCount: .res 2	; RAM disk: count of 256 byte blocks
00705E  1               
00705E  1               UArea:
00705E  1               VUser: ; user area variables, partially initialized from ORIG
00705E  1  xx xx        	.res 2	;+00:	ptr latest ROM word
007060  1  xx xx        VBS:	.res 2	;+02:	backspace char
007062  1  xx xx        VUA:	.res 2	;+04:	ptr user area (direct page IS the user area)
007064  1  xx xx        VS0:	.res 2	;+06:	initial value for the parameter stack index
007066  1  xx xx        VR0:	.res 2	;+08:	initial value of the return stack ptr
007068  1  xx xx        VTIB:	.res 2	;+0a:	Address of the terminal input buffer.
00706A  1  xx xx        VWidth:	.res 2	;+0c:	Maximum number of letters saved in the compilation of a definitions' name.
00706C  1               		;	It must be 1 thru 31, with a default of 31.
00706C  1               		;	The name char cound and its natural chars are saved, up to the value in WIDTH.
00706C  1               		;	The value may be changed at any time within the above limits.
00706C  1  xx xx        VWarning: .res 2 ;+0e:	Value controlling messages.  If =1 disc is present,
00706E  1               		;	and screen 4 of drive 0 is the base location for messages.
00706E  1               		;	If =0, no disc is present and messages will be presented by number.
00706E  1               		;	if =-1, execute (ABORT) for a user specified procedure.
00706E  1               		;	See MESSAGE ERROR
00706E  1  xx xx        VFence:	.res 2	;+10:	Address below which FORGETting is trapped.
007070  1               		;	To forget below this point the user must alter the contents of FENCE .
007070  1  xx xx        VDP:	.res 2	;+12:	ptr next available dictionary memory location
007072  1               		;	The value may be read by HERE and altered by ALLOT.
007072  1               
007072  1  xx xx        VVoc_Link: .res 2 ;+14:	Containing the address of a field in the definition of the most
007074  1               		;	recently created vocabulary.  All vocabulary names are linked by these fields
007074  1               		;	to allow control for FORGETting thru multiple vocabularys.
007074  1               
007074  1  xx xx        VBlk:	.res 2	;+16:	Block (not screen) number being interpreted.
007076  1               		;	If 0, input is being taken from the terminal input buffer.
007076  1               		;	https://forth-standard.org/standard/block/BLK
007076  1  xx xx        VIn:	.res 2	;+18:	Byte offset within the current input text buffer (terminal or disc)
007078  1               		;	from which the next text will be accepted.
007078  1               		;	WORD uses and moves the value of IN .
007078  1  xx xx        VOut:	.res 2	;+1A:	A value incremented by EMIT .
00707A  1               		;	The user may alter and examine OUT to control display formatting.
00707A  1  xx xx        VScr:	.res 2	;+1C:	the screen number most recently referenced by LIST .
00707C  1               		;	https://forth-standard.org/standard/block/SCR
00707C  1  xx xx        VOffset: .res 2	;+1E:	disc block offset in 1024 byte blocks
00707E  1               		;	The contents of OFFSET is added to the block number in BLOCK
00707E  1               		;	to allow for this selection.
00707E  1               		;	May contain a block offset to disc drives.  The contents
00707E  1               		;	of OFFSET is added to the stack number by BLOCK .
00707E  1               		;	Messages by MESSAGE are independent of OFFSET .
00707E  1               		;	See BLOCK DR0 DR1 MESSAGE
00707E  1               
00707E  1  xx xx        VContext: .res 2 ;+20:	pointer to the vocabulary within which dictionary searching will first begin.
007080  1               		;	ptr to dictionary head in vocabulary word
007080  1  xx xx        VCurrent: .res 2 ;+22:	ptr to dictionary head in vocabulary word
007082  1  xx xx        VState:	.res 2	;+24:	compilation state.  A non-zero value indicates compilation.
007084  1               		;	The value itself may be implementation dependent.
007084  1               		;	Contains the compilation-state flag.
007084  1               		;	STATE is true when in compilation state, false otherwise.
007084  1               		;	The true value in STATE is non-zero, but is otherwise implementation-defined.
007084  1               		;	Only the following standard words alter the value in STATE:
007084  1               		;		: (colon), ; (semicolon), ABORT, QUIT, :NONAME, [ (left-bracket), ] (right-bracket).
007084  1               		;	Note: A program shall not directly alter the contents of STATE.
007084  1  xx xx        VBase:	.res 2	;+26:	the current number base used for input and output conversion; 2..36
007086  1  xx xx        VDPL:	.res 2	;+28:	number of digits to the rights of the decimal on double integer input.
007088  1               		;	It may also be used to hold output column location of a decimal point,
007088  1               		;	in user generated formatting.
007088  1               		;	The default value on signel number input is -1 (none).
007088  1  xx xx        VFld:	.res 2	;+2A:	for control of number output field width. Presently unused in fig-FORTH.
00708A  1  xx xx        VCSP:	.res 2	;+2C:	temporarily store the stack pointer position, for compilation error checking.
00708C  1  xx xx        VRNum:	.res 2	;+2E:	may contain the location of an editing cursor, or other file related function.
00708E  1  xx xx        VHld:	.res 2	;+30:	holds the address of the latest char of text during numeric output conversion.
007090  1  xx           VLineComment: .res 1	; ignore remainder of line
007091  1               
007091  1               
007091  1  xx xx        VFPtr:	.res 2	;	Floating-point stack ptr
007093  1  xx xx        VFpLo:	.res 2	;	"                " lo limit
007095  1  xx xx        VFpHi:	.res 2	;	"                " hi limit
007097  1               
007097  1  xx xx xx xx  BOS:	.res $7e	; parameter (data) stack
00709B  1  xx xx xx xx  
00709F  1  xx xx xx xx  
0070A3  1  xx xx xx xx  
0070A7  1  xx xx xx xx  
0070AB  1  xx xx xx xx  
0070AF  1  xx xx xx xx  
0070B3  1  xx xx xx xx  
0070B7  1  xx xx xx xx  
0070BB  1  xx xx xx xx  
0070BF  1  xx xx xx xx  
0070C3  1  xx xx xx xx  
0070C7  1  xx xx xx xx  
0070CB  1  xx xx xx xx  
0070CF  1  xx xx xx xx  
0070D3  1  xx xx xx xx  
0070D7  1  xx xx xx xx  
0070DB  1  xx xx xx xx  
0070DF  1  xx xx xx xx  
0070E3  1  xx xx xx xx  
0070E7  1  xx xx xx xx  
0070EB  1  xx xx xx xx  
0070EF  1  xx xx xx xx  
0070F3  1  xx xx xx xx  
0070F7  1  xx xx xx xx  
0070FB  1  xx xx xx xx  
0070FF  1  xx xx xx xx  
007103  1  xx xx xx xx  
007107  1  xx xx xx xx  
00710B  1  xx xx xx xx  
00710F  1  xx xx xx xx  
007113  1  xx xx        
007115  1  xx xx xx xx  TOS:	.res 8		; top of parameter stack, with extra padding
007119  1  xx xx xx xx  
00711D  1               
00711D  1               ;N:	.res 8		; scratch workspace.
00711D  1               
00711D  1  xx xx xx xx  RStack:	.res 128	; return stack
007121  1  xx xx xx xx  
007125  1  xx xx xx xx  
007129  1  xx xx xx xx  
00712D  1  xx xx xx xx  
007131  1  xx xx xx xx  
007135  1  xx xx xx xx  
007139  1  xx xx xx xx  
00713D  1  xx xx xx xx  
007141  1  xx xx xx xx  
007145  1  xx xx xx xx  
007149  1  xx xx xx xx  
00714D  1  xx xx xx xx  
007151  1  xx xx xx xx  
007155  1  xx xx xx xx  
007159  1  xx xx xx xx  
00715D  1  xx xx xx xx  
007161  1  xx xx xx xx  
007165  1  xx xx xx xx  
007169  1  xx xx xx xx  
00716D  1  xx xx xx xx  
007171  1  xx xx xx xx  
007175  1  xx xx xx xx  
007179  1  xx xx xx xx  
00717D  1  xx xx xx xx  
007181  1  xx xx xx xx  
007185  1  xx xx xx xx  
007189  1  xx xx xx xx  
00718D  1  xx xx xx xx  
007191  1  xx xx xx xx  
007195  1  xx xx xx xx  
007199  1  xx xx xx xx  
00719D  1               RStackE:
00719D  1               
00719D  1               UserSize: ; end of user ara variables
00719D  1               ;	.assert <*<$100, error, "user area overflowed"
00719D  1               
00719D  1               
00719D  1               
00719D  1  xx xx xx xx  RndState: .res 4	; random # state
0071A1  1               
0071A1  1  xx xx xx xx  DArea:	.res (SectorSize+4)*NBUF ; disk buffer space.
0071A5  1  xx xx xx xx  
0071A9  1  xx xx xx xx  
0071AD  1  xx xx xx xx  
0071B1  1  xx xx xx xx  
0071B5  1  xx xx xx xx  
0071B9  1  xx xx xx xx  
0071BD  1  xx xx xx xx  
0071C1  1  xx xx xx xx  
0071C5  1  xx xx xx xx  
0071C9  1  xx xx xx xx  
0071CD  1  xx xx xx xx  
0071D1  1  xx xx xx xx  
0071D5  1  xx xx xx xx  
0071D9  1  xx xx xx xx  
0071DD  1  xx xx xx xx  
0071E1  1  xx xx xx xx  
0071E5  1  xx xx xx xx  
0071E9  1  xx xx xx xx  
0071ED  1  xx xx xx xx  
0071F1  1  xx xx xx xx  
0071F5  1  xx xx xx xx  
0071F9  1  xx xx xx xx  
0071FD  1  xx xx xx xx  
007201  1  xx xx xx xx  
007205  1  xx xx xx xx  
007209  1  xx xx xx xx  
00720D  1  xx xx xx xx  
007211  1  xx xx xx xx  
007215  1  xx xx xx xx  
007219  1  xx xx xx xx  
00721D  1  xx xx xx xx  
007221  1  xx xx xx xx  
007225  1  xx xx xx xx  
007229  1  xx xx xx xx  
00722D  1  xx xx xx xx  
007231  1  xx xx xx xx  
007235  1  xx xx xx xx  
007239  1  xx xx xx xx  
00723D  1  xx xx xx xx  
007241  1  xx xx xx xx  
007245  1  xx xx xx xx  
007249  1  xx xx xx xx  
00724D  1  xx xx xx xx  
007251  1  xx xx xx xx  
007255  1  xx xx xx xx  
007259  1  xx xx xx xx  
00725D  1  xx xx xx xx  
007261  1  xx xx xx xx  
007265  1  xx xx xx xx  
007269  1  xx xx xx xx  
00726D  1  xx xx xx xx  
007271  1  xx xx xx xx  
007275  1  xx xx xx xx  
007279  1  xx xx xx xx  
00727D  1  xx xx xx xx  
007281  1  xx xx xx xx  
007285  1  xx xx xx xx  
007289  1  xx xx xx xx  
00728D  1  xx xx xx xx  
007291  1  xx xx xx xx  
007295  1  xx xx xx xx  
007299  1  xx xx xx xx  
00729D  1  xx xx xx xx  
0072A1  1  xx xx xx xx  
0072A5  1  xx xx xx xx  
0072A9  1  xx xx xx xx  
0072AD  1  xx xx xx xx  
0072B1  1  xx xx xx xx  
0072B5  1  xx xx xx xx  
0072B9  1  xx xx xx xx  
0072BD  1  xx xx xx xx  
0072C1  1  xx xx xx xx  
0072C5  1  xx xx xx xx  
0072C9  1  xx xx xx xx  
0072CD  1  xx xx xx xx  
0072D1  1  xx xx xx xx  
0072D5  1  xx xx xx xx  
0072D9  1  xx xx xx xx  
0072DD  1  xx xx xx xx  
0072E1  1  xx xx xx xx  
0072E5  1  xx xx xx xx  
0072E9  1  xx xx xx xx  
0072ED  1  xx xx xx xx  
0072F1  1  xx xx xx xx  
0072F5  1  xx xx xx xx  
0072F9  1  xx xx xx xx  
0072FD  1  xx xx xx xx  
007301  1  xx xx xx xx  
007305  1  xx xx xx xx  
007309  1  xx xx xx xx  
00730D  1  xx xx xx xx  
007311  1  xx xx xx xx  
007315  1  xx xx xx xx  
007319  1  xx xx xx xx  
00731D  1  xx xx xx xx  
007321  1  xx xx xx xx  
007325  1  xx xx xx xx  
007329  1  xx xx xx xx  
00732D  1  xx xx xx xx  
007331  1  xx xx xx xx  
007335  1  xx xx xx xx  
007339  1  xx xx xx xx  
00733D  1  xx xx xx xx  
007341  1  xx xx xx xx  
007345  1  xx xx xx xx  
007349  1  xx xx xx xx  
00734D  1  xx xx xx xx  
007351  1  xx xx xx xx  
007355  1  xx xx xx xx  
007359  1  xx xx xx xx  
00735D  1  xx xx xx xx  
007361  1  xx xx xx xx  
007365  1  xx xx xx xx  
007369  1  xx xx xx xx  
00736D  1  xx xx xx xx  
007371  1  xx xx xx xx  
007375  1  xx xx xx xx  
007379  1  xx xx xx xx  
00737D  1  xx xx xx xx  
007381  1  xx xx xx xx  
007385  1  xx xx xx xx  
007389  1  xx xx xx xx  
00738D  1  xx xx xx xx  
007391  1  xx xx xx xx  
007395  1  xx xx xx xx  
007399  1  xx xx xx xx  
00739D  1  xx xx xx xx  
0073A1  1  xx xx xx xx  
0073A5  1  xx xx xx xx  
0073A9  1  xx xx xx xx  
0073AD  1  xx xx xx xx  
0073B1  1  xx xx xx xx  
0073B5  1  xx xx xx xx  
0073B9  1  xx xx xx xx  
0073BD  1  xx xx xx xx  
0073C1  1  xx xx xx xx  
0073C5  1  xx xx xx xx  
0073C9  1  xx xx xx xx  
0073CD  1  xx xx xx xx  
0073D1  1  xx xx xx xx  
0073D5  1  xx xx xx xx  
0073D9  1  xx xx xx xx  
0073DD  1  xx xx xx xx  
0073E1  1  xx xx xx xx  
0073E5  1  xx xx xx xx  
0073E9  1  xx xx xx xx  
0073ED  1  xx xx xx xx  
0073F1  1  xx xx xx xx  
0073F5  1  xx xx xx xx  
0073F9  1  xx xx xx xx  
0073FD  1  xx xx xx xx  
007401  1  xx xx xx xx  
007405  1  xx xx xx xx  
007409  1  xx xx xx xx  
00740D  1  xx xx xx xx  
007411  1  xx xx xx xx  
007415  1  xx xx xx xx  
007419  1  xx xx xx xx  
00741D  1  xx xx xx xx  
007421  1  xx xx xx xx  
007425  1  xx xx xx xx  
007429  1  xx xx xx xx  
00742D  1  xx xx xx xx  
007431  1  xx xx xx xx  
007435  1  xx xx xx xx  
007439  1  xx xx xx xx  
00743D  1  xx xx xx xx  
007441  1  xx xx xx xx  
007445  1  xx xx xx xx  
007449  1  xx xx xx xx  
00744D  1  xx xx xx xx  
007451  1  xx xx xx xx  
007455  1  xx xx xx xx  
007459  1  xx xx xx xx  
00745D  1  xx xx xx xx  
007461  1  xx xx xx xx  
007465  1  xx xx xx xx  
007469  1  xx xx xx xx  
00746D  1  xx xx xx xx  
007471  1  xx xx xx xx  
007475  1  xx xx xx xx  
007479  1  xx xx xx xx  
00747D  1  xx xx xx xx  
007481  1  xx xx xx xx  
007485  1  xx xx xx xx  
007489  1  xx xx xx xx  
00748D  1  xx xx xx xx  
007491  1  xx xx xx xx  
007495  1  xx xx xx xx  
007499  1  xx xx xx xx  
00749D  1  xx xx xx xx  
0074A1  1  xx xx xx xx  
0074A5  1  xx xx xx xx  
0074A9  1  xx xx xx xx  
0074AD  1  xx xx xx xx  
0074B1  1  xx xx xx xx  
0074B5  1  xx xx xx xx  
0074B9  1  xx xx xx xx  
0074BD  1  xx xx xx xx  
0074C1  1  xx xx xx xx  
0074C5  1  xx xx xx xx  
0074C9  1  xx xx xx xx  
0074CD  1  xx xx xx xx  
0074D1  1  xx xx xx xx  
0074D5  1  xx xx xx xx  
0074D9  1  xx xx xx xx  
0074DD  1  xx xx xx xx  
0074E1  1  xx xx xx xx  
0074E5  1  xx xx xx xx  
0074E9  1  xx xx xx xx  
0074ED  1  xx xx xx xx  
0074F1  1  xx xx xx xx  
0074F5  1  xx xx xx xx  
0074F9  1  xx xx xx xx  
0074FD  1  xx xx xx xx  
007501  1  xx xx xx xx  
007505  1  xx xx xx xx  
007509  1  xx xx xx xx  
00750D  1  xx xx xx xx  
007511  1  xx xx xx xx  
007515  1  xx xx xx xx  
007519  1  xx xx xx xx  
00751D  1  xx xx xx xx  
007521  1  xx xx xx xx  
007525  1  xx xx xx xx  
007529  1  xx xx xx xx  
00752D  1  xx xx xx xx  
007531  1  xx xx xx xx  
007535  1  xx xx xx xx  
007539  1  xx xx xx xx  
00753D  1  xx xx xx xx  
007541  1  xx xx xx xx  
007545  1  xx xx xx xx  
007549  1  xx xx xx xx  
00754D  1  xx xx xx xx  
007551  1  xx xx xx xx  
007555  1  xx xx xx xx  
007559  1  xx xx xx xx  
00755D  1  xx xx xx xx  
007561  1  xx xx xx xx  
007565  1  xx xx xx xx  
007569  1  xx xx xx xx  
00756D  1  xx xx xx xx  
007571  1  xx xx xx xx  
007575  1  xx xx xx xx  
007579  1  xx xx xx xx  
00757D  1  xx xx xx xx  
007581  1  xx xx xx xx  
007585  1  xx xx xx xx  
007589  1  xx xx xx xx  
00758D  1  xx xx xx xx  
007591  1  xx xx xx xx  
007595  1  xx xx xx xx  
007599  1  xx xx xx xx  
00759D  1  xx xx xx xx  
0075A1  1  xx xx xx xx  
0075A5  1  xx xx xx xx  
0075A9  1  xx xx xx xx  
0075AD  1  xx xx xx xx  
0075B1  1               DAreaEnd:
0075B1  1               
0075B1  1               
0075B1  1               
0075B1  1               INL_End = $0909	; RSR, & ha_inline code end marker
0075B1  1               
0075B1  1               ; Bit masks in "flags & length" byte of word header:
0075B1  1               ha_inline    = $80 ; can be compiled by copying inline
0075B1  1               ha_immediate = $40 ; aka precedence bit
0075B1  1               ha_smudge    = $20 ; do not find this word by name
0075B1  1               ha_length    = $1f ; # of chars in name (including ones > vWidth)
0075B1  1               
0075B1  1                 .macro FHdr name,flags ; compile a FORTH word header
0075B1  1               	.local L1,L2
0075B1  1               L1:	.byte name	;name of word as a string (no leading count byte)
0075B1  1               L2:	.byte L2-L1+flags ;flags & length of name (see ha_*)
0075B1  1               	.dbyt DictLink	;LFA: link to previous word's CFA in vocabulary chain
0075B1  1               DictLink .set *
0075B1  1               ;		The fields above are at negative offsets from label.
0075B1  1               ;label:	;NFA: same as CFA.  We access header fields using negative offsets from CFA.
0075B1  1               ;	;CFA: CPU6 code starts here.  This is the address that "find" returns.
0075B1  1               ;		Words that want PFA (eg CREATEd words) will have a JSR to the handler code,
0075B1  1               ;		  followed by the PFA area.  The JSR return address (+1) points to the PFA.
0075B1  1               	.endmacro
0075B1  1               
0075B1  1               DictLink .set 0 ; used to build the FHdr link chain.
0075B1  1               		; 0 indicates end of vocabulary list
0075B1  1               
0075B1  1               ; The FHdr line of each entry shows a symbolic description of the action of the procedure
0075B1  1               ; on the parameter stack.  The symbols indicate the order in which input parameters have
0075B1  1               ; been placed on the stack.  "---" indicate the execution point; any parameters left on the
0075B1  1               ; stack are listed after.  In this notation, the top of the stack is to the right.
0075B1  1               ;
0075B1  1               ; The symbols include:
0075B1  1               ;
0075B1  1               ; addr	memory address
0075B1  1               ; b	8 bit byte (i.e. hi 8  bits zero)
0075B1  1               ; c	ASCII character (hi 9 bits zero)
0075B1  1               ; d	32 bit signed double integer, most significant portion with sign on top of stack.
0075B1  1               ; f	boolean flag. 0=false, non-zero=true
0075B1  1               ; ff	boolean false flag=0
0075B1  1               ; n	16 bit signed integer number
0075B1  1               ; u	16 bit unsigned integer
0075B1  1               ; tf	boolean true flag (non-zero)
0075B1  1               ;
0075B1  1               ; The capital letters on the right show definition characteristics:
0075B1  1               ;   (not used)
0075B1  1               ; C	May only be used within a colon definition. A digit indicates number of memory
0075B1  1               ;	addresses used, if other than one.
0075B1  1               ; E	intended for execution only.
0075B1  1               ; L0	Level Zero definition of FORTH-78
0075B1  1               ; L1	Level One definition of FORTH-78
0075B1  1               ; P	Has precedence bit (immediate) set. Will execute even when compliling.
0075B1  1               ; U	A user variable.
0075B1  1               ;
0075B1  1               ; Unless otherwise noted, all references to numbers are for 16 bit signed integers.
0075B1  1               ; 16 bit numbers are big-endian, like the hardware.
0075B1  1               ; For 32 bit signed double numbers, the most significant part (with the sign) is on top.
0075B1  1               ;
0075B1  1               ; All arithmetic is implicitly 16 bit signed integer math, with error and underflow
0075B1  1               ; indication unspecified.
0075B1  1               
0075B1  1               
0075B1  1               	.org $200 ; start of program RAM ==========================================================
000200  1               ORIG:	; Start of boot up parameters.  34 bytes.
000200  1               
000200  1  01           Enter:	NOPC		; +00 User cold entry point
000201  1  71 17 C1     	JMPD Cold
000204  1  01           ReEnter: NOPC		; +04 User warm entry point
000205  1  71 17 CF     	JMPD Warm
000208  1  00 00 00 00  	.dbyt 0,0	; +08 CPU6 in radix-36
00020C  1               
00020C  1               ; Initial values copied to VUser.
00020C  1               ; These values are altered as you make permanent extensions to your installation.
00020C  1  1E 76        	.dbyt NTOP	; +0C Last word
00020E  1  00 08        	.dbyt $08	; +0E Backspace Character
000210  1  70 5E        	.dbyt UArea	; +10 Initial User Area
000212  1  71 15        	.dbyt TOS	; +12 S0 - Initial Top of Stack (in user area)
000214  1  71 9D        	.dbyt RStackE	; +14 R0 - Initial Top of Return Stack
000216  1  70 04        	.dbyt TIBX	; +16 Initial terminal input buffer
000218  1  00 1F        	.dbyt 31	; +18 Initial name field width (not used)
00021A  1  00 00        	.dbyt 0		; +1A Initial warning
00021C  1  1E E3        	.dbyt TOP	; +1C Initial fence address
00021E  1  1E E3        	.dbyt TOP	; +1E Initial top of dictionary
000220  1  16 FA        	.dbyt Forth+3+2	; +20 Initial Vocabulary link ptr.
000222  1               
000222  1               
000222  1  45 6D 70 74   FHdr 'Empty-RStack',0 ; ( -- ) ( R: ... -- )  empty the return stack (load from user variable R0 ) .
000226  1  79 2D 52 53  
00022A  1  74 61 63 6B  
00022E  1  0C 00 00     
000231  1               EmptyRStack:
000231  1  91 70 66     	LDAD VR0	; load S
000234  1  5F           	XAS
000235  1  75 40        	JMPX XW,ModBRB,0 ; return (without adjusting S)
000237  1               
000237  1               
000237  1               	.if 0
000237  1                FHdr 'RP!',0 ; ( -- )  FIG alias
000237  1               	JMPR EmptyRStack
000237  1               	.endif
000237  1               
000237  1               
000237  1               	.if 0
000237  1                FHdr 'RDepth',0 ; ( -- n )  return # of cells on return stack (not including this routine)
000237  1               	LDAD VR0
000237  1               	SUB AW,SW
000237  1               	INR AW,2
000237  1               	JMPR Depth3
000237  1               	.endif
000237  1               
000237  1               
000237  1  45 6D 70 74   FHdr 'Empty-Stack',0 ; ( ... -- )  empty the param stack.
00023B  1  79 2D 53 74  
00023F  1  61 63 6B 0B  
000243  1  02 31        
000245  1               EmptyStack:
000245  1  91 70 64     	LDAD VS0		; load the parameter stack pointer from S0
000248  1  5E           	XAZ
000249  1  D1 70 95     	LDBD VFpHi		; also empty FP stack
00024C  1  F1 70 91     	STBD VFPtr
00024F  1  09           	RSR
000250  1               
000250  1               
000250  1               	.if 0
000250  1                FHdr 'SP!',0 ; ( -- )  FIG alias
000250  1               	JMPR EmptyStack
000250  1               	.endif
000250  1               
000250  1               
000250  1  44 65 70 74   FHdr 'Depth',0 ; ( -- n )  https://forth-standard.org/standard/core/DEPTH
000254  1  68 05 02 45  
000258  1               ; Return the address of the stack position to the top of the stack, as it was before Depth was executed.
000258  1               ; (e.g. 1 2 Depth  . . .  would type 2 2 1 )
000258  1  91 70 64     Depth:	LDAD VS0
00025B  1  51 80        	SUB AW,ZW
00025D  1  33 01        Depth3:	IVR AW,1		; A = VS0-param_stack_ptr
00025F  1  3C           	SRA			; /2
000260  1  B5 82        	STAX ZW,ModBMRB,0	; push it
000262  1  09           	RSR			; return
000263  1               
000263  1               
000263  1               	.if 0
000263  1                FHdr 'SP@',0 ; ( -- n )  FIG alias
000263  1               	JMPR Depth
000263  1               	.endif
000263  1               
000263  1               
000263  1  44 72 6F 70   FHdr 'Drop',ha_inline ; ( n -- )  Drop a number from the stack.
000267  1  84 02 58     
00026A  1                  ; https://forth-standard.org/standard/core/DROP
00026A  1  30 81        Drop:	INR ZW,2		; bump the param stack index up 1 cell
00026C  1  09 09        	.dbyt INL_End		; return
00026E  1               
00026E  1               
00026E  1  32 44 72 6F   FHdr '2Drop',ha_inline ; ( n n -- )
000272  1  70 85 02 6A  
000276  1                  ; https://forth-standard.org/standard/core/TwoDROP
000276  1               TwoDrop:
000276  1  30 83        	INR ZW,4		; bump the param stack index up 2 cells
000278  1  09 09        	.dbyt INL_End		; return
00027A  1               
00027A  1               
00027A  1  52 6F 74 03   FHdr 'Rot',0 ; ( n1 n2 n3 -- n2 n3 n1 )  https://forth-standard.org/standard/core/ROT
00027E  1  02 76        
000280  1                  ; Rotate the top 3 values on the stack, bringing the 3rd to the top.
000280  1                  ; https://forth-standard.org/standard/core/ROT
000280  1  95 88 04     Rot:	LDAX ZW,ModNBRB,4	; Y=n1
000283  1  D5 88 02     	LDBX ZW,ModNBRB,2	; A=n2
000286  1  F5 88 04     	STBX ZW,ModNBRB,4	; store 3rd-on-stack
000289  1  DC           	LDBA ZW			; A=n1
00028A  1  F5 88 02     	STBX ZW,ModNBRB,2	; store next-on-stack
00028D  1  BC           	STAA ZW			; store top-on-stack
00028E  1  09           	RSR			; return
00028F  1               
00028F  1               
00028F  1               	.if 1
00028F  1  2D 52 6F 74   FHdr '-Rot',0 ; ( n1 n2 n3 -- n3 n1 n2 )  rotate the other way
000293  1  04 02 80     
000296  1               MRot:	; small but slow
000296  1  7B E8        	JSRR Rot
000298  1  73 E6        	JMPR Rot
00029A  1               	.endif
00029A  1               
00029A  1               
00029A  1               	.if 0
00029A  1                FHdr '2Rot',0 ; ( d1 d2 d3 -- d2 d3 d1 )  Rotate the top 3 values on the stack
00029A  1                  ; https://forth-standard.org/standard/double/TwoROT
00029A  1               TwoRot:	DCR ZW,2		; do hi word
00029A  1               	JSRR @10
00029A  1               	INR ZW,2		; do lo word
00029A  1               @10:	LDAX ZW,ModNBRB,8+2	; Y=n1
00029A  1               	LDBX ZW,ModNBRB,4+2	; A=n2
00029A  1               	STBX ZW,ModNBRB,8+2	; store 3rd-on-stack
00029A  1               	LDBX ZW,ModNBRB,0+2	; A=n1
00029A  1               	STBX ZW,ModNBRB,4+2	; store next-on-stack
00029A  1               	STAX ZW,ModNBRB,0+2	; store top-on-stack
00029A  1               	RSR			; return
00029A  1               	.endif
00029A  1               
00029A  1               
00029A  1               	.if 0
00029A  1                FHdr 'Roll',0 ; ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
00029A  1                  ; Remove u. Rotate u+1 items on the top of the stack.
00029A  1                  ; An ambiguous condition exists if there are less than u+2 items on the stack before ROLL is executed.
00029A  1                  ; https://forth-standard.org/standard/core/ROLL
00029A  1               Roll:	JSRD ABort ;???
00029A  1               	.endif
00029A  1               
00029A  1               
00029A  1  53 77 61 70   FHdr 'Swap',0 ; ( n1 n2 -- n2 n1 )  Exchange the top 2 values on the stack.
00029E  1  04 02 96     
0002A1  1                  ; https://forth-standard.org/standard/core/SWAP
0002A1  1  D5 81        Swap:	LDBX ZW,ModBRPB,0	; B=n2
0002A3  1  9C           	LDAA ZW			; A=n1
0002A4  1  FC           	STBA ZW			; store next-on-stack
0002A5  1  B5 82        	STAX ZW,ModBMRB,0	; store top-on-stack
0002A7  1  09           	RSR			; return
0002A8  1               
0002A8  1               
0002A8  1  32 53 77 61   FHdr '2Swap',0 ; ( d1 d2 -- d2 d1 )  Exchange top 2 double values on the stack.
0002AC  1  70 05 02 A1  
0002B0  1                  ; https://forth-standard.org/standard/core/TwoSWAP
0002B0  1               TwoSwap:
0002B0  1  D5 88 06     	LDBX ZW,ModNBRB,6	; swap lo words
0002B3  1  95 88 02     	LDAX ZW,ModNBRB,2
0002B6  1  F5 88 02     	STBX ZW,ModNBRB,2
0002B9  1  B5 88 06     	STAX ZW,ModNBRB,6
0002BC  1  D5 88 04     	LDBX ZW,ModNBRB,4	; swap hi words
0002BF  1  9C           	LDAA ZW
0002C0  1  FC           	STBA ZW
0002C1  1  B5 88 04     	STAX ZW,ModNBRB,4
0002C4  1  09           	RSR			; return
0002C5  1               
0002C5  1               
0002C5  1  4F 76 65 72   FHdr 'Over',ha_inline ; ( n1 n2 -- n1 n2 n1 )  Copy the second stack value, placing it as the new top.
0002C9  1  84 02 B0     
0002CC  1                  ; https://forth-standard.org/standard/core/OVER
0002CC  1  95 88 02     Over:	LDAX ZW,ModNBRB,2	; get next-on-stack
0002CF  1  B5 82        	STAX ZW,ModBMRB,0	; push it
0002D1  1  09 09        	.dbyt INL_End		; return
0002D3  1               
0002D3  1               
0002D3  1  32 4F 76 65   FHdr '2Over',0 ; ( d1 d2 -- d1 d2 d1 )  Copy the 2nd double value
0002D7  1  72 05 02 CC  
0002DB  1                  ; https://forth-standard.org/standard/core/TwoOVER
0002DB  1               TwoOver:
0002DB  1  D5 88 04     	LDBX ZW,ModNBRB,4	; get d1.hi word
0002DE  1  95 88 06     	LDAX ZW,ModNBRB,6	; get d1.lo word
0002E1  1  73 16        	JMPR PushBA
0002E3  1               
0002E3  1               
0002E3  1  44 75 70 83   FHdr 'Dup',ha_inline ; ( n1 -- n1 n1 )  Duplicate the value on the stack.
0002E7  1  02 DB        
0002E9  1                  ; https://forth-standard.org/standard/core/DUP
0002E9  1  9C           Dup:	LDAA ZW
0002EA  1  B5 82        PushA:	STAX ZW,ModBMRB,0 ; pushes AW register to the param stack.
0002EC  1  09 09        	.dbyt INL_End
0002EE  1               
0002EE  1               
0002EE  1  32 44 75 70   FHdr '2Dup',0 ; ( d1 -- d1 d1 )  Duplicate double value o the stack.
0002F2  1  04 02 E9     
0002F5  1                  ; https://forth-standard.org/standard/core/TwoDUP
0002F5  1  DC           TwoDup:	LDBA ZW			; get hi word
0002F6  1  95 88 02     	LDAX ZW,ModNBRB,2	; get lo word
0002F9  1  B5 82        PushBA:	STAX ZW,ModBMRB,0	; push lo word
0002FB  1  F5 82        	STBX ZW,ModBMRB,0	; push hi word
0002FD  1  09           	RSR
0002FE  1               
0002FE  1               
0002FE  1  3F 44 75 70   FHdr '?Dup',0	; ( n1 -- n1    ) (if zero)
000302  1  04 02 F5     
000305  1               		; ( n1 -- n1 n1 ) (non-zero)
000305  1                  ; Reproduce n1 only if it is non-zero.  This is usually used to copy a
000305  1                  ; value just before IF, to eliminate the need for an ELSE part to drop it.
000305  1                  ; https://forth-standard.org/standard/core/qDUP
000305  1  9C           QDup:	LDAA ZW			; n1<>0?
000306  1  15 E2        	BNZ PushA		;   push it & return
000308  1  09           	RSR			; return
000309  1               
000309  1               
000309  1               	.if 0
000309  1                FHdr '-Dup',0	; FIG alias
000309  1               	JMPR QDup
000309  1               	.endif
000309  1               
000309  1               
000309  1               	.if 1
000309  1  50 69 63 6B   FHdr 'Pick',0 ; ( xu...x1 x0 u -- xu...x1 x0 xu )  Remove u. Copy the xu to the top of the stack.
00030D  1  04 03 05     
000310  1                  ; An ambiguous condition exists if there are less than u+2 items on the stack before PICK is executed.
000310  1                  ; https://forth-standard.org/standard/core/PICK
000310  1  9C           	LDAA ZW			; get u
000311  1  38           	INA
000312  1  3D           	SLA
000313  1  50 80        	ADD AW,ZW
000315  1  98           	LDAA AW
000316  1  BC           	STAA ZW
000317  1  09           	RSR
000318  1               	.endif
000318  1               
000318  1               
000318  1  4E 69 70 83   FHdr 'Nip',ha_inline ; ( n1 n2 -- n2 )   Drop the first item below the top of stack.
00031C  1  03 10        
00031E  1                  ; https://forth-standard.org/standard/core/NIP
00031E  1  95 81        Nip:	LDAX ZW,ModBRPB,0	; pop n2
000320  1  BC           Nip3:	STAA ZW			; store as top-of-stack
000321  1  09 09        	.dbyt INL_End		; return
000323  1               
000323  1               
000323  1  32 4E 69 70   FHdr '2Nip',0 ; ( d1 d2 -- d2 )
000327  1  04 03 1E     
00032A  1  D5 81        TwoNip:	LDBX ZW,ModBRPB,0	; pop d2.hi
00032C  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
00032E  1  FC           	STBA ZW			; store d.hi
00032F  1  B5 88 02     	STAX ZW,ModNBRB,2	; store d.lo
000332  1  09           	RSR
000333  1               
000333  1               
000333  1               	.if 1
000333  1  54 75 63 6B   FHdr 'Tuck',0 ; ( x1 x2 -- x2 x1 x2 )
000337  1  04 03 2A     
00033A  1                  ; Copy the first (top) stack item below the second stack item.
00033A  1                  ; https://forth-standard.org/standard/core/TUCK
00033A  1  95 81        Tuck:	LDAX ZW,ModBRPB,0	; pop x2
00033C  1  DC           	LDBA ZW			; get x1
00033D  1  BC           	STAA ZW
00033E  1  F5 82        	STBX ZW,ModBMRB,0
000340  1  B5 82        	STAX ZW,ModBMRB,0
000342  1  09           	RSR
000343  1               	.endif
000343  1               
000343  1               
000343  1  4D 69 6E 03   FHdr 'Min',0 ; ( n1 n2 -- n3 )	Leave the smaller of two numbers.
000347  1  03 3A        
000349  1                  ; https://forth-standard.org/standard/core/MIN
000349  1  95 81        Min:	LDAX ZW,ModBRPB,0	; pop n2
00034B  1  DC           	LDBA ZW			; get n1
00034C  1  59           	SAB			; B=A-B
00034D  1  12 0F        	BF Max3			; overflow?
00034F  1  16 CF        Min3:	BM Nip3			; keep n2, return
000351  1  09           	RSR			; return
000352  1               
000352  1               
000352  1  4D 61 78 03   FHdr 'Max',0 ; ( n1 n2 -- n3 )	Leave the greater of two numbers.
000356  1  03 49        
000358  1                  ; https://forth-standard.org/standard/core/MAX
000358  1  95 81        Max:	LDAX ZW,ModBRPB,0	; pop n2
00035A  1  DC           	LDBA ZW			; get n1
00035B  1  59           	SAB			; B=A-B
00035C  1  12 F1        	BF Min3			; overflow?
00035E  1  17 C0        Max3:	BP Nip3			; keep n2, return
000360  1  09           	RSR			; return
000361  1               
000361  1               
000361  1  44 4D 61 78   FHdr 'DMax',0 ; ( d1 d2 -- d )
000365  1  04 03 58     
000368  1                  ; https://forth-standard.org/standard/double/DMAX
000368  1  95 81        DMax:	LDAX ZW,ModBRPB,0	; pop d2.hi
00036A  1  5C           	XAY
00036B  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
00036D  1  DC           	LDBA ZW			; get d1.hi
00036E  1  51 62        	SUB BW,YW		; compare hi words
000370  1  15 07        	BNZ @3
000372  1  D5 88 02     	LDBX ZW,ModNBRB,2	; get d1.lo
000375  1  59           	SAB
000376  1  10 05        	BL DMax7
000378  1  09           	RSR
000379  1               
000379  1  12 23        @3:	BF DMin3
00037B  1  16 06        DMax3:	BM DMax9
00037D  1  55 62        DMax7:	XFR BW,YW		; store d.hi
00037F  1  FC           	STBA ZW
000380  1  B5 88 02     	STAX ZW,ModNBRB,2	; store d.lo
000383  1  09           DMax9:	RSR
000384  1               
000384  1               
000384  1  44 4D 69 6E   FHdr 'DMin',0 ; ( d1 d2 -- d )
000388  1  04 03 68     
00038B  1                  ; https://forth-standard.org/standard/double/DMIN
00038B  1  95 81        DMin:	LDAX ZW,ModBRPB,0	; pop d2.hi
00038D  1  5C           	XAY
00038E  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
000390  1  DC           	LDBA ZW			; get d1.hi
000391  1  51 62        	SUB BW,YW		; compare hi words
000393  1  15 07        	BNZ @3
000395  1  D5 88 02     	LDBX ZW,ModNBRB,2	; get d1.lo
000398  1  59           	SAB
000399  1  11 E2        	BNL DMax7
00039B  1  09           	RSR
00039C  1               
00039C  1  12 DD        @3:	BF DMax3
00039E  1  16 DD        DMin3:	BM DMax7
0003A0  1  09           	RSR
0003A1  1               
0003A1  1               
0003A1  1               	.if 0
0003A1  1                FHdr 'Within',0 ; ( n1 | u1 n2 | u2 n3 | u3 -- flag )
0003A1  1                  ; Perform a comparison of a test value n1 | u1 with a lower limit n2 | u2 and an upper limit n3 | u3,
0003A1  1                  ; returning true if either (n2 | u2 < n3 | u3 and (n2 | u2 <= n1 | u1 and n1 | u1 < n3 | u3)) or
0003A1  1                  ; (n2 | u2 > n3 | u3 and (n2 | u2 <= n1 | u1 or n1 | u1 < n3 | u3)) is true, returning false otherwise.
0003A1  1                  ; An ambiguous condition exists n1 | u1, n2 | u2, and n3 | u3 are not all the same type.
0003A1  1                  ; https://forth-standard.org/standard/core/WITHIN
0003A1  1               Within:	JSRD Abort ;???
0003A1  1               	.endif
0003A1  1               
0003A1  1               
0003A1  1               ; Note that top-of-return-stack lives in X in the calling routine,
0003A1  1               ; so inline code is not R@="LDAA SW", >R="STAX SW,ModBMRB,0", R>="LDAX SW,ModBRPB,0"
0003A1  1               
0003A1  1  52 40 02 03   FHdr 'R@',0 ; ( R: n -- n ) ( -- n )  Copy the top of the return stack to the param stack.
0003A5  1  8B           
0003A6  1                  ; https://forth-standard.org/standard/core/RFetch
0003A6  1  9D           RAt:	LDAA SW			; get top of return stack of my caller
0003A7  1  B5 82        	STAX ZW,ModBMRB,0	; push it
0003A9  1  09           	RSR			; return
0003AA  1               
0003AA  1               	.if 0
0003AA  1                FHdr 'R',0 ; ( -- n )  FIG alias
0003AA  1               	JMPR RAt
0003AA  1               	.endif
0003AA  1               
0003AA  1               
0003AA  1  52 3E 02 03   FHdr 'R>',0 ; ( R: n -- ) ( -- n )  https://forth-standard.org/standard/core/Rfrom
0003AE  1  A6           
0003AF  1                  ; Remove the top value from the return stack and leave it on the param stack.
0003AF  1                  ; See >R and R@
0003AF  1  95 A1        RFrom:	LDAX SW,ModBRPB,0	; pop return stack, skipping my return addr in X
0003B1  1  B5 82        	STAX ZW,ModBMRB,0	; push n
0003B3  1  09           	RSR
0003B4  1               
0003B4  1               
0003B4  1  3E 52 02 03   FHdr '>R',0 ; ( n -- ) ( R: -- n )   https://forth-standard.org/standard/core/toR
0003B8  1  AF           
0003B9  1                  ; Remove a numbef from the computation stack and place as the most accessable
0003B9  1                  ; on the return stack.  Use should be balanced with R> in the same definition.
0003B9  1                  ; https://forth-standard.org/standard/core/toR
0003B9  1  95 81        ToR:	LDAX ZW,ModBRPB,0	; pop n
0003BB  1  B5 A2        	STAX SW,ModBMRB,0	; push n on return stack
0003BD  1  09           	RSR
0003BE  1               
0003BE  1               
0003BE  1  32 3E 52 03   FHdr '2>R',0 ; ( d -- ) ( R: -- d )
0003C2  1  03 B9        
0003C4  1                  ; https://forth-standard.org/standard/core/TwotoR
0003C4  1  95 81        TwoToR:	LDAX ZW,ModBRPB,0	; pop d.hi
0003C6  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d.lo
0003C8  1  7E 03        	PUSH AH,4		; push d.lo & d.hi
0003CA  1  09           	RSR
0003CB  1               
0003CB  1               
0003CB  1  32 52 40 03   FHdr '2R@',0 ; ( -- d ) ( R: d -- d )
0003CF  1  03 C4        
0003D1  1                  ; https://forth-standard.org/standard/core/TwoRFetch
0003D1  1  DD           TwoRAt:	LDBA SW			; get d.hi
0003D2  1  95 A8 02     	LDAX SW,ModNBRB,2	; get d.lo
0003D5  1  71 02 F9     	JMPD PushBA
0003D8  1               
0003D8  1               
0003D8  1  32 52 3E 03   FHdr '2R>',0 ; ( R: d -- ) ( -- d )
0003DC  1  03 D1        
0003DE  1                  ; https://forth-standard.org/standard/core/TwoRfrom
0003DE  1               TwoRFrom:
0003DE  1  D5 A1        	LDBX SW,ModBRPB,0	; pop d.hi
0003E0  1  95 A1        	LDAX SW,ModBRPB,0	; pop d.lo
0003E2  1  71 02 F9     	JMPD PushBA
0003E5  1               
0003E5  1               
0003E5  1               	.if 0
0003E5  1               
0003E5  1                FHdr 'NR>',0
0003E5  1                  ; Interpretation:
0003E5  1                  ;   Interpretation semantics for this word are undefined.
0003E5  1                  ; Execution:
0003E5  1                  ;   ( -- i * x +n ) ( R: j * x +n -- )
0003E5  1                  ;   Retrieve the items previously stored by an invocation of N>R. n is the number of items placed on the data stack.
0003E5  1                  ;   It is an ambiguous condition if NR> is used with data not stored by N>R.
0003E5  1                  ; https://forth-standard.org/standard/tools/NRfrom
0003E5  1               NRFrom:
0003E5  1               	JSRD Abort ;???
0003E5  1               
0003E5  1               
0003E5  1                FHdr 'N>R',0
0003E5  1                  ; Interpretation:
0003E5  1                  ;   Interpretation semantics for this word are undefined.
0003E5  1                  ; Execution:
0003E5  1                  ;   ( i * n +n -- ) ( R: -- j * x +n )
0003E5  1                  ;   Remove n+1 items from the data stack and store them for later retrieval by NR>.
0003E5  1                  ;   The return stack may be used to store the data. Until this data has been retrieved by NR>:
0003E5  1                  ;   * this data will not be overwritten by a subsequent invocation of N>R and
0003E5  1                  ;   * a program may not access data placed on the return stack before the invocation of N>R.
0003E5  1                  ; https://forth-standard.org/standard/tools/NtoR
0003E5  1               NToR:
0003E5  1               	JSRD Abort ;???
0003E5  1               
0003E5  1               	.endif
0003E5  1               
0003E5  1               
0003E5  1  49 6E 76 65   FHdr 'Invert',ha_inline ; ( n1 -- n2 ) Invert bits
0003E9  1  72 74 86 03  
0003ED  1  DE           
0003EE  1                  ; see 0= for logical negate
0003EE  1                  ; https://forth-standard.org/standard/core/INVERT
0003EE  1  9C           Invert:	LDAA ZW
0003EF  1  33 00        	IVR AW,0
0003F1  1  BC           	STAA ZW
0003F2  1  09 09        	.dbyt INL_End
0003F4  1               
0003F4  1               
0003F4  1  41 6E 64 83   FHdr 'And',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical and of n1 and n2 as n3.
0003F8  1  03 EE        
0003FA  1                  ; https://forth-standard.org/standard/core/AND
0003FA  1  95 81        AndD:	LDAX ZW,ModBRPB,0	; pop n2
0003FC  1  DC           	LDBA ZW			; get n1
0003FD  1  5A           	NAB			; and
0003FE  1  FC           	STBA ZW			; store result
0003FF  1  09 09        	.dbyt INL_End		; return
000401  1               
000401  1               
000401  1  4F 72 82 03   FHdr 'Or',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical or of two 16 bit values.
000405  1  FA           
000406  1                  ; https://forth-standard.org/standard/core/OR
000406  1  95 81        Or:	LDAX ZW,ModBRPB,0	; pop n2
000408  1  DC           	LDBA ZW			; get n1
000409  1  53 02        	ORI BW,AW
00040B  1  FC           	STBA ZW			; store result
00040C  1  09 09        	.dbyt INL_End		; return
00040E  1               
00040E  1               
00040E  1  58 6F 72 83   FHdr 'Xor',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical exclusive-or of two values.
000412  1  04 06        
000414  1                  ; https://forth-standard.org/standard/core/XOR
000414  1  95 81        Xor:	LDAX ZW,ModBRPB,0	; pop n2
000416  1  DC           XorA:	LDBA ZW			; get n1
000417  1  54 02        	ORE BW,AW
000419  1  FC           	STBA ZW			; store result
00041A  1  09 09        	.dbyt INL_End		; return
00041C  1               
00041C  1               
00041C  1  32 2A 82 04   FHdr '2*',ha_inline ; ( x1 -- x2 )  signed multiply by 2 (signed left shift)
000420  1  14           
000421  1                  ; x2 is the result of shifting x1 one bit toward the most-significant bit, filling the vacated
000421  1                  ; least-significant bit with zero.
000421  1                  ; https://forth-standard.org/standard/core/TwoTimes
000421  1               TwoStar:
000421  1  9C           	LDAA ZW
000422  1  3D           	SLA
000423  1  BC           	STAA ZW
000424  1  09 09        	.dbyt INL_End
000426  1               
000426  1               
000426  1  44 32 2A 03   FHdr 'D2*',0 ; ( xd1 -- xd2 )  signed double multiply by 2 (signed left shift)
00042A  1  04 21        
00042C  1                  ; xd2 is the result of shifting xd1 one bit toward the most-significant bit, filling the vacated
00042C  1                  ; least-significant bit with zero.
00042C  1                  ; https://forth-standard.org/standard/double/DTwoTimes
00042C  1               DTwoStar:
00042C  1  95 88 02     	LDAX ZW,ModNBRB,2
00042F  1  3D           	SLA
000430  1  B5 88 02     	STAX ZW,ModNBRB,2
000433  1  9C           	LDAA ZW
000434  1  37 00        	RLR AW,1
000436  1  BC           	STAA ZW
000437  1  09           	RSR
000438  1               
000438  1               
000438  1  32 2F 82 04   FHdr '2/',ha_inline ; ( x1 -- x2 )  signed divide by  (signed right shift)
00043C  1  2C           
00043D  1                  ; x2 is the result of shifting x1 one bit toward the least-significant bit, leaving the most significant
00043D  1                  ; bit unchanged.
00043D  1                  ; https://forth-standard.org/standard/core/TwoDiv
00043D  1               TwoSlash:
00043D  1  9C           	LDAA ZW
00043E  1  3C           	SRA
00043F  1  BC           	STAA ZW
000440  1  09 09        	.dbyt INL_End
000442  1               
000442  1               
000442  1  44 32 2F 03   FHdr 'D2/',0 ; ( xd1 -- xd2 )  signed double divide by 2 (signed right shift)
000446  1  04 3D        
000448  1                  ; xd2 is the result of shifting xd1 one bit toward the least-significant bit, leaving the most significant
000448  1                  ; bit unchanged.
000448  1                  ; https://forth-standard.org/standard/double/DTwoDiv
000448  1  9C           DDiv2:	LDAA ZW
000449  1  3C           	SRA
00044A  1  BC           	STAA ZW
00044B  1  95 88 02     	LDAX ZW,ModNBRB,2
00044E  1  36 00        	RRR AW,1
000450  1  B5 88 02     	STAX ZW,ModNBRB,2
000453  1  09           	RSR
000454  1               
000454  1               
000454  1  55 32 2F 83   FHdr 'U2/',ha_inline ; ( u -- u/2 )   Unsigned divide by two (logical right shift)
000458  1  04 48        
00045A  1                  ; https://forth-standard.org/standard/core/TwoDiv "Shr"
00045A  1  9C           UDiv2:	LDAA ZW
00045B  1  07           	RL
00045C  1  36 00        	RRR AW,1
00045E  1  BC           	STAA ZW
00045F  1  09 09        	.dbyt INL_End
000461  1               
000461  1               
000461  1               	.if 0
000461  1                FHdr 'UD2/',0 ; ( ud1 -- ud2 ) unsigned double divide by 2 (logical right shift)
000461  1               	JSRR UDiv2
000461  1               	LDAX ZW,ModNBRB,2
000461  1               	RRR AW,1
000461  1               	STAX ZW,ModNBRB,2
000461  1               	RSR
000461  1               	.endif
000461  1               
000461  1               
000461  1  72 6F 72 83   FHdr 'ror',ha_inline ; ( x1 -- x2 )   Logical right-rotation of one bit-place
000465  1  04 5A        
000467  1  9C           	LDAA ZW
000468  1  36 00        	RRR AW,1
00046A  1  BC           	STAA ZW
00046B  1  09 09        	.dbyt INL_End
00046D  1               
00046D  1               
00046D  1  72 6F 6C 83   FHdr 'rol',ha_inline ; ( x1 -- x2 )   Logical left-rotation of one bit-place
000471  1  04 67        
000473  1  9C           	LDAA ZW
000474  1  37 00        	RLR AW,1
000476  1  BC           	STAA ZW
000477  1  09 09        	.dbyt INL_End
000479  1               
000479  1               
000479  1               	.if 1
000479  1               
000479  1  4C 53 68 69   FHdr 'LShift',0 ; ( x1 u -- x2 )  Perform a logical left shift of u bit-places on x1, giving x2.
00047D  1  66 74 06 04  
000481  1  73           
000482  1                  ; Put zeroes into the least significant bits vacated by the shift.
000482  1                  ; An ambiguous condition exists if u is greater than or equal to the number of bits in a cell.
000482  1                  ; https://forth-standard.org/standard/core/LSHIFT
000482  1  95 81        LShift:	LDAX ZW,ModBRPB,0	; pop u
000484  1  14 07        	BZ @9
000486  1  DC           	LDBA ZW			; get x1
000487  1  35 20        @2:	SLR BW,1
000489  1  29           	DCAB
00048A  1  15 FB        	BNZ @2
00048C  1  FC           	STBA ZW			; save x2
00048D  1  09           @9:	RSR
00048E  1               
00048E  1               
00048E  1  52 53 68 69   FHdr 'RShift',0 ; ( x1 u -- x2 )  Perform a logical right shift of u bit-places on x1, giving x2.
000492  1  66 74 06 04  
000496  1  82           
000497  1                  ; Put zeroes into the most significant bits vacated by the shift.
000497  1                  ; An ambiguous condition exists if u is greater than or equal to the number of bits in a cell.
000497  1                  ; https://forth-standard.org/standard/core/RSHIFT
000497  1  95 81        RShift:	LDAX ZW,ModBRPB,0	; pop u
000499  1  14 08        	BZ @9
00049B  1  DC           	LDBA ZW			; get x1
00049C  1  07           @2:	RL
00049D  1  36 20        	RRR BW,1
00049F  1  29           	DCAB
0004A0  1  15 FA        	BNZ @2
0004A2  1  FC           	STBA ZW			; save x2
0004A3  1  09           @9:	RSR
0004A4  1               
0004A4  1               	.endif
0004A4  1               
0004A4  1               
0004A4  1  31 2B 82 04   FHdr '1+',ha_inline ; ( n1 -- n2 )  Increment n1 by 1
0004A8  1  97           
0004A9  1                  ; https://forth-standard.org/standard/core/OnePlus
0004A9  1               OnePlus:
0004A9  1  9C           	LDAA ZW			; get n1
0004AA  1  38           	INA
0004AB  1  BC           	STAA ZW			; store n2
0004AC  1  09 09        	.dbyt INL_End		; return
0004AE  1               
0004AE  1               
0004AE  1  32 2B 82 04   FHdr '2+',ha_inline ; ( n1 -- n2 )  Increment n1 by 2
0004B2  1  A9           
0004B3  1               TwoPlus:
0004B3  1  9C           	LDAA ZW			; get n1
0004B4  1  30 01        	INR AW,2
0004B6  1  BC           	STAA ZW			; store n2
0004B7  1  09 09        	.dbyt INL_End		; return
0004B9  1               
0004B9  1               
0004B9  1  31 2D 82 04   FHdr '1-',ha_inline ; ( n1 -- n2 )  Decrement n1 by 1
0004BD  1  B3           
0004BE  1                  ; https://forth-standard.org/standard/core/OneMinus
0004BE  1               OneMinus:
0004BE  1  9C           	LDAA ZW			; get n1
0004BF  1  39           	DCA
0004C0  1  BC           	STAA ZW			; store n2
0004C1  1  09 09        	.dbyt INL_End		; return
0004C3  1               
0004C3  1               
0004C3  1  32 2D 82 04   FHdr '2-',ha_inline ; ( n1 -- n2 ) Decrement n1 by 2
0004C7  1  BE           
0004C8  1               TwoMinus:
0004C8  1  9C           	LDAA ZW			; get n1
0004C9  1  31 01        	DCR AW,2		; subtract 2
0004CB  1  BC           	STAA ZW			; store n2
0004CC  1  09 09        	.dbyt INL_End
0004CE  1               
0004CE  1               
0004CE  1  2B 81 04 C8   FHdr '+',ha_inline ; ( n1 n2 -- n_sum )  n_sum = n1 + n2
0004D2  1                  ; https://forth-standard.org/standard/core/Plus
0004D2  1  95 81        Plus:	LDAX ZW,ModBRPB,0	; pop n2
0004D4  1  DC           PlusA:	LDBA ZW			; get n1
0004D5  1  58           	AAB
0004D6  1  FC           	STBA ZW			; store n_sum
0004D7  1  09 09        	.dbyt INL_End		; return
0004D9  1               
0004D9  1               
0004D9  1  4D 2B 02 04   FHdr 'M+',0 ; ( d1 n -- d2 )  d2 = d1 + signed(n)
0004DD  1  D2           
0004DE  1                 ; https://forth-standard.org/standard/double/MPlus
0004DE  1  95 81        MPlus:	LDAX ZW,ModBRPB,0	; pop n
0004E0  1  D5 88 02     MPlusA:	LDBX ZW,ModNBRB,2	; get d1.lo
0004E3  1  58           	AAB
0004E4  1  F5 88 02     	STBX ZW,ModNBRB,2
0004E7  1  DC           	LDBA ZW			; get d1.hi
0004E8  1  11 02        	BNL @4			; carry?
0004EA  1  30 20        	INR BW,1
0004EC  1  5C           @4:	XAY			; test n sign
0004ED  1  17 02        	BP @6
0004EF  1  31 20        	DCR BW,1
0004F1  1  FC           @6:	STBA ZW
0004F2  1  09           	RSR
0004F3  1               
0004F3  1               
0004F3  1  44 2B 02 04   FHdr 'D+',0 ; ( d1 d2 -- d_sum )  d_sum = d1 + d2
0004F7  1  DE           
0004F8  1  95 81        DPlus:	LDAX ZW,ModBRPB,0 ; pop d2.hi
0004FA  1  5C           	XAY
0004FB  1  95 81        	LDAX ZW,ModBRPB,0 ; pop d2.lo
0004FD  1  D5 88 02     	LDBX ZW,ModNBRB,2 ; get d1.lo
000500  1  58           	AAB
000501  1  F5 88 02     	STBX ZW,ModNBRB,2 ; store d1.lo
000504  1  11 02        	BNL @2		; carry?
000506  1  30 60        	INR YW,1
000508  1               @2:
000508  1  9C           	LDAA ZW		; get d1.hi
000509  1  50 60        	ADD AW,YW
00050B  1  BC           	STAA ZW		; store d1.hi
00050C  1  09           	RSR
00050D  1               
00050D  1               
00050D  1  2D 81 04 F8   FHdr '-',ha_inline ; ( n1 n2 -- n_diff )  n_diff=n1-n2
000511  1                  ; https://forth-standard.org/standard/core/Minus
000511  1               Subtract:
000511  1  D5 81        	LDBX ZW,ModBRPB,0 ; pop n2
000513  1  9C           	LDAA ZW		; get n1
000514  1  59           	SAB
000515  1  FC           	STBA ZW		; store n_diff
000516  1  09 09        	.dbyt INL_End
000518  1               
000518  1               
000518  1  44 2D 02 05   FHdr 'D-',0 ; ( d1 d2 -- d )  d=d1-d2
00051C  1  11           
00051D  1                  ; https://forth-standard.org/standard/double/DMinus
00051D  1               DMinus:
00051D  1                   .if 1
00051D  1               	; short slower version
00051D  1  7B 2F        	JSRR DNegate
00051F  1  73 D7        	JMPR DPlus
000521  1                   .else
000521  1               	; long faster version
000521  1               	LDAX ZW,ModBRPB,0	; Y= d2.hi
000521  1               	XAY
000521  1               	LDBX ZW,ModBRPB,0	; B= dl.lo
000521  1               	LDAX ZW,ModNBRB,2	; A= d1.lo
000521  1               	SAB
000521  1               	STBX ZW,ModNBRB,2
000521  1               	LDAA ZW			; A= d1.hi
000521  1               	XFR BW,YW
000521  1               	SAB
000521  1               	STAA ZW
000521  1               	RSR
000521  1                   .endif
000521  1               
000521  1               
000521  1  4E 65 67 61   FHdr 'Negate',ha_inline ; ( n -- n )  Leave the two's complement of a number.
000525  1  74 65 86 05  
000529  1  1D           
00052A  1                  ; https://forth-standard.org/standard/core/NEGATE
00052A  1  DC           Negate:	LDBA ZW		; get n
00052B  1  33 21        Negat1:	IVR BW,1
00052D  1  FC           	STBA ZW		; store n
00052E  1  09 09        	.dbyt INL_End
000530  1               
000530  1               
000530  1               	.if 0
000530  1                FHdr "Minus",0 ; ( n -- n )  FIG alias
000530  1               	JMPR Negate
000530  1               	.endif
000530  1               
000530  1               
000530  1  41 62 73 03   FHdr 'Abs',0 ; ( n -- u )  Leave the absolute value of n as u.
000534  1  05 2A        
000536  1  DC           Abs:	LDBA ZW		; n<0?
000537  1  16 F2        	BM Negat1	;   negate it & return
000539  1  09           	RSR		; return
00053A  1               
00053A  1               
00053A  1  2B 2D 02 05   FHdr '+-',0 ; ( n1 n2 -- n3 )  Apply the sign of n2 to n1, which is left as n3.
00053E  1  36           
00053F  1  95 81        PM:	LDAX ZW,ModBRPB,0 ; pop n2
000541  1  16 E7        PMP:	BM Negate	;   negate n1 & return
000543  1  09           	RSR		; return
000544  1               
000544  1               
000544  1  44 4E 65 67   FHdr 'DNegate',0 ; ( d1 -- d2 )  Convert d1 to its double number two's complement.
000548  1  61 74 65 07  
00054C  1  05 3F        
00054E  1                  ; https://forth-standard.org/standard/double/DNEGATE
00054E  1  D5 88 02     DNegate: LDBX ZW,ModNBRB,2 ; get d1.lo
000551  1  3A           	CLA
000552  1  59           	SAB
000553  1  F5 88 02     	STBX ZW,ModNBRB,2 ; store d2.lo
000556  1  DC           	LDBA ZW		; get d1.hi
000557  1  10 01        	BL @3		; borrow?
000559  1  39           	DCA
00055A  1               @3:
00055A  1  59           	SAB
00055B  1  FC           	STBA ZW		; store d2.hi
00055C  1  09           	RSR
00055D  1               
00055D  1               
00055D  1               	.if 0
00055D  1                FHdr 'DMinus',0 ; ( d1 -- d2 )  FIG alias
00055D  1               	JMPR DNegate
00055D  1               	.endif
00055D  1               
00055D  1               
00055D  1  44 41 62 73   FHdr 'DAbs',0 ; ( d -- ud )  Leave the absolute value ud of a double number.
000561  1  04 05 4E     
000564  1                  ; https://forth-standard.org/standard/double/DABS
000564  1  8C           DAbs:	LDABA ZW	; d<0?
000565  1  16 E7        	BM DNegate	;   negate d & return
000567  1  09           	RSR		; return
000568  1               
000568  1               
000568  1  44 2B 2D 03   FHdr 'D+-',0 ; ( d1 n -- d2 )  Apply the sign of n to the doulbe number d1, leaving it as d2.
00056C  1  05 64        
00056E  1                  ; https://forth-standard.org/standard/double/DPlus
00056E  1  95 81        DPM:	LDAX ZW,ModBRPB,0 ; pop n
000570  1  16 DC        DPMP:	BM DNegate	;   negate d1 & return
000572  1  09           	RSR		; return
000573  1               
000573  1               
000573  1               	.if 1
000573  1               
000573  1  46 61 6C 73   FHdr 'False',ha_inline ; ( -- false )  Return a false flag.
000577  1  65 85 05 6E  
00057B  1                  ; https://forth-standard.org/standard/core/FALSE
00057B  1  3A           False:	CLA
00057C  1  B5 82        	STAX ZW,ModBMRB,0
00057E  1  09 09        	.dbyt INL_End
000580  1               
000580  1               
000580  1  54 72 75 65   FHdr 'True',ha_inline ; ( -- true )  Return a true flag.
000584  1  84 05 7B     
000587  1                  ; https://forth-standard.org/standard/core/TRUE
000587  1  32 01        True:	CLR AW,1
000589  1  B5 82        	STAX ZW,ModBMRB,0
00058B  1  09 09        	.dbyt INL_End
00058D  1               
00058D  1               	.endif
00058D  1               
00058D  1               
00058D  1  30 3C 02 05   FHdr '0<',0 ; ( n -- f )  Leave a bool n<0
000591  1  87           
000592  1                  ; https://forth-standard.org/standard/core/Zeroless
000592  1               ZLessThan:
000592  1  8C           	LDABA ZW		; test n
000593  1  16 76        	BM True0
000595  1  71 06 1A     	JMPD False0
000598  1               
000598  1               
000598  1  30 3E 02 05   FHdr '0>',0 ; ( n -- f )  Leave a bool n>0
00059C  1  92           
00059D  1  9C           ZGt:	LDAA ZW			; test n
00059E  1  16 7A        	BM False0
0005A0  1  14 78        	BZ False0
0005A2  1  73 67        	JMPR True0
0005A4  1               
0005A4  1               
0005A4  1  44 30 3C 03   FHdr 'D0<',0 ; ( d -- f ) f=(d<0)
0005A8  1  05 9D        
0005AA  1                  ; https://forth-standard.org/standard/double/DZeroless
0005AA  1               DZLessThan:
0005AA  1  95 81        	LDAX ZW,ModBRPB,0	; pop d.hi
0005AC  1  16 5D        	BM True0
0005AE  1  73 6A        	JMPR False0
0005B0  1               
0005B0  1               
0005B0  1  30 3D 02 05   FHdr '0=',0 ; ( n -- f )  Leave a bool n==0
0005B4  1  AA           
0005B5  1                  ; https://forth-standard.org/standard/core/ZeroEqual
0005B5  1  9C           ZEqual:	LDAA ZW			; test n
0005B6  1  14 53        	BZ True0
0005B8  1  73 60        	JMPR False0
0005BA  1               
0005BA  1               
0005BA  1  30 3C 3E 03   FHdr '0<>',0 ; ( n -- f )  Leave a bool n!=0
0005BE  1  05 B5        
0005C0  1                  ; https://forth-standard.org/standard/core/Zerone
0005C0  1               ZNEqual:
0005C0  1  9C           	LDAA ZW			; test n
0005C1  1  15 48        	BNZ True0
0005C3  1  09           	RSR
0005C4  1               
0005C4  1               
0005C4  1  44 30 3D 03   FHdr 'D0=',0 ; ( d -- f ) Leave a bool d==0
0005C8  1  05 C0        
0005CA  1                  ; https://forth-standard.org/standard/double/DZeroEqual
0005CA  1               DZEqual:
0005CA  1  95 81        	LDAX ZW,ModBRPB,0	; pop hi word
0005CC  1  15 4C        	BNZ False0
0005CE  1  DC           	LDBA ZW			; get lo word
0005CF  1  14 3A        	BZ True0
0005D1  1  73 47        	JMPR False0
0005D3  1               
0005D3  1               
0005D3  1  44 3D 02 05   FHdr 'D=',0 ; ( d1 d2 -- f )  f=(d1==d2)  double equal
0005D7  1  CA           
0005D8  1                  ; https://forth-standard.org/standard/double/DEqual
0005D8  1  95 81        DEqual:	LDAX ZW,ModBRPB,0	; pop d2.hi
0005DA  1  5C           	XAY
0005DB  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
0005DD  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d1.hi
0005DF  1  51 62        	SUB BW,YW		; compare hi words
0005E1  1  15 37        	BNZ False0
0005E3  1  DC           	LDBA ZW			; get d1.lo
0005E4  1  59           	SAB			; compare lo words
0005E5  1  15 33        	BNZ False0
0005E7  1  73 22        	JMPR True0
0005E9  1               
0005E9  1               
0005E9  1  44 3C 3E 03   FHdr 'D<>',0 ; ( d1 d2 -- f )  f=(d1!=d2)  double not equal
0005ED  1  05 D8        
0005EF  1               DNEqual:
0005EF  1  7B E7        	JSRR DEqual
0005F1  1  71 05 B5     	JMPD ZEqual
0005F4  1               
0005F4  1               
0005F4  1  3C 3E 02 05   FHdr '<>',0 ; ( x1 x2 -- flag)  https://forth-standard.org/standard/core/ne
0005F8  1  EF           
0005F9  1                  ; https://forth-standard.org/standard/core/Zerone
0005F9  1               NtoEqual:
0005F9  1  95 81        	LDAX ZW,ModBRPB,0	; pop x2
0005FB  1  DC           	LDBA ZW			; get x1
0005FC  1  59           	SAB			; x2<>x1?
0005FD  1  15 0C        	BNZ True0
0005FF  1  FC           	STBA ZW			; flag=false
000600  1  09           	RSR
000601  1               
000601  1               
000601  1  3D 01 05 F9   FHdr '=',0 ; ( x1 x2 -- flag )  Leave a true flag if x1=x2; otherwise leave a false flag.
000605  1                  ; https://forth-standard.org/standard/core/Equal
000605  1  95 81        Equal:	LDAX ZW,ModBRPB,0	; pop x2
000607  1  DC           	LDBA ZW			; get x1
000608  1  59           	SAB			; x2==x1?
000609  1  15 0F        	BNZ False0
00060B  1  32 01        True0:	CLR AW,1		; flag=true
00060D  1  BC           	STAA ZW
00060E  1  09           	RSR
00060F  1               
00060F  1               
00060F  1  55 3C 02 06   FHdr 'U<',0 ; ( u1 u2 -- f )  f=u1<u2 (unsigned compare)
000613  1  05           
000614  1                  ; https://forth-standard.org/standard/core/Uless
000614  1               ULessThan:
000614  1  D5 81        	LDBX ZW,ModBRPB,0	; pop u2
000616  1  9C           	LDAA ZW			; get u1
000617  1  59           ULt3:	SAB			; n1<n2?
000618  1  11 F1        	BNL True0
00061A  1  3A           False0:	CLA			; f=false
00061B  1  BC           	STAA ZW
00061C  1  09           	RSR
00061D  1               
00061D  1               
00061D  1  55 3E 02 06   FHdr 'U>',0 ; ( u1 u2 -- f )  f=u1>u2 (unsigned compare)
000621  1  14           
000622  1                  ; https://forth-standard.org/standard/core/Umore
000622  1               UGreaterThan:
000622  1  95 81        	LDAX ZW,ModBRPB,0	; pop u2
000624  1  DC           	LDBA ZW			; get u1
000625  1  73 F0        	JMPR ULt3
000627  1               
000627  1               
000627  1  3C 01 06 22   FHdr '<',0 ; ( n1 n2 -- f )  f=n1<n2 (signed compare)
00062B  1                  ; https://forth-standard.org/standard/core/less
00062B  1               LessThan:
00062B  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n2
00062D  1  9C           	LDAA ZW			; get n1
00062E  1  59           LT2:	SAB			; n1<n2?
00062F  1  12 04        LT3:	BF @3			; overflow?
000631  1  16 D8        	BM True0
000633  1  73 E5        	JMPR False0
000635  1               
000635  1  16 E3        @3:	BM False0
000637  1  73 D2        	JMPR True0
000639  1               
000639  1               
000639  1  3C 3D 02 06   FHdr '<=',0 ; ( n1 n2 -- flag ) flag=n1<=n2 (signed compare)
00063D  1  2B           
00063E  1               LessEqual:
00063E  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n2
000640  1  9C           	LDAA ZW			; get n1
000641  1  59           LE3:	SAB			; n1<n2?
000642  1  15 EB        	BNZ LT3
000644  1  73 C5        	JMPR True0
000646  1               
000646  1               
000646  1  3E 01 06 3E   FHdr '>',0 ; ( n1 n2 -- f )  f=n1>n2 (signed compare)
00064A  1                  ; https://forth-standard.org/standard/core/less
00064A  1               GreaterThan:
00064A  1  95 81        	LDAX ZW,ModBRPB,0	; pop n2
00064C  1  DC           	LDBA ZW			; get n1
00064D  1  73 DF        	JMPR LT2
00064F  1               
00064F  1               
00064F  1  3E 3D 02 06   FHdr '>=',0 ; ( n1 n2 -- f )  f=n1>=n2 (signed compare)
000653  1  4A           
000654  1               GreaterEqual:
000654  1  95 81        	LDAX ZW,ModBRPB,0	; pop n2
000656  1  DC           	LDBA ZW			; get n1
000657  1  73 E8        	JMPR LE3
000659  1               
000659  1               
000659  1  44 55 3C 03   FHdr 'DU<',0 ; ( d1 d2 -- f )  f=d1<d2 (unsigned compare)
00065D  1  06 54        
00065F  1                  ; https://forth-standard.org/standard/double/DUless
00065F  1               DULessThan:
00065F  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d2.hi
000661  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
000663  1  5C           	XAY
000664  1  95 81        	LDAX ZW,ModBRPB,0	; pop d1.hi
000666  1  59           	SAB
000667  1  15 03        	BNZ @7
000669  1  9C           	LDAA ZW			; get d1.lo
00066A  1  51 06        	SUB YW,AW
00066C  1  11 9D        @7:	BNL True0
00066E  1  73 AA        	JMPR False0
000670  1               
000670  1               
000670  1  44 3C 02 06   FHdr 'D<',0 ; ( d1 d2 -- f )  f=d1<d2 (signed compare)
000674  1  5F           
000675  1                  ; https://forth-standard.org/standard/double/Dless
000675  1               DLessThan:
000675  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d2.hi
000677  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
000679  1  5C           	XAY
00067A  1  95 81        	LDAX ZW,ModBRPB,0	; pop d1.hi
00067C  1  59           	SAB
00067D  1  15 07        	BNZ @10
00067F  1  9C           	LDAA ZW			; get d1.lo
000680  1  51 06        	SUB YW,AW
000682  1  11 87        	BNL True0
000684  1  73 94        	JMPR False0
000686  1               
000686  1  13 05        @10:	BNF @14
000688  1  16 90        	BM False0
00068A  1  71 06 0B     	JMPD True0
00068D  1               
00068D  1  17 8B        @14:	BP False0
00068F  1  71 06 0B     	JMPD True0
000692  1               
000692  1               
000692  1  44 3E 53 83   FHdr 'D>S',ha_inline ; ( d -- n )  Convert double to single
000696  1  06 75        
000698  1                  ; https://forth-standard.org/standard/double/DtoS
000698  1  30 81        DToS:	INR ZW,2
00069A  1  09 09        	.dbyt INL_End
00069C  1               
00069C  1               
00069C  1  53 3E 44 03   FHdr 'S>D',0 ; ( n -- d )  Sign extend a single number to form a double number.
0006A0  1  06 98        
0006A2  1                  ; https://forth-standard.org/standard/core/StoD
0006A2  1  3A           SToD:	CLA			; assume hi word is 0
0006A3  1  DC           	LDBA ZW			; n<0?
0006A4  1  17 01        	BP @2
0006A6  1  39           	DCA			;   change to -1
0006A7  1  B5 82        @2:	STAX ZW,ModBMRB,0	; push hi word
0006A9  1  09           	RSR
0006AA  1               
0006AA  1               
0006AA  1               	.if 0
0006AA  1                FHdr 'S->D',0 ; ( n -- d )  FIG alias
0006AA  1               	JMPR SToD
0006AA  1               	.endif
0006AA  1               
0006AA  1               
0006AA  1  55 4D 2A 03   FHdr 'UM*',0 ; ( u1 u2 -- ud )  ud = unsigned double number product of 2 unsigned numbers.
0006AE  1  06 A2        
0006B0  1                  ; https://forth-standard.org/standard/core/UMTimes
0006B0  1  6D A2        UMStar:	STXX SW,ModBMRB,0	; save X
0006B2  1  95 88 02     	LDAX ZW,ModNBRB,2	; Y=u1
0006B5  1  5C           	XAY
0006B6  1  9C           	LDAA ZW			; A=u2
0006B7  1  32 20        	CLR BW,0		; product.hi=0
0006B9  1  60 00 10     	LDXL 16			; for 16 bits
0006BC  1  07           	RL			; pre-shift u2
0006BD  1  36 00        	RRR AW,1
0006BF  1  11 02        @3:	BNL @4			;   set?
0006C1  1  50 62        	ADD BW,YW		;     add u1 to product.hi
0006C3  1  36 20        @4:	RRR BW,1		;   rotate product right 1 bit
0006C5  1  36 00        	RRR AW,1
0006C7  1  3F           	DCX			;  next bit
0006C8  1  15 F5        	BNZ @3
0006CA  1  FC           	STBA ZW			; store product.hi
0006CB  1  B5 88 02     	STAX ZW,ModNBRB,2	; store product.lo
0006CE  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
0006D0  1  09           	RSR			; return
0006D1  1               
0006D1  1               
0006D1  1               	.if 0
0006D1  1                FHdr 'U*',0 ; ( u1 u2 -- ud )  FIG alias
0006D1  1               	JMPR UMStar
0006D1  1               	.endif
0006D1  1               
0006D1  1                 .if 0
0006D1  1               UMStarTest1:
0006D1  1               	LDAL 1
0006D1  1               	STAX ZW,ModBMRB,0
0006D1  1               	LDAL 1
0006D1  1               	STAX ZW,ModBMRB,0
0006D1  1               	JSRD UMStar
0006D1  1               	LDAX ZW,ModBRPB,0
0006D1  1               	LDBL 0
0006D1  1               	SAB
0006D1  1               	BZ @13
0006D1  1               	HLT
0006D1  1               @13:
0006D1  1               	LDAX ZW,ModBRPB,0
0006D1  1               	LDBL 1
0006D1  1               	SAB
0006D1  1               	BZ @14
0006D1  1               	HLT
0006D1  1               @14:
0006D1  1               
0006D1  1               	LDAL $9876
0006D1  1               	STAX ZW,ModBMRB,0
0006D1  1               	LDAL $a987
0006D1  1               	STAX ZW,ModBMRB,0
0006D1  1               	JSRD UMStar
0006D1  1               	LDAX ZW,ModBRPB,0
0006D1  1               	LDBL $64f6
0006D1  1               	SAB
0006D1  1               	BZ @23
0006D1  1               	HLT
0006D1  1               @23:
0006D1  1               	LDAX ZW,ModBRPB,0
0006D1  1               	LDBL $4c3a
0006D1  1               	SAB
0006D1  1               	BZ @24
0006D1  1               	HLT
0006D1  1               @24:
0006D1  1               
0006D1  1               	RSR
0006D1  1                 .endif
0006D1  1               
0006D1  1               
0006D1  1  55 4D 2F 4D   FHdr 'UM/Mod',0 ; ( ud_dividend u_divisor -- u_rem u_quot )
0006D5  1  6F 64 06 06  
0006D9  1  B0           
0006DA  1                  ; Leave the unsigned remainder and unsigned quotient from the unsigned
0006DA  1                  ; double dividend and unsigned divisor.
0006DA  1                  ; https://forth-standard.org/standard/core/UMDivMOD
0006DA  1               UMSlashMod:
0006DA  1  95 81        	LDAX ZW,ModBRPB,0	; pop divisor into A
0006DC  1  33 01        	IVR AW,1		; negate
0006DE  1  6D A2        	STXX SW,ModBMRB,0	; save X
0006E0  1  55 82        	XFR BW,ZW		; save Z
0006E2  1  F5 A2        	STBX SW,ModBMRB,0
0006E4  1  D5 88 02     	LDBX ZW,ModNBRB,2	; Y=dividend.lo
0006E7  1  55 26        	XFR YW,BW
0006E9  1  65 80        	LDXX ZW,ModBRB,0	; X=dividend.hi
0006EB  1               
0006EB  1  C0 10        	LDBBL 16		; for 16 bits
0006ED  1  45 39        	XFRB ZL,BL
0006EF  1  35 60        	SLR YW,1		; shift dividend.lo left
0006F1  1  37 40        @2:	RLR XW,1		;   rotate dividend.hi left
0006F3  1  10 1B        	BL @7			;   dividend overflowed?
0006F5  1  55 42        	XFR BW,XW
0006F7  1  58           	AAB			;   dividend.hi>=divisor?
0006F8  1  14 02        	BZ @3
0006FA  1  11 02        	BNL @4
0006FC  1  55 24        @3:	XFR XW,BW		;     dividend.hi-=divisor
0006FE  1  37 60        @4:	RLR YW,1		;   shift into quotient, start dividend shift
000700  1  21 90        	DCRB ZL			;  next bit
000702  1  15 ED        	BNZ @2
000704  1  95 A1        	LDAX SW,ModBRPB,0	; restore Z
000706  1  5E           	XAZ
000707  1  6D 88 02     	STXX ZW,ModNBRB,2	; save remainder
00070A  1  55 60        	XFR AW,YW
00070C  1  BC           	STAA ZW			; save quotient
00070D  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
00070F  1  09           	RSR			; return
000710  1               
000710  1               @7:				; dividend overflowed, so it's always bigger than the divisor
000710  1  55 42        	XFR BW,XW
000712  1  58           	AAB			; dividend.hi-=divisor
000713  1  06           	SL			; it always fits, because the shifted out bit was set
000714  1  73 E6        	JMPR @3
000716  1               
000716  1               
000716  1               	.if 0
000716  1                FHdr 'U/',0 ; FIG alias
000716  1               	JMPR UMSlashMod
000716  1               	.endif
000716  1               
000716  1               
000716  1               	.if 0
000716  1               UMSlashModTest1:
000716  1               	LDAL $5678		; dividend = $12345678
000716  1               	STAX ZW,ModBMRB,0
000716  1               	LDAL $1234
000716  1               	STAX ZW,ModBMRB,0
000716  1               	LDAL $6789		; divisor = $6789
000716  1               	STAX ZW,ModBMRB,0
000716  1               	JSRD UMSlashMod
000716  1               	LDAX ZW,ModBRPB,0	; quotient
000716  1               	LDBL $2d03
000716  1               	SAB
000716  1               	BZ @3
000716  1               	HLT
000716  1               @3:
000716  1               	LDAX ZW,ModBRPB,0	; remainder
000716  1               	LDBL $add
000716  1               	SAB
000716  1               	BZ @4
000716  1               	HLT
000716  1               @4:
000716  1               	RSR
000716  1               	.endif
000716  1               
000716  1               
000716  1  4D 2A 02 06   FHdr 'M*',0 ; ( n1 n2 -- d )
00071A  1  DA           
00071B  1                  ; A mixed magnitude math operations which leaves the double number signed
00071B  1                  ; product of two signed integers.
00071B  1                  ; https://forth-standard.org/standard/core/MTimes
00071B  1  9C           MStar:	LDAA ZW			; save result sign
00071C  1  D5 88 02     	LDBX ZW,ModNBRB,2
00071F  1  54 02        	ORE BW,AW
000721  1  F5 A2        	STBX SW,ModBMRB,0
000723  1  79 05 36     	JSRD Abs		; n2=abs(n2)
000726  1  D5 88 02     	LDBX ZW,ModNBRB,2	; n1<0?
000729  1  17 05        	BP @4
00072B  1  3A           	CLA			;   n1=-n1
00072C  1  59           	SAB
00072D  1  F5 88 02     	STBX ZW,ModNBRB,2
000730  1               @4:
000730  1  79 06 B0     	JSRD UMStar		; unsigned multiply giving double product
000733  1  95 A1        	LDAX SW,ModBRPB,0	; should be negative?
000735  1  71 05 70     	JMPD DPMP		; fix sign & return
000738  1               
000738  1               
000738  1  4D 2F 4D 6F   FHdr 'M/Mod',0 ; ( ud1 u2 -- u3 ud4 )
00073C  1  64 05 07 1B  
000740  1                  ; An unsigned mixed magnitude math operation which leaves a double quotient ud4 and
000740  1                  ; remainder u3, from a double dividend ud1 and single divisor u2.
000740  1               MSlashMod:
000740  1  DC           	LDBA ZW			; >R 0
000741  1  F5 A2        	STBX SW,ModBMRB,0
000743  1  3A           	CLA
000744  1  BC           	STAA ZW
000745  1  F5 82        	STBX ZW,ModBMRB,0	; R
000747  1  79 06 DA     	JSRD UMSlashMod		; U/
00074A  1  DD           	LDBA SW			; R> Swap >R
00074B  1  9C           	LDAA ZW
00074C  1  FC           	STBA ZW
00074D  1  BD           	STAA SW
00074E  1  79 06 DA     	JSRD UMSlashMod		; U/
000751  1  95 A1        	LDAX SW,ModBRPB,0	; R>
000753  1  B5 82        	STAX ZW,ModBMRB,0
000755  1  09           	RSR
000756  1               
000756  1               
000756  1               	.if 0
000756  1               MSlashModTest1:
000756  1               	LDAL .loword(123456789)
000756  1               	STAX ZW,ModBMRB,0
000756  1               	LDAL .hiword(123456789)
000756  1               	STAX ZW,ModBMRB,0
000756  1               	LDAL 10
000756  1               	STAX ZW,ModBMRB,0
000756  1               	JSRR MSlashMod
000756  1               	LDAX ZW,ModBRPB,0
000756  1               	LDBL .hiword(12345678)
000756  1               	SAB
000756  1               	BZ @11
000756  1               	HLT
000756  1               @11:
000756  1               	LDAX ZW,ModBRPB,0
000756  1               	LDBL .loword(12345678)
000756  1               	SAB
000756  1               	BZ @12
000756  1               	HLT
000756  1               @12:
000756  1               	LDAX ZW,ModBRPB,0
000756  1               	LDBL 9
000756  1               	SAB
000756  1               	BZ @13
000756  1               	HLT
000756  1               @13:
000756  1               	RSR
000756  1               	.endif
000756  1               
000756  1               
000756  1  53 4D 2F 52   FHdr 'SM/Rem',0 ; ( d_dividend n_divisor -- n_remainder n_quotient )
00075A  1  65 6D 06 07  
00075E  1  40           
00075F  1                  ; A mixed magnitude math operation which leaves the signed remainder and signed
00075F  1                  ; quotient, from a double number dividend and divisor.
00075F  1                  ; The remainder takes its sign from the dividend.
00075F  1               
00075F  1                  ; Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
00075F  1                  ;  Input and output stack arguments are signed.
00075F  1                  ;  An ambiguous condition exists if n1 is zero or if the quotient lies outside the range of a single-cell signed integer.
00075F  1                  ; https://forth-standard.org/standard/core/SMDivREM
00075F  1               SMSlashRem:
00075F  1  95 81        	LDAX ZW,ModBRPB,0	; pop divisor
000761  1  DC           	LDBA ZW			; push dividend sign to return stack
000762  1  F5 A2        	STBX SW,ModBMRB,0
000764  1  B5 A2        	STAX SW,ModBMRB,0	; push divisor to return stack
000766  1  79 05 64     	JSRD DAbs		; d=abs(d)
000769  1  9D           	LDAA SW			; get a copy of divisor from return stack
00076A  1  B5 82        	STAX ZW,ModBMRB,0
00076C  1  79 05 36     	JSRD Abs		; abs
00076F  1  79 06 DA     	JSRD UMSlashMod		; unsigned divide
000772  1  95 A1        	LDAX SW,ModBRPB,0	; pop divisor from return stack
000774  1               ;	STAX ZW,ModBMRB,0
000774  1  DD           	LDBA SW			; should quotient be negative?
000775  1  54 02        	ORE BW,AW
000777  1  79 05 41     	JSRD PMP
00077A  1  95 A1        	LDAX SW,ModBRPB,0	; pop dividend sign
00077C  1  17 08        	BP @18			; should remander be negative?
00077E  1  3A           	CLA			;   negate remainder
00077F  1  D5 88 02     	LDBX ZW,ModNBRB,2
000782  1  59           	SAB
000783  1  F5 88 02     	STBX ZW,ModNBRB,2
000786  1               @18:
000786  1  09           	RSR			; return
000787  1               
000787  1               
000787  1               	.if 0
000787  1                FHdr 'M/',0 ; ( d_dividend n_divisor -- n_remainder n_quotient )  FIG alias
000787  1               	JMPR SMSlashRem
000787  1               	.endif
000787  1               
000787  1               
000787  1               	.if 0
000787  1                FHdr 'FM/Mod',0 ; ( d n1 — n2 n3 )
000787  1                  ; Divide d1 by n1, giving the floored quotient n3 and the remainder n2.
000787  1                  ; Input and output stack arguments are signed.
000787  1                  ; An ambiguous condition exists if n1 is zero or if the quotient lies outside the range of a single-cell signed integer.
000787  1                  ; https://forth-standard.org/standard/core/FMDivMOD
000787  1               FMSMod:	LDAX ZW,ModBRPB,0	;pop divsior
000787  1               FMSModA: STAX SW,ModBMRB,0	;save divisor
000787  1               	LDAA ZW			; get dividend hi word
000787  1               	STAX SW,ModBMRB ,0	; save dividend sign
000787  1               	BP @3			; make dividend positive
000787  1               	JSRD DNegate
000787  1               @3:
000787  1               	LDAX SW,ModNBRB,2	; get abs(divisor)
000787  1               	BP @4
000787  1               	IVR AW,1
000787  1               @4:
000787  1               	STAX SW,ModBMRB,0
000787  1               	JSRD UMSlashMod		;unsigned divide
000787  1               
000787  1               	LDAXB SW,ModNBRB,2	;correct remainder
000787  1               	BP @6
000787  1               	LDAX ZW,ModNBRB,2
000787  1               	IVR AW,1
000787  1               	STAX ZW,ModNBRB,2
000787  1               @6:
000787  1               	LDAX SW,ModBRPB,0	;correct quotient
000787  1               	LDBA SW
000787  1               	ORE AW,BW
000787  1               	BP @5
000787  1               	sec
000787  1               	lda 2,x
000787  1               	beq @7
000787  1               	lda 1,s
000787  1               	sec
000787  1               	sbc 2,x
000787  1               	sta 2,x
000787  1               	clc
000787  1               @7:
000787  1               	lda #0
000787  1               	sbc 0,x
000787  1               	sta 0,x
000787  1               @5:
000787  1               	INR SW,2		; drop divisor
000787  1               	RSR
000787  1               	.endif
000787  1               
000787  1               
000787  1  2A 01 07 5F   FHdr '*',0 ; ( n1 n2 -- n_prod )  Leave the signed product of two signed numbers.
00078B  1                  ; https://forth-standard.org/standard/core/Times
00078B  1  79 06 B0     Star:	JSRD UMStar		; do unsigned multiply
00078E  1  30 81        	INR ZW,2		; drop hi word of result
000790  1  09           	RSR			; return
000791  1               
000791  1               
000791  1  2F 4D 6F 64   FHdr '/Mod',0 ; ( n_dividend n_divisor -- n_rem n_quot )  Divide
000795  1  04 07 8B     
000798  1                  ; https://forth-standard.org/standard/core/DivMOD
000798  1               SlashMod:
000798  1  95 81        	LDAX ZW,ModBRPB,0	; save divisor
00079A  1  B5 A2        	STAX SW,ModBMRB,0
00079C  1  79 06 A2     	JSRD SToD		; convert dividend to double
00079F  1  95 A1        	LDAX SW,ModBRPB,0	; get divisor
0007A1  1  B5 82        	STAX ZW,ModBMRB,0
0007A3  1  73 BA        	JMPR SMSlashRem		; divide & return
0007A5  1               
0007A5  1               
0007A5  1  2F 01 07 98   FHdr '/',0 ; ( n_dividend n_divisor -- n_quot )  Divide
0007A9  1                  ; https://forth-standard.org/standard/core/Div
0007A9  1  7B ED        Slash:	JSRR SlashMod		; do the divide
0007AB  1  71 03 1E     	JMPD Nip		; discard the remainder, & return
0007AE  1               
0007AE  1               
0007AE  1  4D 6F 64 03   FHdr 'Mod',0 ; ( n_dividend n_divisor -- n_mod )
0007B2  1  07 A9        
0007B4  1                  ; Leave the remainder of n1/n2, with the same sign as n1.
0007B4  1                  ; https://forth-standard.org/standard/core/MOD
0007B4  1  7B E2        Mod:	JSRR SlashMod		; do the divide
0007B6  1  30 81        	INR ZW,2		; drop the quotient
0007B8  1  09           	RSR			; return
0007B9  1               
0007B9  1               
0007B9  1  2A 2F 4D 6F   FHdr '*/Mod',0 ; ( n1 n_multipier n_divisor -- n_remainder n_quotient )
0007BD  1  64 05 07 B4  
0007C1  1                  ; Leave the quotient and remainder of the operation (n1*n_multiplier)/n_divisor .
0007C1  1                  ; A 31 bit intermediate product is used as for */ .
0007C1  1                  ; https://forth-standard.org/standard/core/TimesDivMOD
0007C1  1               StarSlashMod:
0007C1  1  95 81        	LDAX ZW,ModBRPB,0	; save divisor on return stack
0007C3  1  B5 A2        	STAX SW,ModBMRB,0
0007C5  1  79 07 1B     	JSRD MStar		; do multiply
0007C8  1  95 A1        	LDAX SW,ModBRPB,0	; get divisor from return stack
0007CA  1  B5 82        	STAX ZW,ModBMRB,0
0007CC  1  73 91        	JMPR SMSlashRem		; do divide & return
0007CE  1               
0007CE  1               
0007CE  1  2A 2F 02 07   FHdr '*/',0 ; ( n1 n_multiplier n_divisor -- n_quotient )
0007D2  1  C1           
0007D3  1                  ; Leave the ratio n_quotient = (n1*n_multiplier)/n_divisor where all are signed numbers.
0007D3  1                  ; Retention of an intermediate 31 bit product permits greater accuracy
0007D3  1                  ; than would be available with the sequence:
0007D3  1                  ;	n1 n_multiplier * n_divisor /
0007D3  1                  ; https://forth-standard.org/standard/core/TimesDiv
0007D3  1               StarSlash:
0007D3  1  7B EC        	JSRR StarSlashMod ; do it
0007D5  1  71 03 1E     	JMPD Nip		; discard the remainder & return
0007D8  1               
0007D8  1               
0007D8  1               	.if 0
0007D8  1                FHdr 'M*/',0 ; ( d1 n1 +n2 -- d2 )
0007D8  1                  ; https://forth-standard.org/standard/double/MTimesDiv
0007D8  1               	JSRD Abort ;???
0007D8  1               	.endif
0007D8  1               
0007D8  1               
0007D8  1  2B 21 02 07   FHdr '+!',0 ; ( n adr -- )  Add n to the value at the address.
0007DC  1  D3           
0007DD  1                  ; https://forth-standard.org/standard/core/PlusStore
0007DD  1               PlusStore:
0007DD  1  95 81        	LDAX ZW,ModBRPB,0	; pop adr
0007DF  1  5C           	XAY
0007E0  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
0007E2  1  DB           	LDBA YW
0007E3  1  58           	AAB
0007E4  1  FB           	STBA YW
0007E5  1  09           	RSR
0007E6  1               
0007E6  1               
0007E6  1  31 2B 21 83   FHdr '1+!',ha_inline ; ( adr -- )  increment a variable
0007EA  1  07 DD        
0007EC  1  D5 81        	LDBX ZW,ModBRPB,0	; pop addr
0007EE  1  99           	LDAA BW			; increment the word
0007EF  1  38           	INA
0007F0  1  B9           	STAA BW
0007F1  1  09 09        	.dbyt INL_End		; return
0007F3  1               
0007F3  1               
0007F3  1  30 21 82 07   FHdr '0!',ha_inline ; ( adr -- )  store 0 in a variable
0007F7  1  EC           
0007F8  1  3A           	CLA
0007F9  1  B5 85        	STAX ZW,ModABRPB,0
0007FB  1  09 09        	.dbyt INL_End		; return
0007FD  1               
0007FD  1               
0007FD  1               	.if 0
0007FD  1                FHdr 'Toggle',0 ; ( adr n -- )  Complement the contents of addr by the bit pattern n .
0007FD  1               Toggle:	LDBX ZW,ModBRPB,0	; pop n
0007FD  1               	LDAX ZW,ModBRPB,0	; pop adr
0007FD  1               	XAY
0007FD  1               	LDAA YW			; do a word
0007FD  1               	ORE AW,BW
0007FD  1               	STAA YW
0007FD  1               	RSR
0007FD  1               	.endif
0007FD  1               
0007FD  1               
0007FD  1  40 81 07 F8   FHdr '@',ha_inline ; ( adr -- n )  Leave the 16 bit contents of address.
000801  1                  ; https://forth-standard.org/standard/core/Fetch
000801  1  95 84        At:	LDAX ZW,ModABRB,0	; get @adr
000803  1  BC           	STAA ZW			; store n
000804  1  09 09        	.dbyt INL_End
000806  1               
000806  1               
000806  1  32 40 02 08   FHdr '2@',0 ; ( adr -- d )  Leave the 32 bit contents of address.
00080A  1  01           
00080B  1                  ; https://forth-standard.org/standard/core/TwoFetch
00080B  1  DC           TwoAt:	LDBA ZW			; get addr
00080C  1  95 21        	LDAX BW,ModBRPB,0	; get d.hi
00080E  1  D9           	LDBA BW			; get d.lo
00080F  1  FC           	STBA ZW			; store d.lo
000810  1  B5 82        	STAX ZW,ModBMRB,0	; store d.hi
000812  1  09           	RSR
000813  1               
000813  1               
000813  1  43 40 82 08   FHdr 'C@',ha_inline ; ( adr -- n )  Leave the 8 bit contents of memory address.
000817  1  0B           
000818  1               ; https://forth-standard.org/standard/core/CFetch
000818  1  3A           CAt:	CLA			; set the hi byte to 0
000819  1  85 84        	LDABX ZW,ModABRB,0	; fetch byte addressed by bottom of stack
00081B  1  BC           	STAA ZW			; store as n
00081C  1  09 09        	.dbyt INL_End		; return
00081E  1               
00081E  1               
00081E  1  21 81 08 18   FHdr '!',ha_inline ; ( n adr -- )  Store 16 bits of n at address.
000822  1                  ; https://forth-standard.org/standard/core/Store
000822  1  D5 81        Store:	LDBX ZW,ModBRPB,0	; pop adr
000824  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
000826  1  B9           	STAA BW			; store at (adr)
000827  1  09 09        	.dbyt INL_End		; return
000829  1               
000829  1               
000829  1  32 21 02 08   FHdr '2!',0 ; ( d adr -- )  Store 32 bits at adr.
00082D  1  22           
00082E  1                  ; https://forth-standard.org/standard/core/TwoStore
00082E  1               TwoStore:
00082E  1  D5 81        	LDBX ZW,ModBRPB,0	; pop adr
000830  1  95 81        	LDAX ZW,ModBRPB,0	; pop d.hi
000832  1  B5 21        	STAX BW,ModBRPB,0	; store at adr+0
000834  1  95 81        	LDAX ZW,ModBRPB,0	; pop d.lo
000836  1  B9           	STAA BW			; store at adr+2
000837  1  09           	RSR			; return
000838  1               
000838  1               
000838  1  43 21 82 08   FHdr 'C!',ha_inline ; ( n adr -- )  Store 8 bits at address.
00083C  1  2E           
00083D  1                  ; https://forth-standard.org/standard/core/CStore
00083D  1  D5 81        CStore:	LDBX ZW,ModBRPB,0	; pop adr
00083F  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
000841  1  A9           	STABA BW		; store at adr
000842  1  09 09        	.dbyt INL_End		; return
000844  1               
000844  1               
000844  1  45 78 65 63   FHdr 'Execute',0 ; ( xt -- )
000848  1  75 74 65 07  
00084C  1  08 3D        
00084E  1                  ; Execute the definition whose address is on the stack.
00084E  1                  ; The code address is also called the compilation address.
00084E  1                  ; https://forth-standard.org/standard/core/EXECUTE
00084E  1  75 85        Execute: JMPX ZW,ModABRPB,0	; pop xt & jmp to it
000850  1               
000850  1               
000850  1  43 6F 75 6E   FHdr 'Count',0 ; ( addr1 -- addr2 len )
000854  1  74 05 08 4E  
000858  1               ; Leave the byte address addr2 and byte count len of a counted string beginning at
000858  1               ; address addr1.  It is presumed that the first byte at addr1 contains the text
000858  1               ; byte count and the actual text starts with the second byte.
000858  1               ; Typically COUNT is followed by TYPE .
000858  1               ; https://forth-standard.org/standard/core/COUNT
000858  1  DC           Count:	LDBA ZW			; get addr1
000859  1  3A           	CLA			; get length byte
00085A  1  85 21        	LDABX BW,ModBRPB,0
00085C  1  FC           	STBA ZW			; store addr2
00085D  1  B5 82        	STAX ZW,ModBMRB,0	; push length
00085F  1  09           	RSR			; return
000860  1               
000860  1               
000860  1               	.if 0
000860  1               
000860  1                FHdr 'Chars',ha_inline ; ( n1 -- n2 )
000860  1                  ; n2 is the size in address units of n1 characters.
000860  1                  ; https://forth-standard.org/standard/core/CHARS
000860  1               Chars:	.dbyt INL_End
000860  1               
000860  1               
000860  1                FHdr 'Char+',0 ; ( c-addr1 -- c-addr2 )
000860  1                  ; Add the size in address units of a character to c-addr1, giving c-addr2.
000860  1                  ; https://forth-standard.org/standard/core/CHARPlus
000860  1               CharPlus: JMPR OnePlus
000860  1               
000860  1               	.endif
000860  1               
000860  1               
000860  1  43 65 6C 6C   FHdr 'Cell',0 ; ( -- n )  size of a cell in bytes
000864  1  04 08 58     
000867  1  71 0A 63     Cell:	JMPD Two
00086A  1               
00086A  1               
00086A  1  43 65 6C 6C   FHdr 'Cells',0 ; ( n1 -- n2 ) convert # of cells to bytes
00086E  1  73 05 08 67  
000872  1                  ; https://forth-standard.org/standard/core/CELLS
000872  1  71 04 21     Cells:	JMPD TwoStar
000875  1               
000875  1               
000875  1  43 65 6C 6C   FHdr 'Cell+',0 ; ( n1 -- n2 ) add size of cell
000879  1  2B 05 08 72  
00087D  1                  ; https://forth-standard.org/standard/core/CELLPlus
00087D  1               CellPlus:
00087D  1  71 04 B3     	JMPD TwoPlus
000880  1               
000880  1               
000880  1               	.if 0
000880  1                FHdr '/String',0 ; ( c-addr1 u1 n -- c-addr2 u2 )
000880  1                  ; Adjust the character string at c-addr1 by n characters. The resulting character string, specified by c-addr2 u2,
000880  1                  ; begins at c-addr1 plus n characters and is u1 minus n characters long.
000880  1                  ; https://forth-standard.org/standard/string/DivSTRING
000880  1               SlashString:
000880  1               	LDAX ZW,ModBRPB,0	; pop n
000880  1               	LDBX ZW,ModNBRB,2	; fix c-addr1
000880  1               	AAB
000880  1               	STBX ZW,ModNBRB,2
000880  1               	LDBA ZW			; fix u1
000880  1               	SUB AW,BW
000880  1               	STAA ZW
000880  1               	RSR
000880  1               	.endif
000880  1               
000880  1               
000880  1  2D 54 72 61   FHdr '-Trailing',0 ; ( addr n1 -- addr n2 )  Remove trailing blanks
000884  1  69 6C 69 6E  
000888  1  67 09 08 7D  
00088C  1                  ; Adjust the char count n1 of a text string beginning at addr to suppress
00088C  1                  ; the output of trailing blanks.  i.e. the chars at addr+n1 to addr+n2
00088C  1                  ; are blanks.
00088C  1                  ; https://forth-standard.org/standard/string/MinusTRAILING
00088C  1               DTrailing:
00088C  1  6D A2        	STXX SW,ModBMRB,0	; save X
00088E  1               
00088E  1  65 80        	LDXX ZW,ModBRB,0	; X= len
000890  1  95 88 02     	LDAX ZW,ModNBRB,2	; Y= addr+len
000893  1  5C           	XAY
000894  1  50 46        	ADD YW,XW
000896  1  3F           @8:	DCX			; step to previous char
000897  1  16 07        	BM @9
000899  1  C5 62        	LDBBX YW,ModBMRB,0	; get char
00089B  1  80 20        	LDABL ' '		; is char blank?
00089D  1  49           	SABB
00089E  1  14 F6        	BZ @8			;   if so, do another char
0008A0  1  3E           @9:	INXC			; done
0008A1  1  6D 80        	STXX ZW,ModBRB,0	; store new len
0008A3  1               
0008A3  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
0008A5  1  09           	RSR			; return
0008A6  1               
0008A6  1               
0008A6  1  55 70 70 65   FHdr 'Upper',0 ; ( adr len -- ) uppercase a string
0008AA  1  72 05 08 8C  
0008AE  1  6D A2        Upper:	STXX SW,ModBMRB,0	; push X
0008B0  1  65 81        	LDXX ZW,ModBRPB,0	; pop len
0008B2  1  95 81        	LDAX ZW,ModBRPB,0	; pop adr
0008B4  1  5C           	XAY
0008B5  1  14 15        	BZ @Done
0008B7  1               
0008B7  1  85 61        @2:	LDABX YW,ModBRPB,0	; get char
0008B9  1  C0 61        	LDBBL 'a'		; <'a'?
0008BB  1  49           	SABB
0008BC  1  11 0B        	BNL @7
0008BE  1  C0 7B        	LDBBL 'z'+1		; >'z'?
0008C0  1  49           	SABB
0008C1  1  10 06        	BL @7
0008C3  1  C0 DF        	LDBBL $DF		; change to ASCII uppercase
0008C5  1  4A           	NABB
0008C6  1  E5 68 FF     	STBBX YW,ModNBRB,$ff	; store it back
0008C9  1  3F           @7:	DCX			; len--
0008CA  1  17 EB        	BP @2			; <0?
0008CC  1               
0008CC  1  65 A1        @Done:	LDXX SW,ModBRPB,0	; pop X
0008CE  1  09           	RSR
0008CF  1               
0008CF  1               
0008CF  1               	.if 0
0008CF  1                FHdr 'Replaces',0 ; ( c-addr1 u1 c-addr2 u2 -- )
0008CF  1                  ; Set the string c-addr1 u1 as the text to substitute for the substitution named by c-addr2 u2.
0008CF  1                  ; If the substitution does not exist it is created. The program may then reuse the buffer c-addr1 u1
0008CF  1                  ; without affecting the definition of the substitution.
0008CF  1                  ;
0008CF  1                  ; Ambiguous conditions occur as follows:
0008CF  1                  ;	The substitution cannot be created;
0008CF  1                  ;	The name of a substitution contains the `%' delimiter character.
0008CF  1                  ; 	REPLACES may allot data space and create a definition. This breaks the contiguity of the current region and
0008CF  1                  ;	  is not allowed during compilation of a colon definition
0008CF  1                  ; https://forth-standard.org/standard/string/REPLACES
0008CF  1               Replaces:
0008CF  1               	JSRD Abort ;???
0008CF  1               	.endif
0008CF  1               
0008CF  1               
0008CF  1               	.if 0
0008CF  1                FHdr 'Search',0 ; ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
0008CF  1                  ; Search the string specified by c-addr1 u1 for the string specified by c-addr2 u2.
0008CF  1                  ; If flag is true, a match was found at c-addr3 with u3 characters remaining.
0008CF  1                  ; If flag is false there was no match and c-addr3 is c-addr1 and u3 is u1.
0008CF  1                  ; https://forth-standard.org/standard/string/SEARCH
0008CF  1               Search:
0008CF  1               	STXX SW,ModBMRB,0	; save X
0008CF  1               	LDAX ZW,ModBRPB,0	; pop u2
0008CF  1               	INA
0008CF  1               	STAX SW,ModBMRB,0	;   push u2
0008CF  1               	LDAA ZW			; get c-addr2
0008CF  1               	LDBL $7f00		;   YH=$7f, YL=1st char
0008CF  1               	LDBBX AW,ModBRPB,0
0008CF  1               	STBX SW,ModBMRB,0	;     push
0008CF  1               	STAX SW,ModBMRB,0	;   push c-addr2 + 1
0008CF  1               	LDAX ZW,ModNBRB,2	; get u1
0008CF  1               	INA			;   + 1
0008CF  1               	LDBX SW,ModNBRB,4	;   - u2
0008CF  1               	SAB
0008CF  1               	STBX SW,ModBMRB,0	;   push
0008CF  1               	LDAX ZW,ModNBRB,4	; get c-addr1
0008CF  1               	STAX SW,ModBMRB,0	;   push
0008CF  1               	XFR AW,ZW		; save Z
0008CF  1               	STAX SW,ModBMRB,0
0008CF  1               @c2	= 10
0008CF  1               @chr2	=  8
0008CF  1               @A2	=  6
0008CF  1               @A1	=  4
0008CF  1               @c1	=  2
0008CF  1               @Z	=  0
0008CF  1               
0008CF  1               @10:				; load regs for 1st char search
0008CF  1               	LDAX SW,ModNBRB,@c1	; Z = @c1
0008CF  1               	XAZ
0008CF  1               	LDAX SW,ModNBRB,@chr2	; Yh = $7f; YL = 1st pattern char
0008CF  1               	XAY
0008CF  1               	LDXX SW,ModNBRB,@A1	; X = @A1
0008CF  1               @12:	DCR ZW			;   get next byte
0008CF  1               	BZ @NotFound
0008CF  1               	LDABX XW,ModBRPB,0
0008CF  1               	SUBB BL,YL		;   compare
0008CF  1               	ANR BL,YH		;   is this helpful?
0008CF  1               	BNZ @12
0008CF  1               	STXX SW,ModNBRB,@A1	; save loc of 2nd char
0008CF  1               	XFR AW,ZW
0008CF  1               	STAX SW,ModNBRB,@c1	; save count
0008CF  1               
0008CF  1               	LDAX SW,ModNBRB,@A2	; load regs for additional chars search
0008CF  1               	XAY
0008CF  1               	LDAX SW,ModNBRB,@c2
0008CF  1               	XAZ
0008CF  1               	JMPR @28
0008CF  1               @22:	LDABX XW,ModBRPB,0	; compare char
0008CF  1               	LDBBX YW,ModBRPB,0
0008CF  1               	SABB
0008CF  1               	BNZ @10
0008CF  1               @28:	DCR ZW			; adjust count
0008CF  1               	BNZ @22
0008CF  1               
0008CF  1               @Found:	LDAA SW ;@Z		; restore Z
0008CF  1               	XAZ
0008CF  1               	LDAX SW,ModNBRB,@A1	; c-addr3 = @A1 - 1
0008CF  1               	DCA
0008CF  1               	STAX ZW,ModNBRB,4
0008CF  1               	LDAX SW,ModNBRB,@c1	; u3 = @c1 + @c2
0008CF  1               	LDBX SW,ModNBRB,@c2
0008CF  1               	AAB
0008CF  1               	STBX ZW,ModNBRB,2
0008CF  1               	LDAL 1			; flag = true
0008CF  1               	JMPR @99
0008CF  1               
0008CF  1               @NotFound:
0008CF  1               	LDAA SW ; @Z		; restore Z
0008CF  1               	XAZ
0008CF  1               	CLA			; flag = false
0008CF  1               
0008CF  1               @99:	INR SW,@c2+2
0008CF  1               	LDXX SW,MonBRPB,0	; restore X
0008CF  1               	STAA ZW			; save flag
0008CF  1               	RSR
0008CF  1               	.endif
0008CF  1               
0008CF  1               
0008CF  1               	.if 0
0008CF  1                FHdr 'Substitute',0 ; ( c-addr1 u1 c-addr2 u2 -- c-addr2 u3 n )
0008CF  1                  ; Perform substitution on the string c-addr1 u1 placing the result at string c-addr2 u3,
0008CF  1                  ; where u3 is the length of the resulting string.
0008CF  1                  ; An error occurs if the resulting string will not fit into c-addr2 u2 or if c-addr2 is the same as c-addr1.
0008CF  1                  ; The return value n is positive or 0 on success and indicates the number of substitutions made. A negative value for n indicates that an error occurred, leaving c-addr2 u3 undefined. Negative values of n are implementation defined except for values in table 9.1 THROW code assignments.
0008CF  1                  ;
0008CF  1                  ; Substitution occurs left to right from the start of c-addr1 in one pass and is non-recursive.
0008CF  1                  ;
0008CF  1                  ; When text of a potential substitution name, surrounded by `%' (ASCII $25) delimiters is encountered by SUBSTITUTE, the following occurs:
0008CF  1                  ;
0008CF  1                  ; If the name is null, a single delimiter character is passed to the output, i.e., %% is replaced by %. The current number of substitutions is not changed.
0008CF  1                  ; If the text is a valid substitution name acceptable to 17.6.2.2141 REPLACES, the leading and trailing delimiter characters and the enclosed substitution name are replaced by the substitution text. The current number of substitutions is incremented.
0008CF  1                  ; If the text is not a valid substitution name, the name with leading and trailing delimiters is passed unchanged to the output. The current number of substitutions is not changed.
0008CF  1                  ; Parsing of the input string resumes after the trailing delimiter.
0008CF  1                  ; If after processing any pairs of delimiters, the residue of the input string contains a single delimiter, the residue is passed unchanged to the output.
0008CF  1                  ; https://forth-standard.org/standard/string/SUBSTITUTE
0008CF  1               Substutute:
0008CF  1               	JSRD Abort ;???
0008CF  1               	.endif
0008CF  1               
0008CF  1               
0008CF  1               	.if 0
0008CF  1                FHdr 'Unescape',0 ; ( c-addr1 u1 c-addr2 -- c-addr2 u2 )
0008CF  1                  ; Replace each `%' character in the input string c-addr1 u1 by two `%' characters.
0008CF  1                  ; The output is represented by c-addr2 u2. The buffer at c-addr2 shall be big enough to hold the unescaped string.
0008CF  1                  ; An ambiguous condition occurs if the resulting string will not fit into the destination buffer (c-addr2).
0008CF  1                  ; https://forth-standard.org/standard/string/UNESCAPE
0008CF  1               Unescape:
0008CF  1               	JSRD Abort ;???
0008CF  1               	.endif
0008CF  1               
0008CF  1               
0008CF  1  45 6E 63 6C   FHdr 'Enclose',0 ; ( addr delimiter - addr1 n1 n2 n3 )
0008D3  1  6F 73 65 07  
0008D7  1  08 AE        
0008D9  1                  ; The text scanning primitive used by WORD.  From the text address addr1 and an ASCII
0008D9  1                  ; delimiting char, is determined the byte offset to the first non-delimiter
0008D9  1                  ; char n1, the offset to the first delimiter after the text n2, and the offset to the
0008D9  1                  ; first char not included.
0008D9  1                  ; This procedure will not process past an ASCII 'null', treating it as an unconditional delimiter.
0008D9  1               Enclose:
0008D9  1  6D A2        	STXX SW,ModBMRB,0	; push X
0008DB  1  65 88 02     	LDXX ZW,ModNBRB,2	; X=addr
0008DE  1  9C           	LDAA ZW			; AL=delimiter
0008DF  1  31 83        	DCR ZW,4		; alloc space for n2 & n3
0008E1  1               
0008E1  1               	; skip initial delimiters
0008E1  1  3F           	DCX
0008E2  1  3E           @313:	INXC			; get next char
0008E3  1  CA           	LDBBA XW
0008E4  1  49           	SABB
0008E5  1  14 FB        	BZ @313
0008E7  1  D5 88 06     	LDBX ZW,ModNBRB,6	; n1=index of 1st non-delimiter char
0008EA  1  51 42        	SUB BW,XW
0008EC  1  F5 88 04     	STBX ZW,ModNBRB,4
0008EF  1               
0008EF  1  3F           	DCX			; skip word
0008F0  1  3E           @318:	INXC			; get next char
0008F1  1  CA           	LDBBA XW
0008F2  1  14 10        	BZ @70			;    null?
0008F4  1  49           	SABB			;    !delimiter?
0008F5  1  15 F9        	BNZ @318
0008F7  1  D5 88 06     	LDBX ZW,ModNBRB,6	; n2=index of delimiter after word
0008FA  1  51 42        	SUB BW,XW
0008FC  1  F5 88 02     	STBX ZW,ModNBRB,2
0008FF  1  30 20        	INR BW,1		; n3=n2+1
000901  1  FC           	STBA ZW
000902  1  73 15        	JMPR @Rtn
000904  1               
000904  1               @70: ; we hit a null
000904  1  D5 88 06     	LDBX ZW,ModNBRB,6	; n2=index of null
000907  1  51 42        	SUB BW,XW
000909  1  F5 88 02     	STBX ZW,ModNBRB,2
00090C  1  FC           	STBA ZW			; n3=index of null
00090D  1               
00090D  1  95 88 04     	LDAX ZW,ModNBRB,4	; n2==n1?
000910  1  51 20        	SUB AW,BW
000912  1  15 05        	BNZ @326
000914  1  30 20        	INR BW,1		;   n2+=1
000916  1  F5 88 02     	STBX ZW,ModNBRB,2
000919  1               @326:
000919  1  65 A1        @Rtn:	LDXX SW,ModBRPB,0	; pop X
00091B  1  09           	RSR			; return
00091C  1               
00091C  1               
00091C  1               ; FHdr 'Word',0 ; ( c -- addr )  ANSI
00091C  1                  ;	Parses one word from the input stream, using the character (usually blank) as a delimiter.
00091C  1                  ;	Moves the string to the address HERE with the count in the first byte, leaving the address on the stack.
00091C  1                  ; https://forth-standard.org/standard/core/WORD
00091C  1               
00091C  1               
00091C  1  57 6F 72 64   FHdr 'Word',0 ; ( c -- )  FIG
000920  1  04 08 D9     
000923  1                  ; Read the next text chars from the input stream being interpreted, until a delimiter
000923  1                  ; c is found, storing the packed char string beginning at the dictionary buffer HERE .
000923  1                  ; WORD leaves the char count in the 1st byte, the chars, and ends with 2 or more blanks.
000923  1                  ; Leading occurances of c are ignored.  If BLK is zero, text is taken from the
000923  1                  ; terminal input buffer, otherwise from the disc block stored in BLK .
000923  1                  ; See BLK IN
000923  1  91 70 74     Word:	LDAD VBlk		; if not terminal
000926  1  14 07        	BZ @1914
000928  1               
000928  1  B5 82        	STAX ZW,ModBMRB,0	;   get block ptr
00092A  1  79 19 04     	JSRD Block
00092D  1  73 05        	JMPR @1916		;  else
00092F  1               
00092F  1  91 70 68     @1914:	LDAD VTIB		;   get terminal buffer ptr
000932  1  B5 82        	STAX ZW,ModBMRB,0
000934  1               				;  then
000934  1               @1916:				; ( c buf )
000934  1               
000934  1  91 70 76     	LDAD VIn
000937  1  79 04 D4     	JSRD PlusA
00093A  1  79 02 A1     	JSRD Swap
00093D  1  79 08 D9     	JSRD Enclose		; ( buf n1 n2 n3 )
000940  1               
000940  1  91 70 70     	LDAD VDP		; output ptr
000943  1  5C           	XAY
000944  1               
000944  1  95 88 02     	LDAX ZW,ModNBRB,2	; store string length
000947  1  D5 88 04     	LDBX ZW,ModNBRB,4
00094A  1  59           	SAB
00094B  1  E5 61        	STBBX YW,ModBRPB,0
00094D  1               
00094D  1  95 88 06     	LDAX ZW,ModNBRB,6	; source addr
000950  1  D5 88 04     	LDBX ZW,ModNBRB,4
000953  1  58           	AAB
000954  1  85 68 FF     	LDABX YW,ModNBRB,$ff
000957  1  45 10        	XFRB AH,AL		; store chars
000959  1  85 21        @31:	LDABX BW,ModBRPB,0
00095B  1  A5 61        	STABX YW,ModBRPB,0
00095D  1  21 00        	DCRB AH
00095F  1  15 F8        	BNZ @31
000961  1               
000961  1  90 20 20     	LDAL $2020		; store blanks
000964  1  BB           	STAA YW
000965  1               
000965  1  79 0B 32     	JSRD In			; In+=n3
000968  1  79 07 DD     	JSRD PlusStore
00096B  1  30 85        	INR ZW,6		; drop n2 n1 buf
00096D  1  09           	RSR
00096E  1               
00096E  1               
00096E  1               	.if 0
00096E  1                FHdr 'Digit',0	; ( c n1 -- n2 true ) (ok)
00096E  1               		; ( c n1 ---  false ) (bad)
00096E  1                  ; Converts the ASCII char c (using base n1) to its binary equivalent n2,
00096E  1                  ; accompanied by a true flag.  If the conversion is invalid, leaves
00096E  1                  ; only a false flag.
00096E  1               	JSRD Abort ;???
00096E  1               	.endif
00096E  1               
00096E  1               
00096E  1  28 4E 75 6D   FHdr '(Number)',0 ; ( d1 addr1 -- d2 addr2 )
000972  1  62 65 72 29  
000976  1  08 09 23     
000979  1                  ; Convert the ASCII text beginning at addr1+1 with regard to BASE.  The new value
000979  1                  ; is accumulated into double number d1, being left as d2.  Addr2 is the address
000979  1                  ; of the first unconvertable digit.  Used by NUMBER.
000979  1               PNumber:
000979  1  9C           @1971:	LDAA ZW			; addr1+=1
00097A  1  38           	INA
00097B  1  BC           	STAA ZW
00097C  1  88           	LDABA AW		; get char
00097D  1  C0 D0        	LDBBL $100-'0'		; 0..9?
00097F  1  40 31        	ADDB AL,BL
000981  1  11 48        	BNL @bad
000983  1  C0 0A        	LDBBL 10
000985  1  49           	SABB
000986  1  11 18        	BNL @base
000988  1  C0 F9        	LDBBL $100-7
00098A  1  40 31        	ADDB AL,BL
00098C  1  C0 0A        	LDBBL 10		; A..Z?
00098E  1  49           	SABB
00098F  1  11 3A        	BNL @bad
000991  1  C1 70 85     	LDBBD 1+VBase
000994  1  49           	SABB
000995  1  11 0F        	BNL @ok
000997  1  C0 E0        	LDBBL $100-$20		; a..z?
000999  1  40 31        	ADDB AL,BL
00099B  1  C0 0A        	LDBBL 10
00099D  1  49           	SABB
00099E  1  11 2B        	BNL @bad
0009A0  1  C1 70 85     @base:	LDBBD 1+VBase		; >=base?
0009A3  1  49           	SABB
0009A4  1  10 25        	BL @bad
0009A6  1               @ok:
0009A6  1  DC           	LDBA ZW			; save addr1 on return stack
0009A7  1  F5 A2        	STBX SW,ModBMRB,0
0009A9  1  22 00        	CLRB AH
0009AB  1  BC           	STAA ZW			; ( ul uh digit )
0009AC  1               
0009AC  1  79 02 A1     	JSRD Swap		; ( ul digit uh )
0009AF  1  7B 1B        	JSRR @mul		; ( u1 digit dh )
0009B1  1  30 81        	INR ZW,2		; ( ul digit uh )
0009B3  1  79 02 80     	JSRD Rot		; ( digit uh ul )  ( n1 n2 n3 -- n2 n3 n1 )
0009B6  1  79 09 CC     	JSRD @mul		; ( digit uh dl )
0009B9  1  79 04 F8     	JSRD DPlus		; ( d2 )
0009BC  1  91 70 86     	LDAD VDPL		; decimal_places>=0?
0009BF  1  16 04        	BM @1998
0009C1  1  38           	INA
0009C2  1  B1 70 86     	STAD VDPL		;   increment decimal_places
0009C5  1               @1998:
0009C5  1  95 A1        	LDAX SW,ModBRPB,0	; pop addr1 from return stack  ( d2 addr )
0009C7  1  B5 82        	STAX ZW,ModBMRB,0
0009C9  1  73 AE        	JMPR @1971		; back for more digits
0009CB  1               
0009CB  1  09           @bad:	RSR			; we hit something not-a-number, return
0009CC  1               
0009CC  1  91 70 84     @mul:	LDAD VBase
0009CF  1  B5 82        	STAX ZW,ModBMRB,0
0009D1  1  71 06 B0     	JMPD UMStar
0009D4  1               
0009D4  1               
0009D4  1  4E 75 6D 62   FHdr 'Number',0 ; ( addr -- d )
0009D8  1  65 72 06 09  
0009DC  1  79           
0009DD  1                  ; Convert a character string left at addr with a preceeding count, to a signed
0009DD  1                  ; double number, using the current numeric base.  If a decimal point is encountered
0009DD  1                  ; in the text its position will be given in DPL, but no other effect occurs.
0009DD  1                  ; If numeric conversion is not possible, an error message will be given.
0009DD  1  6D A2        Number:	STXX SW,ModBMRB,0	; save X
0009DF  1  65 80        	LDXX ZW,ModBRB,0	; get addr
0009E1  1  3A           	CLA			; push 0.
0009E2  1  BC           	STAA ZW
0009E3  1  B5 82        	STAX ZW,ModBMRB,0
0009E5  1  31 81        	DCR ZW,2		; ( d addr )
0009E7  1               
0009E7  1  91 70 84     	LDAD VBase		; save default base
0009EA  1  B5 A2        	STAX SW,ModBMRB,0
0009EC  1  90 FF FF     	LDAL $ffff		; init decimal places to "no . found"
0009EF  1  B1 70 86     	STAD VDPL
0009F2  1               
0009F2  1  3E           	INXC			; skip string count byte
0009F3  1  8A           	LDABA XW		; look at next char
0009F4  1  C0 2D        	LDBBL '-'		; negative sign?
0009F6  1  49           	SABB
0009F7  1  E5 A2        	STBBX SW,ModBMRB,0	;   save this for finish
0009F9  1  15 02        	BNZ @17
0009FB  1  3E           	INXC			;   skip sign char
0009FC  1  8A           	LDABA XW
0009FD  1               @17:
0009FD  1  C0 24        	LDBBL '$'		;    hex?
0009FF  1  49           	SABB
000A00  1  14 1D        	BZ @Hex
000A02  1  C0 27        	LDBBL "'"		;    char literal?
000A04  1  49           	SABB
000A05  1  14 1E        	BZ @Char
000A07  1  3F           @29:	DCX			; save addr of remaining string-1
000A08  1  6D 80        	STXX ZW,ModBRB,0
000A0A  1               
000A0A  1  79 09 79     @2023:	JSRD PNumber		; do some digits
000A0D  1  85 84        	LDABX ZW,ModABRB,0	; look at next char
000A0F  1  C0 20        	LDBBL ' '		; blank?
000A11  1  49           	SABB
000A12  1  14 27        	BZ @2042
000A14  1  C0 2E        	LDBBL '.'		; '.'?
000A16  1  49           	SABB
000A17  1  15 1D        	BNZ @err
000A19  1  3A           	CLA			; remember the dot
000A1A  1  B1 70 86     	STAD VDPL
000A1D  1  73 EB        	JMPR @2023		; back for more chars
000A1F  1               
000A1F  1               @Hex:	; temporary hex base
000A1F  1  79 0D 30     	JSRD Hex
000A22  1  3E           	INXC
000A23  1  73 E2        	JMPR @29
000A25  1               
000A25  1               @Char: ; char literal
000A25  1  85 48 02     	LDABX XW,ModNBRB,2	; check ending delimiter
000A28  1  C0 27        	LDBBL "'"
000A2A  1  49           	SABB
000A2B  1  15 DA        	BNZ @29
000A2D  1  3A           	CLA			; get char
000A2E  1  85 48 01     	LDABX XW,ModNBRB,1
000A31  1  B5 88 04     	STAX ZW,ModNBRB,4
000A34  1  73 05        	JMPR @2042
000A36  1               
000A36  1  32 20        @err:	CLR BW,Err_0		; unconvertable digit, signal error
000A38  1  79 0F 5F     	JSRD ErrorY
000A3B  1               
000A3B  1               @2042:				; done
000A3B  1  30 81        	INR ZW,2		; drop addr
000A3D  1  85 A1        	LDABX SW,ModBRPB,0	; was there a '-' sign?
000A3F  1  15 03        	BNZ @2047
000A41  1  79 05 4E     	JSRD DNegate		;   negate the result
000A44  1               @2047:
000A44  1  95 A1        	LDAX SW,ModBRPB,0	; restore base
000A46  1  B1 70 84     	STAD VBase
000A49  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
000A4B  1  09           	RSR			; return
000A4C  1               
000A4C  1               
000A4C  1               	.if 0
000A4C  1                FHdr '>Number',0 ; ( ud1 addr1 u1 — ud2 addr2 u2 )
000A4C  1                  ;Return value ud2 is the unsigned result of converting the characters within the string specified
000A4C  1                  ; by addr1 u1 into digits, using the number in BASE, and adding each into ud1 after multiplying
000A4C  1                  ; ud1 by the number in BASE. Conversion continues left-to-right until a character that is not
000A4C  1                  ; convertible, including any “+” or “-“, is encountered or the string is entirely converted.
000A4C  1                  ; Address addr2 is the location of the first unconverted character or the first character past
000A4C  1                  ; the end of the string if the string was entirely converted.
000A4C  1                  ; Length u2 is the number of unconverted characters in the string.
000A4C  1               	JSRD Abort ;???
000A4C  1               	.endif
000A4C  1               
000A4C  1               
000A4C  1               ; These small numbers are used so often that it is attractive to define them
000A4C  1               ; by name in the dictionary as constants.
000A4C  1               
000A4C  1  30 81 09 DD   FHdr '0',ha_inline ; ( -- n )  constant: 0
000A50  1  3A           Zero:	CLA
000A51  1  B5 82        	STAX ZW,ModBMRB,0
000A53  1  09 09        	.dbyt INL_End
000A55  1               
000A55  1               
000A55  1  31 81 0A 50   FHdr '1',ha_inline ; ( -- n )  constant: 1
000A59  1  32 01        One:	CLR AW,1
000A5B  1  B5 82        	STAX ZW,ModBMRB,0
000A5D  1  09 09        	.dbyt INL_End
000A5F  1               
000A5F  1               
000A5F  1  32 81 0A 59   FHdr '2',ha_inline ; ( -- n )  constant: 2
000A63  1  32 02        Two:	CLR AW,2
000A65  1  B5 82        	STAX ZW,ModBMRB,0
000A67  1  09 09        	.dbyt INL_End
000A69  1               
000A69  1               
000A69  1  33 81 0A 63   FHdr '3',ha_inline ; ( -- n )  constant: 3
000A6D  1  32 03        Three:	CLR AW,3
000A6F  1  B5 82        	STAX ZW,ModBMRB,0
000A71  1  09 09        	.dbyt INL_End
000A73  1               
000A73  1               
000A73  1  42 6C 82 0A   FHdr 'Bl',ha_inline ; ( -- n )	constant: the ASCII value for "blank".
000A77  1  6D           
000A78  1               ; https://forth-standard.org/standard/core/BL
000A78  1  90 00 20     Bl:	LDAL ' '		; push a blank & return
000A7B  1  B5 82        	STAX ZW,ModBMRB,0
000A7D  1  09 09        	.dbyt INL_End
000A7F  1               
000A7F  1               
000A7F  1  43 2F 4C 03   FHdr 'C/L',0 ; ( -- n )  constant: chars per screen line
000A83  1  0A 78        
000A85  1  90 00 40     CSlashL: LDAL 64
000A88  1  B5 82        	STAX ZW,ModBMRB,0
000A8A  1  09           	RSR
000A8B  1               
000A8B  1               
000A8B  1  42 2F 42 75   FHdr 'B/Buf',0 ; ( -- n )  constant: number of bytes per disc buffer,
000A8F  1  66 05 0A 85  
000A93  1               			; the byte count read from disc by BLOCK.
000A93  1  90 01 00     BBuf:	LDAL SectorSize
000A96  1  B5 82        	STAX ZW,ModBMRB,0
000A98  1  09           	RSR
000A99  1               
000A99  1               
000A99  1  42 2F 53 63   FHdr 'B/Scr',0 ; ( -- n )  constant: number of blocks per editing screen.
000A9D  1  72 05 0A 93  
000AA1  1               		; By convention, an editing screen is 1024 bytes organized as 16 lines of 64 chars each.
000AA1  1  90 00 04     BScr:	LDAL 1024/SectorSize
000AA4  1  B5 82        	STAX ZW,ModBMRB,0
000AA6  1  09           	RSR
000AA7  1               
000AA7  1               
000AA7  1  2B 4F 72 69   FHdr '+Origin',0 ; ( n -- adr )  Memory address relative by n to the origin parameter area.
000AAB  1  67 69 6E 07  
000AAF  1  0A A1        
000AB1  1               	; n is the minimum address unit, either byte or word.
000AB1  1               	; This definition is used to access or modify the boot-up parameters at the origin area.
000AB1  1  90 02 00     POrig:	LDAL ORIG
000AB4  1  71 04 D4     	JMPD PlusA
000AB7  1               
000AB7  1               
000AB7  1  55 73 65 72   FHdr 'User',0 ;
000ABB  1  04 0A B1     
000ABE  1                  ; A defining word used in the form:
000ABE  1                  ;	n USER cccc
000ABE  1                  ; which creates a user variable cccc.
000ABE  1                  ; When cccc is later executed, it places the sum of its offset and the user area
000ABE  1                  ; base address on the stack as the storage address of that particular variable.
000ABE  1  79 12 B7     User:	JSRD HeaderComma	; compile word header
000AC1  1  79 11 1F     	JSRD LdaImmedComma	; compile "ldal n"
000AC4  1  90 0B 53     	LDAL DoUser		; compile "jmp DoUser" & return
000AC7  1  71 10 EA     	JMPD JmpCommaA
000ACA  1               
000ACA  1               
000ACA  1  42 53 02 0A   FHdr 'BS',0 ; ( -- n )	User variable
000ACE  1  BE           
000ACF  1  90 70 60     BS:	LDAL VBS
000AD2  1  73 7F        	JMPR DoUser
000AD4  1               
000AD4  1               
000AD4  1  54 49 42 03   FHdr 'TIB',0 ; ( -- adr )  User variable
000AD8  1  0A CF        
000ADA  1  90 70 68     TIB:	LDAL VTIB
000ADD  1  73 74        	JMPR DoUser
000ADF  1               
000ADF  1               
000ADF  1               	.if 0
000ADF  1                FHdr '#TIB',0 ; ( — addr )  User variable
000ADF  1               	HLT ; ??Contains the size of the contents of the terminal input buffer.
000ADF  1               	.endif
000ADF  1               
000ADF  1               
000ADF  1  57 69 64 74   FHdr 'Width',0 ; ( -- adr )  User variable
000AE3  1  68 05 0A DA  
000AE7  1  90 70 6A     Width:	LDAL VWidth
000AEA  1  73 67        	JMPR DoUser
000AEC  1               
000AEC  1               
000AEC  1  57 61 72 6E   FHdr 'Warning',0 ; ( -- adr )  User variable
000AF0  1  69 6E 67 07  
000AF4  1  0A E7        
000AF6  1  90 70 6C     Warning: LDAL VWarning
000AF9  1  73 58        	JMPR DoUser
000AFB  1               
000AFB  1               
000AFB  1  46 65 6E 63   FHdr 'Fence',0 ; ( -- adr )  User variable
000AFF  1  65 05 0A F6  
000B03  1  90 70 6E     Fence:	LDAL VFence
000B06  1  73 4B        	JMPR DoUser
000B08  1               
000B08  1               
000B08  1  44 50 02 0B   FHdr 'DP',0 ; ( -- adr )  User variable
000B0C  1  03           
000B0D  1  90 70 70     DP:	LDAL VDP
000B10  1  73 41        	JMPR DoUser
000B12  1               
000B12  1               
000B12  1  56 6F 63 2D   FHdr 'Voc-Link',0 ; ( -- adr )  User variable
000B16  1  4C 69 6E 6B  
000B1A  1  08 0B 0D     
000B1D  1  90 70 72     VocL:	LDAL VVoc_Link
000B20  1  73 31        	JMPR DoUser
000B22  1               
000B22  1               
000B22  1  42 6C 6B 03   FHdr 'Blk',0 ; ( -- adr )  User variable
000B26  1  0B 1D        
000B28  1  90 70 74     Blk:	LDAL VBlk
000B2B  1  73 26        	JMPR DoUser
000B2D  1               
000B2D  1               
000B2D  1  49 6E 02 0B   FHdr 'In',0 ; ( -- adr )  User variable
000B31  1  28           
000B32  1  90 70 76     In:	LDAL VIn
000B35  1  73 1C        	JMPR DoUser
000B37  1               
000B37  1               
000B37  1  3E 49 4E 03   FHdr '>IN',0 ; ( -- a-addr )
000B3B  1  0B 32        
000B3D  1                  ; a-addr is the address of a cell containing the offset in characters from the start of the input
000B3D  1                  ; buffer to the start of the parse area.
000B3D  1                  ; https://forth-standard.org/standard/core/toIN
000B3D  1  73 F3        ToIn:	JMPR In
000B3F  1               
000B3F  1               
000B3F  1  4F 75 74 03   FHdr 'Out',0 ; ( -- adr )  User variable
000B43  1  0B 3D        
000B45  1  90 70 78     Out:	LDAL VOut
000B48  1  73 09        	JMPR DoUser
000B4A  1               
000B4A  1               
000B4A  1  53 63 72 03   FHdr 'Scr',0 ; ( -- adr )  User variable
000B4E  1  0B 45        
000B50  1  90 70 7A     Scr:	LDAL VScr
000B53  1               ;	JMPR DoUser
000B53  1               
000B53  1               
000B53  1               DoUser: ; runtime.  Push A + user area base
000B53  1  B5 82        	STAX ZW,ModBMRB,0	; push A
000B55  1               ;	LDBD VUA		; add user area base
000B55  1               ;	AAB
000B55  1               ;	STBX ZW,ModBMRB,0	; push B
000B55  1  09           	RSR			; return
000B56  1               
000B56  1               
000B56  1  4F 66 66 73   FHdr 'Offset',0 ; ( -- adr )  User variable
000B5A  1  65 74 06 0B  
000B5E  1  50           
000B5F  1  90 70 7C     Offset:	LDAL VOffset
000B62  1  73 EF        	JMPR DoUser
000B64  1               
000B64  1               
000B64  1  43 6F 6E 74   FHdr 'Context',0 ; ( -- adr )  User variable
000B68  1  65 78 74 07  
000B6C  1  0B 5F        
000B6E  1  90 70 7E     Context: LDAL VContext
000B71  1  73 E0        	JMPR DoUser
000B73  1               
000B73  1               
000B73  1  43 75 72 72   FHdr 'Current',0 ; ( -- adr )  User variable
000B77  1  65 6E 74 07  
000B7B  1  0B 6E        
000B7D  1  90 70 80     Current: LDAL VCurrent
000B80  1  73 D1        	JMPR DoUser
000B82  1               
000B82  1               
000B82  1  53 74 61 74   FHdr 'State',0 ; ( -- adr )  User variable
000B86  1  65 05 0B 7D  
000B8A  1  90 70 82     State:	LDAL VState
000B8D  1  73 C4        	JMPR DoUser
000B8F  1               
000B8F  1               
000B8F  1  42 61 73 65   FHdr 'Base',0 ; ( -- adr )  User variable
000B93  1  04 0B 8A     
000B96  1  90 70 84     Base:	LDAL VBase
000B99  1  73 B8        	JMPR DoUser
000B9B  1               
000B9B  1               
000B9B  1  44 50 4C 03   FHdr 'DPL',0 ; ( -- adr )  User variable
000B9F  1  0B 96        
000BA1  1  90 70 86     DPL:	LDAL VDPL
000BA4  1  73 AD        	JMPR DoUser
000BA6  1               
000BA6  1               
000BA6  1  46 6C 64 03   FHdr 'Fld',0 ; ( -- adr )  User variable
000BAA  1  0B A1        
000BAC  1  90 70 88     Fld:	LDAL VFld
000BAF  1  73 A2        	JMPR DoUser
000BB1  1               
000BB1  1               
000BB1  1  43 53 50 03   FHdr 'CSP',0 ; ( -- adr )  User variable
000BB5  1  0B AC        
000BB7  1  90 70 8A     CSP:	LDAL VCSP
000BBA  1  73 97        	JMPR DoUser
000BBC  1               
000BBC  1               
000BBC  1  52 23 02 0B   FHdr 'R#',0 ; ( -- adr )  User variable
000BC0  1  B7           
000BC1  1  90 70 8C     RNum:	LDAL VRNum
000BC4  1  71 0B 53     	JMPD DoUser
000BC7  1               
000BC7  1               
000BC7  1  48 6C 64 03   FHdr 'Hld',0 ; ( -- adr )  User variable
000BCB  1  0B C1        
000BCD  1  90 70 8E     Hld:	LDAL VHld
000BD0  1  71 0B 53     	JMPD DoUser
000BD3  1               
000BD3  1               
000BD3  1               	.if 0
000BD3  1                FHdr 'N',0 ; ( -- adr )  User variable
000BD3  1               N:	LDAL VN
000BD3  1               	JMPD DoUser
000BD3  1               	.endif
000BD3  1               
000BD3  1               
000BD3  1  46 50 74 72   FHdr 'FPtr',0 ; ( -- adr )  User variable
000BD7  1  04 0B CD     
000BDA  1  90 70 91     FPtr:	LDAL VFPtr
000BDD  1  71 0B 53     	JMPD DoUser
000BE0  1               
000BE0  1               
000BE0  1  46 70 4C 6F   FHdr 'FpLo',0 ; ( -- adr )  User variable
000BE4  1  04 0B DA     
000BE7  1  90 70 93     FpLo:	LDAL VFpLo
000BEA  1  71 0B 53     	JMPD DoUser
000BED  1               
000BED  1               
000BED  1  46 70 48 69   FHdr 'FpHi',0 ; ( -- adr )  User variable
000BF1  1  04 0B E7     
000BF4  1  90 70 95     FpHi:	LDAL VFpHi
000BF7  1  71 0B 53     	JMPD DoUser
000BFA  1               
000BFA  1               
000BFA  1  48 65 72 65   FHdr 'Here',0 ; ( -- n )  Leave the address of the next available dictionary location.
000BFE  1  04 0B F4     
000C01  1                  ; https://forth-standard.org/standard/core/HERE
000C01  1  91 70 70     Here:	LDAD VDP		; get next available dictionary location
000C04  1  B5 82        	STAX ZW,ModBMRB,0	; push it
000C06  1  09           	RSR			; return
000C07  1               
000C07  1               
000C07  1  4C 61 74 65   FHdr 'Latest',0 ; ( -- addr )
000C0B  1  73 74 06 0C  
000C0F  1  01           
000C10  1                  ; Leave the code field address of the topmost word in the CURRENT vocabulary.
000C10  1  92 70 80     Latest:	LDAI VCurrent
000C13  1  B5 82        	STAX ZW,ModBMRB,0	; push A
000C15  1  09           	RSR
000C16  1               
000C16  1               
000C16  1  43 4D 6F 76   FHdr 'CMove',0 ; ( src_addr dest_addr len -- )
000C1A  1  65 05 0C 10  
000C1E  1                  ; Move the specified quantity of bytes beginning at src_addr to dest_addr.
000C1E  1                  ; The contents of src_addr is moved first proceeding toward high memory.
000C1E  1                  ; Further specification is necessary on word addressing computers.
000C1E  1                  ; This would probably run faster if it took advantage of word load & store.
000C1E  1                  ; https://forth-standard.org/standard/string/CMOVE
000C1E  1                  ; Also: CPU6 0xf7 memcpy instruction
000C1E  1  6D A2        CMove:	STXX SW,ModBMRB,0	; save X
000C20  1  65 81        	LDXX ZW,ModBRPB,0	; pop len
000C22  1  95 81        	LDAX ZW,ModBRPB,0	; pop dest
000C24  1  5C           	XAY
000C25  1  D5 81        	LDBX ZW,ModBRPB,0	; pop src
000C27  1  55 44        	XFR XW,XW		; len=0?
000C29  1  14 07        	BZ @Done
000C2B  1  85 21        @4:	LDABX BW,ModBRPB,0	; copy a byte
000C2D  1  A5 61        	STABX YW,ModBRPB,0
000C2F  1  3F           	DCX
000C30  1  15 F9        	BNZ @4
000C32  1  65 A1        @Done:	LDXX SW,ModBRPB,0	; restore X
000C34  1  09           	RSR
000C35  1               
000C35  1               
000C35  1  43 4D 6F 76   FHdr 'CMove>',0 ; ( src_addr dest_addr len -- )
000C39  1  65 3E 06 0C  
000C3D  1  1E           
000C3E  1                  ; Move the specified quantity of bytes beginning at src_addr to dest_addr.
000C3E  1                  ; Moves proceeding toward low memory.
000C3E  1                  ; This would probably run faster if it took advantage of word load & store.
000C3E  1                  ; https://forth-standard.org/standard/string/CMOVEtop
000C3E  1  6D A2        CMoveG:	STXX SW,ModBMRB,0	; save X
000C40  1  65 81        	LDXX ZW,ModBRPB,0	; pop len
000C42  1  95 81        	LDAX ZW,ModBRPB,0	; pop dest
000C44  1  5C           	XAY
000C45  1  D5 81        	LDBX ZW,ModBRPB,0	; pop src
000C47  1  55 44        	XFR XW,XW		; len=0?
000C49  1  14 0B        	BZ @Done
000C4B  1  50 42        	ADD BW,XW
000C4D  1  50 46        	ADD YW,XW
000C4F  1  85 22        @4:	LDABX BW,ModBMRB,0	; copy a byte
000C51  1  A5 62        	STABX YW,ModBMRB,0
000C53  1  3F           	DCX
000C54  1  15 F9        	BNZ @4
000C56  1  65 A1        @Done:	LDXX SW,ModBRPB,0	; restore X
000C58  1  09           	RSR
000C59  1               
000C59  1               
000C59  1  4D 6F 76 65   FHdr 'Move',0 ; ( src_addr dest_addr len -- )
000C5D  1  04 0C 3E     
000C60  1                  ; After this move, the u bytes at addr2 contain exactly what the u bytes at addr1 contained before
000C60  1                  ; the move (no “clobbering” occurs).
000C60  1                  ; https://forth-standard.org/standard/core/MOVE
000C60  1  95 88 04     Move:	LDAX ZW,ModNBRB,4
000C63  1  D5 88 02     	LDBX ZW,ModNBRB,2
000C66  1  59           	SAB
000C67  1  10 B5        	BL CMove
000C69  1  73 D3        	JMPR CMoveG
000C6B  1               
000C6B  1               
000C6B  1               	.if 0
000C6B  1                FHdr 'Compare',0 ; ( addr1 u1 addr2 u2 — n )
000C6B  1                  ;Compare the string specified by addr1 and u1 to the string specified by addr2 and u2.
000C6B  1                  ; The strings are compared, beginning at the given addresses, character by character up
000C6B  1                  ; to the length of the shorter string, or until a difference is found.
000C6B  1                  ; If both strings are the same up to the length of the shorter string, then the longer
000C6B  1                  ; string is greater than the shorter string.
000C6B  1                  ; n is -1 if the string specified by addr1 and u1 is less than the string specified by addr2 and u2.
000C6B  1                  ; n is zero if the strings are equal.
000C6B  1                  ; n is 1 if the string specified by addr1 and u1 is greater than the string specified by addr2 and u2.
000C6B  1                  ; https://forth-standard.org/standard/string/COMPARE
000C6B  1               Compare:
000C6B  1               	STXX SW,ModBMRB,0	; save X
000C6B  1               	XFR AW,ZW		; save Z
000C6B  1               	STAX SW,ModBMRB,0
000C6B  1               
000C6B  1               	JSRD Abort ;???
000C6B  1               
000C6B  1               	LDBX ZW,ModBRPB,0	; pop u2
000C6B  1               	LDAZ ZW,ModBRPB,0	; pop addr2
000C6B  1               	XAY
000C6B  1               	LDAX ZW,ModBRPB,0	; pop u2
000C6B  1               	SAB
000C6B  1               	STBA ZW			; save u1-u2
000C6B  1               	BL @17
000C6B  1               	LDAA ZW
000C6B  1               @17:	XAY			; save min(u1,u2)
000C6B  1               	XFR AW,ZW		; push Z
000C6B  1               	STAX SW,ModBMRB,0
000C6B  1               
000C6B  1               	LDAX ZW,ModNBRB,2	; X = addr2
000C6B  1               	XAX
000C6B  1               	LDAX ZW,ModNBRB,6	; Z = addr1
000C6B  1               	XAZ
000C6B  1               @12:	DCR YW,1
000C6B  1               	BZ @30
000C6B  1               	LDABX XW,ModBRPB,0	; get chars
000C6B  1               	LDBBX ZW,ModBRPB,0
000C6B  1               	SABB
000C6B  1               	BZ @12
000C6B  1               
000C6B  1               @20:	CLR BW,0
000C6B  1               	RLR BW,2
000C6B  1               	INR SW,2		; rdrop u1-u2
000C6B  1               @22:	LDAA SW			; restore Z
000C6B  1               	XAZ
000C6B  1               	INR ZW,6		; drop u2, addr2, u1
000C6B  1               	STBA ZW			; save n
000C6B  1               	LDXX SW,ModBRPB,0	; restore X
000C6B  1               	RSR
000C6B  1               
000C6B  1               @30: ; chars are equal, compare lengths
000C6B  1               
000C6B  1               	.endif
000C6B  1               
000C6B  1               
000C6B  1  46 69 6C 6C   FHdr 'Fill',0 ; ( adr len value -- )  Fill memory at the address with the specified quantity of bytes value.
000C6F  1  04 0C 60     
000C72  1                  ; https://forth-standard.org/standard/core/FILL
000C72  1  D5 81        Fill:	LDBX ZW,ModBRPB,0	; pop value
000C74  1  55 46        Fill1:	XFR YW,XW		; save X
000C76  1  95 81        	LDAX ZW,ModBRPB,0	; pop len
000C78  1  38           	INA
000C79  1  65 81        	LDXX ZW,ModBRPB,0	; pop adr
000C7B  1  73 02        	JMPR @8
000C7D  1               
000C7D  1  E5 41        @2:	STBBX XW,ModBRPB,0	; store a byte
000C7F  1  39           @8:	DCA			; count it
000C80  1  15 FB        	BNZ @2
000C82  1  55 64        	XFR XW,YW		; restore X
000C84  1  09           	RSR
000C85  1               
000C85  1               
000C85  1  45 72 61 73   FHdr 'Erase',0 ; ( adr len -- )  Clear a region of memory to zero from addr over len addresses.
000C89  1  65 05 0C 72  
000C8D  1                  ; https://forth-standard.org/standard/core/ERASE
000C8D  1  C0 00        Erase:	LDBBL 0			; fill value
000C8F  1  73 E3        	JMPR Fill1		; do Fill, & return
000C91  1               
000C91  1               
000C91  1  42 6C 61 6E   FHdr 'Blanks',0 ; ( adr count -- )  Fill an area of memory beginning at addr with blanks.
000C95  1  6B 73 06 0C  
000C99  1  8D           
000C9A  1                  ; https://forth-standard.org/standard/string/BLANK
000C9A  1  C0 20        Blanks:	LDBBL ' '		; fill value
000C9C  1  73 D6        	JMPR Fill1		; do Fill, & return
000C9E  1               
000C9E  1               ;----------------------
000C9E  1               ; 1st Terminal muliplexer port
000C9E  1               
000C9E  1               Term0CmdStat = $f200	; command (Write) & status (Read)
000C9E  1               Term0Data = $f201	; data tx (Write) & rx (Read)
000C9E  1               
000C9E  1               ;TermInit:
000C9E  1               ;	LDABL $c5		; configure UART - 9600,n,8,1
000C9E  1               ;	STABD Term0CmdStat
000C9E  1               ;	RSR
000C9E  1               
000C9E  1               
000C9E  1  4B 65 79 03   FHdr 'Key',0 ; ( -- n )
000CA2  1  0C 9A        
000CA4  1                  ; Leave the ASCII value of the next terminal key struck.
000CA4  1                  ; https://forth-standard.org/standard/core/KEY
000CA4  1               Key:
000CA4  1               	.if 1
000CA4  1  71 1D B9     	JMPD Tty_GetC
000CA7  1               
000CA7  1               KeyA = Tty_GetC_A ; reads one terminal keystroke to A
000CA7  1               
000CA7  1               	.else
000CA7  1               
000CA7  1               	JSRR KeyA
000CA7  1               	STAX ZW,ModBMRB,0	; push it on param stack
000CA7  1               	RSR			; return
000CA7  1               
000CA7  1               KeyA: ; reads one terminal keystroke to A
000CA7  1               @1:	LDABD Term0CmdStat	; char ready?
000CA7  1               	SRAB
000CA7  1               	BNL @Empty
000CA7  1               	CLA			; get char
000CA7  1               	LDABD Term0Data
000CA7  1               	LDBBL $7f		; strip hi bit
000CA7  1               	ANDB AL,BL
000CA7  1               	RSR
000CA7  1               
000CA7  1               @Empty:	; queue empty
000CA7  1               ;	JSRD Pause		; wait awhile
000CA7  1               	JMPR @1			; & try again
000CA7  1               
000CA7  1               	.endif
000CA7  1               
000CA7  1               
000CA7  1  3F 54 65 72   FHdr '?Terminal',0 ; ( -- f )
000CAB  1  6D 69 6E 61  
000CAF  1  6C 09 0C A4  
000CB3  1                  ; Perform a test of the terminal keyboard for actuation of the break key.
000CB3  1                  ; A true flags indicates actuation.
000CB3  1                  ; This definition is installation dependent.
000CB3  1               QTerminal:
000CB3  1               	.if 1
000CB3  1  71 1D DF     	JMPD Tty_Next
000CB6  1               
000CB6  1               QTerminalA:
000CB6  1  7B FB        	JSRR QTerminal
000CB8  1  95 81        	LDAX ZW,ModBRPB,0	; set flags too
000CBA  1  09           	RSR
000CBB  1               
000CBB  1               	.else
000CBB  1               	JSRR QTerminalA
000CBB  1               	STAX ZW,ModBMRB,0	; push it
000CBB  1               	RSR			; return
000CBB  1               
000CBB  1               QTerminalA: ; leaves a boolean in A & V flag representing terminal break
000CBB  1               	CLA
000CBB  1               	LDABD Term0CmdStat
000CBB  1               	LDBL 1
000CBB  1               	ANDC AW,BW
000CBB  1               	RSR
000CBB  1               	.endif
000CBB  1               
000CBB  1               
000CBB  1  45 6D 69 74   FHdr 'Emit',0 ; ( n -- )
000CBF  1  04 0C B3     
000CC2  1                  ; Transmit ASCII char n to the selected output device.
000CC2  1                  ; OUT is incremented for each char output.
000CC2  1                  ; https://forth-standard.org/standard/core/EMIT
000CC2  1               Emit:	; writes one ASCII character to terminal
000CC2  1  91 70 78     	LDAD VOut	; count the char
000CC5  1  38           	INA
000CC6  1  B1 70 78     	STAD VOut
000CC9  1               	.if 1
000CC9  1  71 1D 79     	JMPD Tty_PutC
000CCC  1               	.else
000CCC  1               @1:	LDABD Term0CmdStat ; ready?
000CCC  1               	SRAB
000CCC  1               	SRAB
000CCC  1               	BNL @Full
000CCC  1               
000CCC  1               	LDAX ZW,ModBRPB,0	; pop n
000CCC  1               	STABD Term0Data		; transmit it
000CCC  1               	RSR
000CCC  1               
000CCC  1               @Full:	; queue full
000CCC  1               ;	JSRD Pause		; wait awhile
000CCC  1               	JMPR @1			; & try again
000CCC  1               	.endif
000CCC  1               
000CCC  1               
000CCC  1               EmitA: ; writes one ASCII character in A to terminal
000CCC  1  B5 82        	STAX ZW,ModBMRB,0	; push char
000CCE  1  F5 A2        	STBX SW,ModBMRB,0	; push B
000CD0  1  55 62        	XFR BW,YW		; push Y
000CD2  1  F5 A2        	STBX SW,ModBMRB,0
000CD4  1  7B EC        	JSRR Emit		; do it
000CD6  1  95 A1        	LDAX SW,ModBRPB,0	; pop Y
000CD8  1  5C           	XAY
000CD9  1  D5 A1        	LDBX SW,ModBRPB,0	; pop B
000CDB  1  09           	RSR
000CDC  1               
000CDC  1               
000CDC  1  43 52 02 0C   FHdr 'CR',0 ; ( -- )  Transmit a carriage return and line feed to the selected output device.
000CE0  1  C2           
000CE1  1                  ; https://forth-standard.org/standard/core/CR
000CE1  1  80 0D        CR:	LDABL $0d		; send CR
000CE3  1  7B E7        	JSRR EmitA
000CE5  1  80 0A        	LDABL $0a		; send LF
000CE7  1  7B E3        	JSRR EmitA
000CE9  1  3A           	CLA			; clear output position
000CEA  1  B1 70 78     	STAD VOut
000CED  1  09           	RSR
000CEE  1               
000CEE  1               
000CEE  1  53 70 61 63   FHdr 'Space',0 ; ( -- )  InseRSR an ASCII blank to the output device.
000CF2  1  65 05 0C E1  
000CF6  1                  ; https://forth-standard.org/standard/core/SPACE
000CF6  1  80 20        Space:	LDABL ' '
000CF8  1  73 D2        	JMPR EmitA
000CFA  1               
000CFA  1               
000CFA  1  53 70 61 63   FHdr 'Spaces',0 ; ( n -- )  Transmit n ASCII blanks to the output device.
000CFE  1  65 73 06 0C  
000D02  1  F6           
000D03  1                  ; https://forth-standard.org/standard/core/SPACES
000D03  1  73 03        Spaces:	JMPR @8
000D05  1               
000D05  1  BC           @2:	STAA ZW			; save n
000D06  1  7B EE        	JSRR Space		; type 1 space
000D08  1  9C           @8:	LDAA ZW			; load n
000D09  1  39           	DCA			; decrement n
000D0A  1  17 F9        	BP @2			; >=0?
000D0C  1  30 81        	INR ZW,2		; drop n
000D0E  1  09           	RSR			; return
000D0F  1               
000D0F  1               
000D0F  1  54 79 70 65   FHdr 'Type',0 ; ( adr len -- )  Transmit len chars from addr to the selected output device.
000D13  1  04 0D 03     
000D16  1                  ; https://forth-standard.org/standard/core/TYPE
000D16  1  9C           Type:	LDAA ZW			; test remaining length
000D17  1  14 0E        	BZ @9
000D19  1  39           	DCA			; decrement length
000D1A  1  BC           	STAA ZW
000D1B  1  D5 88 02     	LDBX ZW,ModNBRB,2	; get addr
000D1E  1  85 21        	LDABX BW,ModBRPB,0	; get char
000D20  1  F5 88 02     	STBX ZW,ModNBRB,2	; save updated addr
000D23  1  7B A7        	JSRR EmitA		; send to console
000D25  1  73 EF        	JMPR Type
000D27  1               
000D27  1  30 83        @9:	INR ZW,4		; pop len & adr
000D29  1  09           	RSR			; return
000D2A  1               
000D2A  1               
000D2A  1  48 65 78 03   FHdr 'Hex',0 ; ( -- )  Set the numeric conversion base to sixteen (hexadecimal).
000D2E  1  0D 16        
000D30  1                  ; https://forth-standard.org/standard/core/HEX
000D30  1  90 00 10     Hex:	LDAL 16			; Base=16
000D33  1  73 0C        	JMPR Decim3
000D35  1               
000D35  1               
000D35  1  44 65 63 69   FHdr 'Decimal',0 ; ( -- )  set the numeric conversion base for decimal input-output.
000D39  1  6D 61 6C 07  
000D3D  1  0D 30        
000D3F  1                  ; https://forth-standard.org/standard/core/DECIMAL
000D3F  1  32 0A        Decimal: CLR AW,10		; Base=10
000D41  1  B1 70 84     Decim3:	STAD VBase
000D44  1  09           	RSR
000D45  1               
000D45  1               
000D45  1               	.if 0
000D45  1                FHdr 'Octal',0 ; ( -- )  set the numeric conversion base for octa input-output.
000D45  1               Decimal: CLR AW,8		; Base=8
000D45  1               	JMPR Decim3
000D45  1               	.endif
000D45  1               
000D45  1               
000D45  1               PadSize = 68	; PAD is 68 ( C/L + a little) bytes above here.
000D45  1               
000D45  1  50 61 64 03   FHdr 'Pad',0 ; ( -- adr )  address of the text output buffer, which is a fixed offset above HERE .
000D49  1  0D 3F        
000D4B  1                  ; https://forth-standard.org/standard/core/PAD
000D4B  1  7B 03        Pad:	JSRR PadA		; get Pad in A
000D4D  1  B5 82        	STAX ZW,ModBMRB,0	; push it
000D4F  1  09           	RSR			; return
000D50  1               
000D50  1  91 70 70     PadA:	LDAD VDP		; get dictionary location
000D53  1  D0 00 44     	LDBL PadSize
000D56  1  50 20        	ADD AW,BW
000D58  1  09           	RSR
000D59  1               
000D59  1               
000D59  1  3C 23 02 0D   FHdr '<#',0 ; ( --- )
000D5D  1  4B           
000D5E  1                  ; Setup for pictured numeric output formatting using the words:
000D5E  1                  ;	<# # #S SIGN #>
000D5E  1                  ; The conversion is done on a double number producting text at PAD .
000D5E  1                  ; https://forth-standard.org/standard/core/num-start
000D5E  1  7B F0        BDigs:	JSRR PadA		; Hld= PAD addr
000D60  1  B1 70 8E     	STAD VHld
000D63  1  09           	RSR			; return
000D64  1               
000D64  1               
000D64  1  48 6F 6C 64   FHdr 'Hold',0 ; ( c -- )
000D68  1  04 0D 5E     
000D6B  1                  ; Used between <# and #> to insert an ASCII char into a pictured numeric
000D6B  1                  ; output string.  e.g. 2E HOLD will place a decimal point.
000D6B  1                  ; https://forth-standard.org/standard/core/HOLD
000D6B  1  95 81        Hold:	LDAX ZW,ModBRPB,0	; pop c
000D6D  1  D1 70 8E     HoldA:	LDBD VHld
000D70  1  A5 22        	STABX BW,ModBMRB,0	; decr addr & store char
000D72  1  F1 70 8E     	STBD VHld
000D75  1  09           	RSR			; return
000D76  1               
000D76  1               
000D76  1               	.if 0
000D76  1                FHdr 'HoldS',0 ; ( c-addr u -- )
000D76  1                  ; Adds the string represented by c-addr u to the pictured numeric output string.
000D76  1                  ; An ambiguous condition exists if HOLDS executes outside of a <# #> delimited number conversion.
000D76  1                  ; https://forth-standard.org/standard/core/HOLDS
000D76  1               HoldS:	LDAX ZW,ModNBRB,2	; get c-addr
000D76  1               	XAY
000D76  1               @11:	LDAA ZW			; get u
000D76  1               	BZ @19
000D76  1               	DCA
000D76  1               	STAA ZW
000D76  1               	LDABX YW,ModBRPB,0	; get char
000D76  1               	JSRD EmitA
000D76  1               	JMPR @11
000D76  1               
000D76  1               @19:	INR ZW,4		; drop u & c-addr
000D76  1               	RSR
000D76  1               	.endif
000D76  1               
000D76  1               
000D76  1  23 3E 02 0D   FHdr '#>',0 ; ( ud -- adr count )
000D7A  1  6B           
000D7B  1                  ; Terminates numeric output conversion by dropping ud, leaving the text
000D7B  1                  ; addres and char count suitable for TYPE.
000D7B  1                  ; https://forth-standard.org/standard/core/num-end
000D7B  1  91 70 8E     EDigs:	LDAD VHld
000D7E  1  B5 88 02     	STAX ZW,ModNBRB,2	; store adr
000D81  1  79 0D 50     	JSRD PadA		; count=PAD-Hld
000D84  1  D1 70 8E     	LDBD VHld
000D87  1  59           	SAB
000D88  1  FC           	STBA ZW			; store count
000D89  1  09           	RSR			; return
000D8A  1               
000D8A  1               
000D8A  1  53 69 67 6E   FHdr 'Sign',0 ; ( n d -- d )
000D8E  1  04 0D 7B     
000D91  1                  ; Stores an ASCII '-' sign just before a converted numeric output string in the text
000D91  1                  ; buffer when n is negative.  n is discarded, but double number d is maintained.
000D91  1                  ; Must be used between <# and #> .
000D91  1                  ; https://forth-standard.org/standard/core/SIGN
000D91  1  79 02 80     Sign:	JSRD Rot		; bring n to top of param stack
000D94  1  95 81        	LDAX ZW,ModBRPB,0	; <0?
000D96  1  17 04        	BP @3496
000D98  1  80 2D        	LDABL '-'		;   append '-'
000D9A  1  15 D1        	BNZ HoldA
000D9C  1  09           @3496:	RSR			; return
000D9D  1               
000D9D  1               
000D9D  1  23 01 0D 91   FHdr '#',0 ; ( ud1 -- ud2 )
000DA1  1                  ; Generate from a double number ud1, the next ASCII char which is placed in
000DA1  1                  ; an output string.  Result ud2 is the quotient after division by BASE, and
000DA1  1                  ; is maintained for further processing.  Used between <# and #>.  See #S.
000DA1  1                  ; https://forth-standard.org/standard/core/num
000DA1  1  91 70 84     Hash:	LDAD VBase
000DA4  1  B5 82        	STAX ZW,ModBMRB,0	; ( ud1 u )
000DA6  1  79 07 40     	JSRD MSlashMod		; ( rem ud2 )
000DA9  1  79 02 80     	JSRD Rot		; ( ud2 remainder )
000DAC  1  95 81        	LDAX ZW,ModBRPB,0	; pop remainder
000DAE  1  C0 0A        	LDBBL 10		; >=10?
000DB0  1  49           	SABB
000DB1  1  11 04        	BNL @3517
000DB3  1  C0 07        	LDBBL 7			;   change from ASCII digit to letter
000DB5  1  40 31        	ADDB AL,BL
000DB7  1  C0 30        @3517:	LDBBL '0'		; convert to ASCII
000DB9  1  40 31        	ADDB AL,BL
000DBB  1  73 B0        	JMPR HoldA		; append to HOLD, & return
000DBD  1               
000DBD  1               
000DBD  1  23 53 02 0D   FHdr '#S',0 ; ( ud1 -- ud2 )
000DC1  1  A1           
000DC2  1                  ; Generates ASCII text in the text output buffer, by the use of #, until
000DC2  1                  ; a zero double number ud2 results.  Used between <# and #>.
000DC2  1                  ; https://forth-standard.org/standard/core/numS
000DC2  1               HashS:
000DC2  1  7B DD        @3529:	JSRR Hash		; do a digit
000DC4  1  95 88 02     	LDAX ZW,ModNBRB,2	;  until ud1=0
000DC7  1  DC           	LDBA ZW
000DC8  1  53 02        	ORI BW,AW
000DCA  1  15 F6        	BNZ @3529
000DCC  1  09           	RSR			; return
000DCD  1               
000DCD  1               
000DCD  1  44 2E 52 03   FHdr 'D.R',0 ; ( d numdigits -- )
000DD1  1  0D C2        
000DD3  1                  ; Print a signed double number d right aligned in a field n chars wide.
000DD3  1                  ; https://forth-standard.org/standard/double/DDotR
000DD3  1  95 81        DDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000DD5  1  B5 A2        	STAX SW,ModBMRB,0
000DD7  1  79 02 A1     DDotR3:	JSRD Swap		; push sign under d
000DDA  1  79 02 CC     	JSRD Over
000DDD  1  79 05 64     	JSRD DAbs		; d=abs(d)
000DE0  1  79 0D 5E     	JSRD BDigs		; begin collecting string
000DE3  1  7B DD        	JSRR HashS		; do all digits
000DE5  1  7B AA        	JSRR Sign		; do sign
000DE7  1  79 0D 7B     DDotR7:	JSRD EDigs		; end collecting string
000DEA  1  95 A1        	LDAX SW,ModBRPB,0	; get numdigits from return stack
000DEC  1  DC           	LDBA ZW			; calc # of padding spaces
000DED  1  59           	SAB
000DEE  1  F5 82        	STBX ZW,ModBMRB,0	; type that many spaces
000DF0  1  79 0D 03     	JSRD Spaces
000DF3  1  71 0D 16     	JMPD Type		; type the string, & return
000DF6  1               
000DF6  1               
000DF6  1  55 44 2E 52   FHdr 'UD.R',0 ; ( d numdigits -- )
000DFA  1  04 0D D3     
000DFD  1                  ; Print an unsigned double number d right aligned in a field n chars wide.
000DFD  1  95 81        UDDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000DFF  1  B5 A2        	STAX SW,ModBMRB,0
000E01  1  79 0D 5E     	JSRD BDigs		; begin collecting string
000E04  1  7B BC        	JSRR HashS		; do all digits
000E06  1  73 DF        	JMPR DDotR7
000E08  1               
000E08  1               
000E08  1  55 44 2E 03   FHdr 'UD.',0 ; ( d -- )
000E0C  1  0D FD        
000E0E  1  79 0D 5E     UDDot:	JSRD BDigs		; begin collecting string
000E11  1  7B AF        	JSRR HashS		; do all digits
000E13  1  79 0D 7B     	JSRD EDigs		; end collecting string
000E16  1  79 0D 16     	JSRD Type
000E19  1  71 0C F6     	JMPD Space
000E1C  1               
000E1C  1               
000E1C  1  44 2E 02 0E   FHdr 'D.',0 ; ( d -- )  Print a signed double number from a 32 bit two's complement value.
000E20  1  0E           
000E21  1                  ; The high-order 16 bits are most accessable on the stack.  Conversion is
000E21  1                  ; performed according to the current BASE .  A blank follows.
000E21  1                  ; https://forth-standard.org/standard/double/Dd
000E21  1  79 0A 50     DDot:	JSRD Zero		; push min # of digits
000E24  1  7B AD        	JSRR DDotR		; do D.R
000E26  1  71 0C F6     	JMPD Space		; type a space, & return
000E29  1               
000E29  1               
000E29  1  2E 52 02 0E   FHdr '.R',0 ; ( n numdigits -- )
000E2D  1  21           
000E2E  1                  ; https://forth-standard.org/standard/core/DotR
000E2E  1  95 81        DotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000E30  1  B5 A2        	STAX SW,ModBMRB,0
000E32  1  79 06 A2     	JSRD SToD		; convert n to double
000E35  1  73 A0        	JMPR DDotR3		; do D.R, & return
000E37  1               
000E37  1               
000E37  1  55 2E 52 03   FHdr 'U.R',0 ; ( u numdigits -- )
000E3B  1  0E 2E        
000E3D  1                  ; https://forth-standard.org/standard/core/UDotR
000E3D  1  95 81        UDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000E3F  1  B5 A2        	STAX SW,ModBMRB,0
000E41  1  3A           	CLA			; convert u to double
000E42  1  B5 82        	STAX ZW,ModBMRB,0
000E44  1  73 91        	JMPR DDotR3		; do D.R, & return
000E46  1               
000E46  1               
000E46  1  55 2E 02 0E   FHdr 'U.',0 ; ( u -- )
000E4A  1  3D           
000E4B  1                  ; https://forth-standard.org/standard/core/Ud
000E4B  1  79 0A 50     UDot:	JSRD Zero
000E4E  1  7B ED        	JSRR UDotR
000E50  1  71 0C F6     	JMPD Space
000E53  1               
000E53  1               
000E53  1  2E 01 0E 4B   FHdr '.',0 ; ( n -- )  Print a number from a signed 16 bit two's complement value,
000E57  1                  ; converted according to the numeric BASE.  A traling blank follows.
000E57  1                  ; https://forth-standard.org/standard/core/d
000E57  1  79 06 A2     Dot:	JSRD SToD		; convert n to double
000E5A  1  73 C5        	JMPR DDot		; do D. , & return
000E5C  1               
000E5C  1               
000E5C  1  3F 01 0E 57   FHdr '?',0 ; ( adr -- )  Print the value contained at the address
000E60  1                  ; in free format according to the current base.
000E60  1                  ; https://forth-standard.org/standard/tools/q
000E60  1  79 08 01     Ques:	JSRD At			; fetch the word at addr
000E63  1  73 F2        	JMPR Dot		; type it, & return
000E65  1               
000E65  1               
000E65  1               	.if 0
000E65  1                FHdr 'Accept',0 ; ( addr u1 -- u2 )  Receives u1 characters (or until carriage return) from the
000E65  1                  ; terminal keyboard and stores them, starting at the address.
000E65  1                  ; The count of received characters is returned.
000E65  1               	.endif
000E65  1               
000E65  1               
000E65  1  45 78 70 65   FHdr 'Expect',0 ; ( addr count -- )
000E69  1  63 74 06 0E  
000E6D  1  60           
000E6E  1                  ; Transfer chars from the terminal to address, until a "return" or the count of
000E6E  1                  ; chars have been received.  One or more nulls area added at the end of the text.
000E6E  1  6D A2        Expect:	STXX SW,ModBMRB,0	; push X
000E70  1  32 40        	CLR XW,0		; index=0
000E72  1  79 01 0F     @next:	JSRD KeyA
000E75  1  D1 70 60     	LDBD VBS		; backspace?
000E78  1  49           	SABB
000E79  1  14 20        	BZ @bs
000E7B  1  C0 0D        	LDBBL $0D		; return?
000E7D  1  49           	SABB
000E7E  1  14 0F        	BZ @cr
000E80  1               
000E80  1  D5 88 02     	LDBX ZW,ModNBRB,2
000E83  1  50 42        	ADD BW,XW
000E85  1  A9           	STABA BW		; store the char
000E86  1  3E           	INXC			; advance index
000E87  1  79 0C CC     	JSRD EmitA		; update the terminal
000E8A  1  DC           	LDBA ZW			; at end_of_line?
000E8B  1  51 42        	SUB BW,XW
000E8D  1  11 E3        	BNL @next
000E8F  1               
000E8F  1  D5 88 02     @cr:	LDBX ZW,ModNBRB,2	; insert trailing NULLs
000E92  1  50 42        	ADD BW,XW
000E94  1  3A           	CLA
000E95  1  B9           	STAA BW
000E96  1  65 A1        	LDXX SW,ModBRPB,0	; pop X
000E98  1  30 83        	INR ZW,4		; TwoDrop
000E9A  1  09           	RSR
000E9B  1               
000E9B  1  55 42        @bs:	XFR BW,XW		; at begin_of_line?
000E9D  1  14 D3        	BZ @next
000E9F  1  3F           	DCX			; back up ptr
000EA0  1  80 08        	LDABL $08		; back up terminal
000EA2  1  79 0C CC     	JSRD EmitA
000EA5  1  73 CB        	JMPR @next		; next
000EA7  1               
000EA7  1               
000EA7  1  51 75 65 72   FHdr 'Query',0 ; ( -- )
000EAB  1  79 05 0E 6E  
000EAF  1                  ; Input 80 chars of text (or until a "return") from the operators terminal.
000EAF  1                  ; Text is positioned at the address contained in TIB with IN set to zero.
000EAF  1  3A           Query:	CLA			; IN=0
000EB0  1  B1 70 76     	STAD VIn
000EB3  1  91 70 68     	LDAD VTIB		; buffer addr
000EB6  1  B5 82        	STAX ZW,ModBMRB,0
000EB8  1  90 00 50     	LDAL 80			; 80 characters from terminal
000EBB  1  B5 82        	STAX ZW,ModBMRB,0
000EBD  1  73 AF        	JMPR Expect
000EBF  1               
000EBF  1               
000EBF  1  28 41 62 6F   FHdr '(Abort)',0 ;
000EC3  1  72 74 29 07  
000EC7  1  0E AF        
000EC9  1               ; Executes after an error when WARNING is -1.  This word normally executes ABORT,
000EC9  1               ; but may be altered (with care) to a user's alternative procedure.
000EC9  1  71 17 82     PAbort:	JMPD Abort
000ECC  1               
000ECC  1               
000ECC  1  45 72 72 6F   FHdr 'Error',0 ; ( error_number -- in blk )  Execute error notification and restart of the system.
000ED0  1  72 05 0E C9  
000ED4  1                  ; WARNING is first examined.  If 1, the text of line n, relative to screen 4 of drive 0 is
000ED4  1                  ; printed.  This line number may be positive or negative, and beyond just screen 4.
000ED4  1                  ; If WARNING=0, n is just printed as a message number (non disc installation).
000ED4  1                  ; If WARNING is -1, the definition (ABORT) is executed, which executes the system ABORT.
000ED4  1                  ; The user may cautionsly modify this execute by altering (ABORT) .
000ED4  1                  ; fig-FORTH saves the contents of IN and BLK to assist in determinging the location of the error.
000ED4  1                  ; Final action is execution of QUIT .
000ED4  1  91 70 6C     Error:	LDAD VWarning		; Warning<0?
000ED7  1  16 F0        	BM PAbort
000ED9  1  79 0C F6     	JSRD Space
000EDC  1  79 0C 01     	JSRD Here		; type the interpreted word
000EDF  1  79 08 58     	JSRD Count
000EE2  1  79 0D 16     	JSRD Type
000EE5  1  79 14 2E     	JSRD PDotQuote		; type "  ? "
000EE8  1  05 20 20 3F  	.byte 5,'  ?',0,' '	; "?\0 " sequence triggers simulator to stop feeding text from file
000EEC  1  00 20        
000EEE  1  79 19 93     	JSRD Message		; type the error
000EF1  1  79 02 45     	JSRD EmptyStack		; empty the param stack
000EF4  1  79 14 2E     	JSRD PDotQuote		; show text position
000EF7  1  07 20 42 6C  	.byte 7," Block="
000EFB  1  6F 63 6B 3D  
000EFF  1  91 70 74     	LDAD VBlk
000F02  1  B5 82        	STAX ZW,ModBMRB,0
000F04  1  79 0E 57     	JSRD Dot
000F07  1  79 14 2E     	JSRD PDotQuote
000F0A  1  07 4F 66 66  	.byte 7,"Offset="
000F0E  1  73 65 74 3D  
000F12  1  91 70 76     	LDAD VIn
000F15  1  B5 82        	STAX ZW,ModBMRB,0
000F17  1  79 0E 57     	JSRD Dot
000F1A  1  71 17 2E     	JMPD Quit		; restart the interpreter
000F1D  1               
000F1D  1               
000F1D  1  3F 53 74 61   FHdr '?Stack',0 ; ( -- )  Issue an error message if the stack is out of bounds.
000F21  1  63 6B 06 0E  
000F25  1  D4           
000F26  1  90 71 16     QStack:	LDAL TOS+1		; param atack beyond empty?
000F29  1  51 80        	SUB AW,ZW
000F2B  1  10 08        	BL @underflow
000F2D  1  90 70 9D     	LDAL BOS+6		; param stack beyond full?
000F30  1  51 80        	SUB AW,ZW
000F32  1  11 05        	BNL @overflow
000F34  1  09           	RSR
000F35  1               
000F35  1  32 21        @underflow: CLR BW,Err_StackUnderflow
000F37  1  73 26        	JMPR ErrorY
000F39  1               
000F39  1  D0 00 07     @overflow: LDBL Err_StackOverflow
000F3C  1  73 21        	JMPR ErrorY
000F3E  1               
000F3E  1               
000F3E  1  3F 45 72 72   FHdr '?Error',0 ; ( f n -- )  Issue an error message number n, if f is true;
000F42  1  6F 72 06 0F  
000F46  1  26           
000F47  1  D5 81        QErr:	LDBX ZW,ModBRPB,0	; pop n
000F49  1  95 81        QErrY:	LDAX ZW,ModBRPB,0	; f true?
000F4B  1  15 14        	BNZ ErrorY2		;   signal error
000F4D  1  09           	RSR			; return
000F4E  1               
000F4E  1               
000F4E  1  3F 43 6F 6D   FHdr '?Comp',0 ; ( -- )  Issue error message if not compiling.
000F52  1  70 05 0F 47  
000F56  1  D0 00 11     QComp:	LDBL Err_CompileOnly
000F59  1  91 70 82     	LDAD VState		; not compiling?
000F5C  1  14 01        	BZ ErrorY		;   signal error
000F5E  1  09           	RSR			; return
000F5F  1               
000F5F  1               ErrorY:				; error code in B
000F5F  1  31 81        	DCR ZW,2
000F61  1  FC           ErrorY2: STBA ZW
000F62  1  71 0E D4     	JMPD Error
000F65  1               
000F65  1               
000F65  1  3F 45 78 65   FHdr '?Exec',0 ; ( -- )  Issue an error message if not executing.
000F69  1  63 05 0F 56  
000F6D  1  D0 00 12     QExec:	LDBL Err_ExecuteOnly
000F70  1  91 70 82     	LDAD VState		; compiling?
000F73  1  15 EA        	BNZ ErrorY		;   signal error
000F75  1  09           	RSR			; return
000F76  1               
000F76  1               
000F76  1  3F 50 61 69   FHdr '?Pairs',0 ; ( n1 n2 -- )  Issue an error message if n1 != n2.
000F7A  1  72 73 06 0F  
000F7E  1  6D           
000F7F  1                  ; The message indicates that compiled conditionals do not match.
000F7F  1  95 81        QPairs:	LDAX ZW,ModBRPB,0	; pop n2
000F81  1  D5 81        QPairsA: LDBX ZW,ModBRPB,0	; pop n1
000F83  1  59           	SAB			; n2<>n1?
000F84  1  14 D0        	BZ QComp		; also verify we're compiling
000F86  1  D0 00 13     	LDBL Err_ConditionalsNotPaired
000F89  1  73 D6        	JMPR ErrorY2		;   signal error
000F8B  1               
000F8B  1               
000F8B  1  21 43 53 50   FHdr '!CSP',0 ; ( -- )  Save the param stack index in CSP. Used as part of the compiler security.
000F8F  1  04 0F 7F     
000F92  1  55 80        SCSP:	XFR AW,ZW
000F94  1  B1 70 8A     	STAD VCSP
000F97  1  09           	RSR
000F98  1               
000F98  1               
000F98  1  3F 43 53 50   FHdr '?CSP',0 ; ( -- )  Issue error message if stack index <> value saved in CSP.
000F9C  1  04 0F 92     
000F9F  1  D0 00 14     QCSP:	LDBL Err_DefinitionNotFinished
000FA2  1  91 70 8A     	LDAD VCSP		; param stack index different than saved?
000FA5  1  51 80        	SUB AW,ZW
000FA7  1  15 B6        	BNZ ErrorY		;   signal error
000FA9  1  09           	RSR			; return
000FAA  1               
000FAA  1               
000FAA  1  3F 4C 6F 61   FHdr '?Loading',0 ; ( -- )  Issue an error message if not loading.
000FAE  1  64 69 6E 67  
000FB2  1  08 0F 9F     
000FB5  1  D0 00 16     QLoad:	LDBL Err_UseOnlyWhenLoading
000FB8  1  91 70 74     	LDAD VBlk		; no block?
000FBB  1  14 A2        	BZ ErrorY		;   signal error
000FBD  1  09           	RSR			; return
000FBE  1               
000FBE  1               
000FBE  1               	.if 0
000FBE  1                FHdr 'Buffer:',0
000FBE  1                  ; Compile: ( u "<spaces>name" -- )
000FBE  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Create a definition for name, with the execution
000FBE  1                  ;   semantics defined below. Reserve u address units at an aligned address.
000FBE  1                  ;   Contiguity of this region with any other region is undefined.
000FBE  1                  ; name Execution:
000FBE  1                  ;   ( -- a-addr )
000FBE  1                  ;   a-addr is the address of the space reserved by BUFFER: when it defined name.
000FBE  1                  ;   The program is responsible for initializing the contents.
000FBE  1                  ; https://forth-standard.org/standard/core/BUFFERColon
000FBE  1               BufferColon:
000FBE  1               	JSRD Create
000FBE  1               	JMPR Allot
000FBE  1               	.endif
000FBE  1               
000FBE  1               
000FBE  1  41 6C 6C 6F   FHdr 'Allot',0 ; ( n -- )  Add the signed number to the dictionary pointer DP.
000FC2  1  74 05 0F B5  
000FC6  1                  ; May be used to reserve dictionary space or re-origin memory.
000FC6  1                  ; n is with regard to computer address type (byte or word).
000FC6  1                  ; https://forth-standard.org/standard/core/ALLOT
000FC6  1  95 81        Allot:	LDAX ZW,ModBRPB,0	; pop n
000FC8  1  D1 70 70     AllotA:	LDBD VDP		; add to DP
000FCB  1  58           	AAB
000FCC  1               AllotCheck:
000FCC  1  F1 70 70     	STBD VDP
000FCF  1  90 6F BC     	LDAL DictTop-PadSize	; out of space?
000FD2  1  59           	SAB
000FD3  1  D0 00 02     	LDBL Err_DictionaryFull
000FD6  1  11 87        	BNL ErrorY
000FD8  1  09           	RSR			; return
000FD9  1               
000FD9  1               
000FD9  1  44 69 63 74   FHdr 'DictTop',0 ; ( -- u )  Return top of dictionary space
000FDD  1  54 6F 70 07  
000FE1  1  0F C6        
000FE3  1  90 70 00     	LDAL DictTop
000FE6  1  B5 82        	STAX ZW,ModBMRB,0
000FE8  1  09           	RSR
000FE9  1               
000FE9  1               
000FE9  1  55 6E 75 73   FHdr 'Unused',0 ; ( -- u )  Return the space remaining in the region addressed by HERE, in address units.
000FED  1  65 64 06 0F  
000FF1  1  E3           
000FF2  1                  ; https://forth-standard.org/standard/core/UNUSED
000FF2  1  90 6F BC     Unused:	LDAL DictTop-PadSize
000FF5  1  D1 70 70     	LDBD VDP
000FF8  1  59           	SAB
000FF9  1  F5 82        	STBX ZW,ModBMRB,0
000FFB  1  09           	RSR
000FFC  1               
000FFC  1               
000FFC  1               ;----------------------------------------------------------------------
000FFC  1               ; Random #s
000FFC  1               
000FFC  1  52 6E 64 53   FHdr 'RndState',0  ; 2Variable
001000  1  74 61 74 65  
001004  1  08 0F F2     
001007  1               RndState1:
001007  1  90 71 9D     	LDAL RndState
00100A  1  B5 82        	STAX ZW,ModBMRB,0
00100C  1  09           	RSR
00100D  1               
00100D  1               
00100D  1               	.if 0
00100D  1                FHdr 'SRand',0 ; ( d -- ) set random # state
00100D  1                  ; Pause is also modifying RndState
00100D  1               SRand:	LDBX ZW,ModBRPB,0
00100D  1               	LDAX ZW,ModBRPB,0
00100D  1               	JMPR Rand8
00100D  1               	.endif
00100D  1               
00100D  1               
00100D  1  52 61 6E 64   FHdr 'Rand',0 ; ( -- n )  generate next random #
001011  1  04 10 07     
001014  1                  ; https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Galois_LFSRs
001014  1                  ; https://en.wikipedia.org/wiki/Xorshift
001014  1               Rand: ; 32bit Galois LFSR
001014  1  91 71 9F     	LDAD 2+RndState		; BA=state
001017  1  D1 71 9D     	LDBD 0+RndState
00101A  1  15 04        	BNZ @39			; fix state=0
00101C  1  5C           	XAY
00101D  1  15 01        	BNZ @39
00101F  1  38           	INA
001020  1               @39:
001020  1  07           	RL			; BA>>=1
001021  1  36 20        	RRR BW,1
001023  1  36 00        	RRR AW,1
001025  1  11 0E        	BNL @49
001027  1               
001027  1  55 46        	XFR YW,XW		; save X
001029  1  60 D0 00     	LDXL $d000		; BA^=$d0000001
00102C  1  54 42        	ORE BW,XW
00102E  1  60 00 01     	LDXL $0001
001031  1  54 40        	ORE AW,XW
001033  1  55 64        	XFR XW,YW		; restore X
001035  1  B5 82        @49:	STAX ZW,ModBMRB,0	; return value
001037  1  F1 71 9D     Rand8:	STBD 0+RndState		; save state
00103A  1  B1 71 9F     	STAD 2+RndState
00103D  1  09           	RSR
00103E  1               
00103E  1               
00103E  1               	.if 0
00103E  1                FHdr 'RndTest1',0 ; ( -- d )  test Rand period
00103E  1               	LDBD 0+RndState		; push original state
00103E  1               	LDAD 2+RndState
00103E  1               	STAX SW,ModBMRB,0
00103E  1               	STBX SW,ModBMRB,0
00103E  1               	CLA			; 0.
00103E  1               	STAX ZW,ModBMRB,0
00103E  1               	STAX ZW,ModBMRB,0
00103E  1               @3:
00103E  1               	LDAA ZW			; increment d
00103E  1               	INA
00103E  1               	STAA ZW
00103E  1               	BNZ @19
00103E  1               	LDAX ZW,ModNBRB,2
00103E  1               	INA
00103E  1               	STAX ZW,ModNBRB,2
00103E  1               	JSRD EX4A
00103E  1               	JSRD Space
00103E  1               @19:
00103E  1               	JSRR Rand		; gen next number
00103E  1               	INR ZW,2		;   drop result
00103E  1               	XAY
00103E  1               	LDAA SW			;  compare
00103E  1               	SAB
00103E  1               	BNZ @3
00103E  1               	LDAX SW,ModNBRB,2
00103E  1               	SUB AW,YW
00103E  1               	BNZ @3
00103E  1               
00103E  1               	INR SW,4		; rdrop starting state
00103E  1               	JMPD Swap		; fix count
00103E  1               	.endif
00103E  1               
00103E  1               
00103E  1  52 61 6E 64   FHdr 'RandM',0 ; ( umod -- u ) random integer between 0 & umod-1
001042  1  4D 05 10 14  
001046  1  95 81        RandM:	LDAX ZW,ModBRPB,0	; save umod
001048  1  B5 A2        	STAX SW,ModBMRB,0
00104A  1  7B C8        	JSRR Rand		; get next random #
00104C  1  F5 A2        	STBX SW,ModBMRB,0	; save hi part
00104E  1  D5 A1        	LDBX SW,ModBRPB,0
001050  1  F5 82        	STBX ZW,ModBMRB,0
001052  1  79 06 DA     	JSRD UMSlashMod
001055  1  30 81        	INR ZW,2		; drop quotient
001057  1  09           	RSR
001058  1               
001058  1               
001058  1  44 65 66 65   FHdr 'Defer',0 ; ( "<spaces>name" -- )  https://forth-standard.org/standard/core/DEFER
00105C  1  72 05 10 46  
001060  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Create a definition for name with the execution semantics defined below.
001060  1                  ; name Execution:
001060  1                  ;   ( i * x -- j * x )
001060  1                  ;   Execute the xt that name is set to execute. An ambiguous condition exists if name has not been set to execute an xt.
001060  1  79 12 B7     Defer:	JSRD HeaderComma	; compile word header
001063  1  90 17 82     	LDAL Abort
001066  1  71 10 EA     	JMPD JmpCommaA
001069  1               
001069  1               
001069  1  44 65 66 65   FHdr 'Defer@',0 ; ( xt1 -- xt2 )  https://forth-standard.org/standard/core/DEFERFetch
00106D  1  72 40 06 10  
001071  1  60           
001072  1                  ;  xt2 is the execution token xt1 is set to execute. An ambiguous condition exists if xt1 is not the execution token of a word defined by DEFER, or if xt1 has not been set to execute an xt.
001072  1               DeferAt:
001072  1  9C           	LDAA ZW			; get xt1
001073  1               	; check that the xt1 word is a Defer ?
001073  1  D5 08 01     	LDBX AW,ModNBRB,1	; get jMPD operand
001076  1  FC           	STBA ZW			; store xt2
001077  1  09           	RSR
001078  1               
001078  1               
001078  1  44 65 66 65   FHdr 'Defer!',0 ; ( xt2 xt1 -- )  https://forth-standard.org/standard/core/DEFERStore
00107C  1  72 21 06 10  
001080  1  72           
001081  1                  ; Set the word xt1 to execute xt2. An ambiguous condition exists if xt1 is not for a word defined by DEFER.
001081  1               DeferStore:
001081  1  95 81        	LDAX ZW,ModBRPB,0	; pop xt1
001083  1               	; check that the xt1 word is a Defer ?
001083  1  D5 81        	LDBX ZW,ModBRPB,0	; pop xt2
001085  1  F5 08 01     	STBX AW,ModNBRB,1	; store xt2 into JMPD operand
001088  1  09           	RSR
001089  1               
001089  1               
001089  1               	.if 0
001089  1               
001089  1                FHdr 'Is',ha_immedate ;
001089  1                  ; Interpretation:
001089  1                  ;   ( xt "<spaces>name" -- )
001089  1                  ;   Skip leading spaces and parse name delimited by a space. Set name to execute xt.
001089  1                  ;   An ambiguous condition exists if name was not defined by DEFER.
001089  1                  ; Compilation:
001089  1                  ;   ( "<spaces>name" -- )
001089  1                  ;   Skip leading spaces and parse name delimited by a space. Append the run-time semantics given below to the current definition.
001089  1                  ;   An ambiguous condition exists if name was not defined by DEFER.
001089  1                  ; Run-time:
001089  1                  ;   ( xt -- )
001089  1                  ;   Set name to execute xt.
001089  1                  ; An ambiguous condition exists if POSTPONE, [COMPILE], ['] or ' is applied to IS.
001089  1                  ; https://forth-standard.org/standard/core/IS
001089  1               Is:	JSRD Tick		; look up the name
001089  1               	LDBD VState		; compiling?
001089  1               	BZ DeferStore
001089  1               
001089  1               	JSRD Swap
001089  1               	LDABL $90		; LDAL xt
001089  1               	JSRD CCommaA
001089  1               	JSRD Comma
001089  1               	LDABL $b1		; STAD name
001089  1               	JSRD CCommaA
001089  1               	JMPD Comma
001089  1               
001089  1               
001089  1                FHdr 'Action-Of',ha_immediate ; https://forth-standard.org/standard/core/ACTION-OF
001089  1                  ; Interpretation:
001089  1                  ;   ( "<spaces>name" -- xt )
001089  1                  ;   Skip leading spaces and parse name delimited by a space. xt is the execution token that name is set to execute.
001089  1                  ;   An ambiguous condition exists if name was not defined by DEFER, or if the name has not been set to execute an xt.
001089  1                  ; Compilation:
001089  1                  ;   ( "<spaces>name" -- )
001089  1                  ;   Skip leading spaces and parse name delimited by a space. Append the run-time semantics given below to the current definition.
001089  1                  ;   An ambiguous condition exists if name was not defined by DEFER.
001089  1                  ; Run-time:
001089  1                  ;   ( -- xt )
001089  1                  ;   xt is the execution token that name is set to execute. An ambiguous condition exists if name has not been set to execute an xt.
001089  1                  ;   An ambiguous condition exists if POSTPONE, [COMPILE], ['] or ' is applied to ACTION-OF.
001089  1               	JSRD Tick		; look up the inline name
001089  1               	LDAA ZW			; get name addr
001089  1               	LDABA AW		; check word 1st opcode
001089  1               	LDBBL $71		;    for JMPD
001089  1               	SABB
001089  1               	BNZ @Abort
001089  1               
001089  1               	LDAD VState		; compiling?
001089  1               	BZ DeferAt
001089  1               
001089  1               	LDABL $91		; LDAD name+1
001089  1               	JSRD CCommaA
001089  1               	JSRD OnePlus
001089  1               	JSRD Comma
001089  1               	JMPD PushAComma		; STAX ZW,ModBMRB,0	; push it
001089  1               
001089  1               	.endif
001089  1               
001089  1               
001089  1               	.if 0
001089  1               
001089  1                FHdr 'Align',ha_inline ; ( -- )  https://forth-standard.org/standard/core/ALIGN
001089  1                  ; If the data-space pointer is not aligned, reserve enough space to align it.
001089  1               	; do nothing, CPU6 doesn't care
001089  1               	.dbyt INL_End
001089  1               
001089  1               
001089  1                FHdr 'Aligned',ha_inline ; ( addr -- a-addr )  https://forth-standard.org/standard/core/ALIGNED
001089  1                  ; a-addr is the first aligned address greater than or equal to addr.
001089  1               		; do nothing, CPU6 doesn't care
001089  1               	.dbyt INL_End
001089  1               
001089  1               	.endif
001089  1               
001089  1               
001089  1               	.if 1
001089  1  50 6F 73 74   FHdr 'Postpone',ha_immediate ; ( "name" -- )
00108D  1  70 6F 6E 65  
001091  1  48 10 81     
001094  1                  ; Interpretation:
001094  1                  ;   Interpretation semantics for this word are undefined.
001094  1                  ; Compilation:
001094  1                  ;   ( "<spaces>name" -- )
001094  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Find name.
001094  1                  ;   Append the compilation semantics of name to the current definition.
001094  1                  ;   An ambiguous condition exists if name is not found.
001094  1                  ; https://forth-standard.org/standard/core/POSTPONE
001094  1               Postpone:
001094  1  79 15 3A     	JSRD TickNew		;find the word
001097  1  9C           	LDAA ZW			;get xt (aka nt)
001098  1  85 08 FD     	LDABX AW,ModNBRB,$fd	;get flags
00109B  1               	.assert ha_immediate=$40, error, "code assumption"
00109B  1  2D           	SLAB
00109C  1  16 14        	BM CompileComma		; imemdiate, so do normal compile
00109E  1               
00109E  1               				; not immediate, so do deferred compilation
00109E  1  79 11 1F     	JSRD LdaImmedComma	; ' "name"
0010A1  1  90 10 B4     	LDAL CompileCommaA	; COMPILE,
0010A4  1  71 10 D7     	JMPD JsrCommaA
0010A7  1               
0010A7  1               	.endif
0010A7  1               
0010A7  1               
0010A7  1               	.if 0
0010A7  1                FHdr 'Recurse',ha_immediate
0010A7  1                  ; Interpretation:
0010A7  1                  ;   Interpretation semantics for this word are undefined.
0010A7  1                  ; Compilation:
0010A7  1                  ;   ( -- )
0010A7  1                  ;   Append the execution semantics of the current definition to the current definition.
0010A7  1                  ;   An ambiguous condition exists if RECURSE appears in a definition after DOES>.
0010A7  1                  ; https://forth-standard.org/standard/core/RECURSE
0010A7  1               	LDBI VCurrent		; start of last word
0010A7  1               	JMPD JsrCommaA
0010A7  1               	.endif
0010A7  1               
0010A7  1               
0010A7  1               	.if 0
0010A7  1                FHdr '[Compile]',ha_immediate  ; https://forth-standard.org/standard/core/BracketCOMPILE
0010A7  1                  ; Interpretation:
0010A7  1                  ;   Interpretation semantics for this word are undefined.
0010A7  1                  ; Compilation:
0010A7  1                  ;   ( "<spaces>name" -- )
0010A7  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Find name. If name has other than default
0010A7  1                  ; compilation semantics, append them to the current definition; otherwise append the execution semantics of name.
0010A7  1                  ; An ambiguous condition exists if name is not found.
0010A7  1               	JSRD Tick
0010A7  1               	JMPR CompileComma
0010A7  1               	.endif
0010A7  1               
0010A7  1               
0010A7  1  43 6F 6D 70   FHdr 'Compile,',0 ; ( addr -- ) compile a call to a word
0010AB  1  69 6C 65 2C  
0010AF  1  08 10 94     
0010B2  1                  ; Not quite standard: it expects an nfa so it can look at the ha_inline flag bit
0010B2  1                  ; https://forth-standard.org/standard/core/COMPILEComma
0010B2  1               CompileComma:
0010B2  1  95 81        	LDAX ZW,ModBRPB,0	; pop addr from param stack
0010B4  1               CompileCommaA: ; nfa (name field addr, also code addr) in A
0010B4  1  C5 08 FD     	LDBBX AW,ModNBRB,$fd	; get flag & length byte
0010B7  1               	.assert ha_inline=$80, error, "ha_inline assumption"
0010B7  1  17 1E        	BP JsrCommaA		; not ha_inline, do JSR
0010B9  1  5C           	XAY			; copy inline bytes until marker
0010BA  1  9B           @11:	LDAA YW
0010BB  1  D0 09 09     	LDBL INL_End
0010BE  1  59           	SAB
0010BF  1  14 0C        	BZ @19
0010C1  1  45 01        	XFRB AL,AH
0010C3  1  7E 61        	PUSH YH,2
0010C5  1  7B 49        	JSRR CCommaA
0010C7  1  7F 61        	POP YH,2
0010C9  1  30 60        	INR YW,1
0010CB  1  73 ED        	JMPR @11
0010CD  1  09           @19:	RSR
0010CE  1               
0010CE  1               
0010CE  1  4A 73 72 2C   FHdr 'Jsr,',0 ; ( adr -- )  compile a "JSRD adr" to call a word
0010D2  1  04 10 B2     
0010D5  1  95 81        	LDAX ZW,ModBRPB,0	; pop adr
0010D7  1               JsrCommaA:
0010D7  1  B5 A2        	STAX SW,ModBMRB,0	; save addr
0010D9  1  80 79        	LDABL $79		; compile "JSRD direct" opcode
0010DB  1               Compile16:
0010DB  1  7B 33        	JSRR CCommaA		; compile opcode
0010DD  1  95 A1        	LDAX SW,ModBRPB,0	; compile 2byte operand, & return
0010DF  1  73 15        	JMPR CommaA
0010E1  1               
0010E1  1               
0010E1  1  4A 6D 70 2C   FHdr 'Jmp,',0 ; ( adr -- )  compile a "JMPD adr"
0010E5  1  04 10 D5     
0010E8  1               JmpComma:
0010E8  1  95 81        	LDAX ZW,ModBRPB,0
0010EA  1               JmpCommaA:
0010EA  1  B5 A2        	STAX SW,ModBMRB,0	; save operand
0010EC  1  80 71        	LDABL $71		; "JMPD abs" opcode
0010EE  1  73 EB        	JMPR Compile16
0010F0  1               
0010F0  1               
0010F0  1               
0010F0  1  2C 01 10 E8   FHdr ',',0 ; ( n -- )  Append n onto the dictionary.
0010F4  1                  ; https://forth-standard.org/standard/core/Comma
0010F4  1  95 81        Comma:	LDAX ZW,ModBRPB,0	; pop n
0010F6  1  D1 70 70     CommaA:	LDBD VDP		; store into dictionary
0010F9  1  B5 21        	STAX BW,ModBRPB,0
0010FB  1  3A           Comma2:	CLA			; store 0 (not required, helps in case of interrupted compile)
0010FC  1  B9           	STAA BW
0010FD  1  71 0F CC     	JMPD AllotCheck
001100  1               
001100  1               
001100  1  32 2C 02 10   FHdr '2,',0 ; ( d -- )  Append d onto the dictionary
001104  1  F4           
001105  1               TwoComma:
001105  1  7B ED        	JSRR Comma	; do hi word
001107  1  73 EB        	JMPR Comma	; do lo word, & return
001109  1               
001109  1               
001109  1  43 2C 02 11   FHdr 'C,',0 ; ( n -- )  Append byte n onto the dictionary.
00110D  1  05           
00110E  1                  ; https://forth-standard.org/standard/core/CComma
00110E  1  95 81        CComma:	LDAX ZW,ModBRPB,0	; pop n
001110  1  D1 70 70     CCommaA: LDBD VDP		; store
001113  1  A5 21        	STABX BW,ModBRPB,0
001115  1  73 E4        	JMPR Comma2		; finish & return
001117  1               
001117  1               
001117  1               LdbaComma: ; ( d -- )  compile ldb # & lda #
001117  1  80 D0        	LDABL $d0		; LDBL n	do hi word
001119  1  7B 06        	JSRR LdComma
00111B  1  73 02        	JMPR LdaImmedComma	;		do lo word
00111D  1               
00111D  1               LdaImmedCommaA: ; compile lda #
00111D  1  B5 82        	STAX ZW,ModBMRB,0
00111F  1               LdaImmedComma: ; compile lda #
00111F  1  80 90        	LDABL $90		; LDAL n
001121  1  7B ED        LdComma: JSRR CCommaA
001123  1  73 CF        	JMPR Comma
001125  1               
001125  1               
001125  1                 .if 0
001125  1                FHdr 'Compile',0 ; ( -- )
001125  1                  ; see Compile,
001125  1                  ; When the word containing COMPILE executes, the execution address of the word
001125  1                  ; following COMPILE is copied (compiled) into the dictionary.  This allows
001125  1                  ; specific compilation situations to be handled in addition to simply compiling
001125  1                  ; an execution address (which the interpreter already does).
001125  1               Compile:
001125  1               	JSRD QComp	; verify we're compiling
001125  1               	LDAX SW,ModBRPB,0 ; get the word following the call to me
001125  1               	JMPR CompileCommaA ; compile the call, & return
001125  1                 .endif
001125  1               
001125  1               
001125  1  42 72 61 6E   FHdr 'Branch,',0 ; ( DestAddr branch_opcode -- ) compile a branch back
001129  1  63 68 2C 07  
00112D  1  11 0E        
00112F  1               BranchComma:
00112F  1  95 81        	LDAX ZW,ModBRPB,0	; pop opcode
001131  1               BranchCommaA:
001131  1  B5 A2        	STAX SW,ModBMRB,0	; save branch_opcode
001133  1  DC           	LDBA ZW			; A=relative displacement of addr
001134  1  31 21        	DCR BW,2
001136  1  91 70 70     	LDAD VDP
001139  1  51 20        	SUB AW,BW
00113B  1  D0 00 80     	LDBL $80		; in range of an 8-bit displacement?
00113E  1  59           	SAB
00113F  1  11 06        	BNL @Short
001141  1  D0 FF 80     	LDBL $ff80
001144  1  59           	SAB
001145  1  11 09        	BNL @Long
001147  1               
001147  1  BC           @Short:	STAA ZW			; drop addr, save displacement
001148  1  95 A1        	LDAX SW,ModBRPB,0	; compile branch_opcode
00114A  1  79 11 10     	JSRD CCommaA
00114D  1  71 11 0E     	JMPD CComma		; compile branch displacement, & return
001150  1               
001150  1  95 A1        @Long:	LDAX SW,ModBRPB,0	; get branch_opcode
001152  1  D0 00 73     	LDBL $73		; unconditional branch opcode?
001155  1  49           	SABB
001156  1  14 90        	BZ JmpComma
001158  1  45 10        	XFRB AH,AL		; complement the branch opcode sense
00115A  1  80 01        	LDABL 1
00115C  1  44 10        	OREB AH,AL
00115E  1  80 03        	LDABL 3			; set displacement to 3
001160  1  79 10 F6     	JSRD CommaA		; compile the branch
001163  1  71 10 E8     	JMPD JmpComma
001166  1               
001166  1               
001166  1               ; FHdr '(0Branch',0 ; ( f A=addr -- )  The run-time procedure to conditionally branch.
001166  1               ;PZBranch: ; ( f A=addr -- )  0Branch runtime
001166  1               ;	LDBX ZW,ModBRPB,0	; if f is false
001166  1               ;	BNZ @9
001166  1               ;	XFR XW,BW
001166  1               ;@9:	RSR
001166  1               
001166  1               PZBranchComma: ; ( adr -- ) compile (0Branch)
001166  1  90 D5 81     	LDAL $D581		; LDBX ZW,ModBRPB,0 to pop & test flag
001169  1  79 10 F6     	JSRD CommaA
00116C  1  80 14        	LDABL $14		; compile BZ
00116E  1  73 C1        	JMPR BranchCommaA
001170  1               
001170  1               
001170  1               	.if 0
001170  1                FHdr 'Ahead',0
001170  1                  ; Interpretation:
001170  1                  ;   Interpretation semantics for this word are undefined.
001170  1                  ; Compilation:
001170  1                  ;   ( C: -- orig )
001170  1                  ;   Put the location of a new unresolved forward reference orig onto the control flow stack.
001170  1                  ;   Append the run-time semantics given below to the current definition.
001170  1                  ;   The semantics are incomplete until orig is resolved (e.g., by THEN).
001170  1                  ;
001170  1                  ; Run-time:
001170  1                  ;   ( -- )
001170  1                  ;   Continue execution at the location specified by the resolution of orig.
001170  1               Ahead:
001170  1               	JSRD Abort ;???
001170  1               	.endif
001170  1               
001170  1               
001170  1  49 66 42 11   FHdr 'If',ha_immediate	; ( f -- ) (run-time)
001174  1  2F           
001175  1               			; ( -- addr n ) (compile)
001175  1                  ; Occurs in a colon-definition in form:
001175  1                  ;	IF (tp) ... ENDIF
001175  1                  ;	IF (tp ... ELSE (fp) ... ENDIF
001175  1                  ; At run-time, IF selects execution based on a bool flag.  If f is true
001175  1                  ; (non-zero), execution continues ahead thru the true part.  If f is false
001175  1                  ; (zero), execution skips till just after ELSE to execute the false part.
001175  1                  ; After either part, execution resumes after ENDIF . ELSE and its false part
001175  1                  ; are optional. If missing, false execution skips to just after ENDIF .
001175  1                  ;
001175  1                  ; At compile-time IF compiles 0BRANCH and reserves space for an offset at
001175  1                  ; addr.  addr and n are used later for resolution of the offset and
001175  1                  ; error testing.
001175  1                  ; https://forth-standard.org/standard/core/IF
001175  1  79 0F 56     If:	JSRD QComp		; verify we're compiling - this is bad news for interpreting
001178  1  90 17 82     	LDAL Abort		; push dest addr
00117B  1  B5 82        	STAX ZW,ModBMRB,0
00117D  1  7B E7        	JSRR PZBranchComma	; compile (0Branch)
00117F  1  79 0C 01     	JSRD Here		; push addr for fixup later
001182  1  71 0A 63     If7:	JMPD Two		; push "IF" pairing code, & return
001185  1               
001185  1               
001185  1  45 6C 73 65   FHdr 'Else',ha_immediate ; ( addr1 n1 -- addr2 ) (compiling)
001189  1  44 11 75     
00118C  1                  ; Occurs within a colon-definition in the form:
00118C  1                  ;	IF ... ELSE ... ENDIF
00118C  1                  ; At run-time, ELSE executes after the true part following IF . ELSE forces
00118C  1                  ; execution to skip over the following false part and resumes execution
00118C  1                  ; after the ENDIF . It has no stack effects.
00118C  1                  ;
00118C  1                  ; At compile-time ELSE replaces BRANCH reserving a branch offset, leaves
00118C  1                  ; the address addr2 and n2 for error testing.  ELSE also resolves the
00118C  1                  ; pending forward branch from IF by calculation the offset from addr1
00118C  1                  ; to HERE and storing at addr1.
00118C  1                  ; https://forth-standard.org/standard/core/Dotq
00118C  1  90 17 82     Else:	LDAL Abort		; compile "jmp abort", addr to be fixed up later
00118F  1  79 10 EA     	JSRD JmpCommaA
001192  1  7B 0C        	JSRR Then		; fixup the IF
001194  1  79 0C 01     	JSRD Here		; save addr for fixup later
001197  1  73 E9        	JMPR If7		; finish
001199  1               
001199  1               
001199  1  54 68 65 6E   FHdr 'Then',ha_immediate ; ( addr n -- ) (compile)
00119D  1  44 11 8C     
0011A0  1                  ; Occurs in a colon-definition in form:
0011A0  1                  ;	IF ... ENDIF
0011A0  1                  ;	IF ... ELSE ... THEN
0011A0  1                  ; At run-time, ENDIF serves only as the destination of a forward branch from
0011A0  1                  ; IF or ELSE . It marks the conclusion of the conditional structure.
0011A0  1                  ; THEN is another name for ENDIF.  Both names are supported in fig-FORTH.
0011A0  1                  ; See also IF and ELSE .
0011A0  1                  ;
0011A0  1                  ; At compile-time, ENDIF computes the forward branch offset from addr to
0011A0  1                  ; HERE and stores it at addr. n is used for error tests.
0011A0  1                  ; https://forth-standard.org/standard/core/THEN
0011A0  1  90 00 02     Then:	LDAL 2		; verify we're paired with an IF , & compiling
0011A3  1  79 0F 81     	JSRD QPairsA
0011A6  1  D5 81        	LDBX ZW,ModBRPB,0	; fixup IF branch addr
0011A8  1  91 70 70     	LDAD VDP
0011AB  1  B5 28 FE     	STAX BW,ModNBRB,$fe
0011AE  1  09           	RSR		; return
0011AF  1               
0011AF  1               
0011AF  1               	.if 0
0011AF  1                FHdr 'EndIf',ha_immediate ;  FIG alias
0011AF  1               	JMPR Then
0011AF  1               	.endif
0011AF  1               
0011AF  1               
0011AF  1  42 65 67 69   FHdr 'Begin',ha_immediate ;  https://forth-standard.org/standard/core/BEGIN
0011B3  1  6E 45 11 A0  
0011B7  1                  ; Compiling: ( -- addr n )
0011B7  1                  ; Occurs in a colon-definition in the form:
0011B7  1                  ;	BEGIN ... UNTIL
0011B7  1                  ;	BEGIN ... AGAIN
0011B7  1                  ;	BEGIN ... WHILE ... REPEAT
0011B7  1                  ; At run-time, begin marks the start of a sequence that may be repetetively executed.
0011B7  1                  ; It serves as a return point from the corresponding UNTIL , AGAIN or REPEAT .
0011B7  1                  ; When executing UNTIL , a return to BEGIN will occur if the top of
0011B7  1                  ; the stack is false; for AGAIN and REPEAT a return to BEGIN always occurs.
0011B7  1                  ;
0011B7  1                  ; At compile time BEGIN leaves its return address and n for compiler error checking.
0011B7  1  79 0F 56     Begin:	JSRD QComp	; verify we're compiling
0011BA  1  79 0C 01     	JSRD Here	; push dictionary addr
0011BD  1  71 0A 59     	JMPD One	; push "Begin" pairing code, & return
0011C0  1               
0011C0  1               
0011C0  1  55 6E 74 69   FHdr 'Until',ha_immediate ;  (     f -- ) (run-time)
0011C4  1  6C 45 11 B7  
0011C8  1               			  ;  ( adr n -- ) (compile)
0011C8  1                  ; Occurs withing a colon-definition in the form:
0011C8  1                  ;	BEGIN .. UNTIL
0011C8  1                  ; At run-time, UNTIL controls the conditional branch back to the corresponding
0011C8  1                  ; BEGIN .  If f is false, execution returns to just after BEGIN ;
0011C8  1                  ; if true, execution continues ahead.
0011C8  1                  ;
0011C8  1                  ; At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to addr.
0011C8  1                  ; n is used for error tests.
0011C8  1                  ; https://forth-standard.org/standard/core/UNTIL
0011C8  1  90 00 01     Until:	LDAL 1		; varify we're paired with a BEGIN, & compiling
0011CB  1  79 0F 81     	JSRD QPairsA
0011CE  1  71 11 66     	JMPD PZBranchComma ; compile a 0Branch
0011D1  1               
0011D1  1               
0011D1  1  45 6E 64 43   FHdr 'End',ha_immediate ; FIG alias
0011D5  1  11 C8        
0011D7  1  73 EF        	JMPR Until
0011D9  1               
0011D9  1               
0011D9  1  41 67 61 69   FHdr 'Again',ha_immediate ; ( addr n -- ) (compiling)
0011DD  1  6E 45 11 D7  
0011E1  1                  ; Used in a colon-definition in the form:
0011E1  1                  ;	BEGIN ... AGAIN
0011E1  1                  ; At run-time, AGAIN forces execution to return to the corresponding BEGIN.
0011E1  1                  ; Three is no effect on the stack.  Execution cannot leave this loop (unless
0011E1  1                  ; R> DROP is executed one level below).
0011E1  1  90 00 01     Again:	LDAL 1		; verify we're paired with a BEGIN, & compiling
0011E4  1  79 0F 81     	JSRD QPairsA
0011E7  1  80 73        	LDABL $73	; compile "jmpr adr", & return
0011E9  1  71 11 31     	JMPD BranchCommaA
0011EC  1               
0011EC  1               
0011EC  1  57 68 69 6C   FHdr 'While',ha_immediate ; (    f -- ) (run-time)
0011F0  1  65 45 11 E1  
0011F4  1               				  ; ( ad1 n1 -- ad1 n1 ad2 n2 )
0011F4  1                  ; Occurs in a colon-definition in the form:
0011F4  1                  ;	BEGIN ... WHILE (tp) ... REPEAT
0011F4  1                  ; At run-time, WHILE selects conditional executing based on bool flag f.
0011F4  1                  ; If f is true (non-zero), WHILE continues execution of the true part thru to
0011F4  1                  ; REPEAT , which then branches back to BEGIN .  If f is false (zero), execution
0011F4  1                  ; skips to just after REPEAT , exiting the structure.
0011F4  1                  ;
0011F4  1                  ; At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the reserved
0011F4  1                  ; offset.  The stack values will be resolved by REPEAT .
0011F4  1                  ; https://forth-standard.org/standard/core/WHILE
0011F4  1  71 11 75     While:	JMPD If
0011F7  1               
0011F7  1               
0011F7  1  52 65 70 65   FHdr 'Repeat',ha_immediate ; ( addr n -- ) (compiling)
0011FB  1  61 74 46 11  
0011FF  1  F4           
001200  1                  ; Used withing a colon-definition in the form:
001200  1                  ;	BEGIN ... WHILE ... REPEAT
001200  1                  ; At run-time, REPEAT forces an unconditional branch back to just after
001200  1                  ; the corresponding BEGIN .
001200  1                  ;
001200  1                  ; At compile-time, REPEAT compiles BRANCH and the offset from HERE to addr.
001200  1                  ; n is used for pairing testing.
001200  1                  ; https://forth-standard.org/standard/core/REPEAT
001200  1  79 03 B9     Repeat:	JSRD ToR		; save While info
001203  1  79 03 B9     	JSRD ToR
001206  1  7B D9        	JSRR Again		; compile branch to Begin
001208  1  79 03 AF     	JSRD RFrom		; restore While info
00120B  1  79 03 AF     	JSRD RFrom
00120E  1  73 90        	JMPR Then		; fixup While
001210  1               
001210  1               
001210  1               	.if 0
001210  1               
001210  1               ;----------------------------------------------------------------------
001210  1               ; Case
001210  1               ;   9 Of ." JACK" EndOf
001210  1               ;  10 Of ." QUEEN" EndOf
001210  1               ;  11 Of ." KING" EndOf
001210  1               ;  12 Of ." ACE" EndOf
001210  1               ;       Dup 2 + .
001210  1               ;  EndCase
001210  1               
001210  1               
001210  1               	.if 0
001210  1                FHdr 'Case',ha_Immediate ;  http://forth-standard.org/standard/core/CASE
001210  1                  ; Interpretation: Interpretation semantics for this word are undefined.
001210  1                  ; Compilation: ( C: -- case-sys )
001210  1                  ;	Mark the start of the CASE. . .OF. . .ENDOF. . .ENDCASE structure. Append the run-time
001210  1                  ;	semantics given below to the current definition.
001210  1                  ; Run-time: ( -- )
001210  1                  ;	continue execution.
001210  1               Case:	LDAL Case
001210  1               	STAX ZW,ModBMRB,0
001210  1               	JMPD Zero
001210  1               	.endif
001210  1               
001210  1               
001210  1               	.if 0
001210  1                FHdr '?Of',ha_Immediate ; accept flag
001210  1               QOf:	JSRD Abort ;???
001210  1               	lda #@x
001210  1               	jsr CompileInlineA
001210  1               	bra Of3
001210  1               
001210  1               @x:	PopAm
001210  1               	tay
001210  1               	bne @x4
001210  1               	jmp Abort
001210  1               @x4:	.word INL_End
001210  1               	.endif
001210  1               
001210  1               
001210  1                FHdr 'Of',ha_Immediate ;  http://forth-standard.org/standard/core/OF
001210  1                  ; Interpretation: Interpretation semantics for this word are undefined.
001210  1                  ; Compilation: ( C: -- of-sys )
001210  1                  ;	Put of-sys onto the control flow stack. Append the run-time semantics given below to the
001210  1                  ;	current definition. The semantics are incomplete until resolved by a consumer of of-sys
001210  1                  ;	such as ENDOF.
001210  1                  ; Run-time: ( x1 x2 -- | x1 )
001210  1                  ;	If the two values on the stack are not equal, discard the top value and continue execution
001210  1                  ;	at the location specified by the consumer of of-sys, e.g., following the next ENDOF.
001210  1                  ;	Otherwise, discard both values and continue execution in line.
001210  1               Of:	JSRD Abort ;???
001210  1               	lda #OfX
001210  1               	jsr CompileInlineA
001210  1               Of3:	lda #Of
001210  1               	jsr Mark2
001210  1               	lda #$e8e8	; inx inx
001210  1               	jmp CommaA
001210  1               
001210  1               OfX:	PopAm
001210  1               	cmp 0,x
001210  1               	bne *
001210  1               	.word INL_End
001210  1               
001210  1               
001210  1               	.if 0
001210  1               
001210  1                FHdr 'Of>',ha_Immediate
001210  1               OfG:	lda #0 ;???	; (ble)
001210  1               	JSRD Abort ;??? bra of2
001210  1               
001210  1               
001210  1                FHdr 'Of>=',ha_Immediate
001210  1               OfGe:	lda #0 ;???	; (blt)
001210  1               	JSRD Abort ;??? bra of2
001210  1               
001210  1               
001210  1                FHdr 'Of<',ha_Immediate
001210  1               OfL:	lda #0 ;???	; (bge)
001210  1               	JSRD Abort ;??? bra of2
001210  1               
001210  1               
001210  1                FHdr 'Of<=',ha_Immediate
001210  1               OfLe:	lda #0 ;???	; (bgt)
001210  1               	JSRD Abort ;??? bra of2
001210  1               
001210  1               	.endif
001210  1               
001210  1               
001210  1                FHdr 'EndOf',ha_Immediate ;  http://forth-standard.org/standard/core/ENDOF
001210  1                  ; Interpretation: Interpretation semantics for this word are undefined.
001210  1                  ; Compilation: ( C: case-sys1 of-sys -- case-sys2 )
001210  1                  ;	Mark the end of the OF. . .ENDOF part of the CASE structure. The next location for a
001210  1                  ;	transfer of control resolves the reference given by of-sys. Append the run-time semantics
001210  1                  ;	given below to the current definition. Replace case-sys1 with case-sys2 on the controlflow
001210  1                  ;	stack, to be resolved by ENDCASE.
001210  1                  ; Run-time: ( -- )
001210  1                  ;	continue execution at the location specified by the consumer of case-sys2.
001210  1               EndOf:	JSRD Abort ;???
001210  1               	lda 2,x
001210  1               	cmp #Of
001210  1               	bne @90
001210  1               	lda 6,x
001210  1               	cmp #Case
001210  1               	bne @90
001210  1               	lda 4,x
001210  1               	ldy MPtr
001210  1               	sty 4,x
001210  1               	jsr JmpCommaA
001210  1               
001210  1               	lda MPtr	;fix the OF
001210  1               	sec
001210  1               	sbc 0,x		;  calc branch displacement
001210  1               	cmp #$80	;  check range
001210  1               	bcs @range
001210  1               	dec 0,x
001210  1               	sep #pm
001210  1               	sta (0,x)
001210  1               	rep #pm
001210  1               	jmp DDrop
001210  1               
001210  1               ;	ldy 0,x		;fix the OF
001210  1               ;	dey		;  short version in-range?
001210  1               ;	dey
001210  1               ;	dey
001210  1               ;	sty @adr
001210  1               ;	lda mp
001210  1               ;	sec
001210  1               ;	sbc @adr
001210  1               ;	cmp #$80
001210  1               ;	bcs @75
001210  1               ;	dey		;  modify to short version
001210  1               ;	dey
001210  1               ;	sep #pm
001210  1               ;	sta a:1,y	;    store displacement
001210  1               ;	lda a:0,y	;    flip sense of branch
001210  1               ;	eor #$20
001210  1               ;	sta a:0,y
001210  1               ;	lda #$89	;    pad with bit #
001210  1               ;	sta a:2,y
001210  1               ;	rep #pm
001210  1               ;	lda #0
001210  1               ;	sta a:3,y
001210  1               ;	bra @79
001210  1               ;
001210  1               ;@75:	lda mp		; fix long version
001210  1               ;	sta a:1,y
001210  1               ;@79:	jmp DDrop
001210  1               
001210  1               @range:	jsr DotQuoteR
001210  1               	.byte 12," Too large! "
001210  1               @90:	jsr Abort
001210  1               
001210  1               
001210  1                FHdr 'EndCase',ha_Immediate ;  http://forth-standard.org/standard/core/ENDCASE
001210  1                  ; Interpretation: Interpretation semantics for this word are undefined.
001210  1                  ; Compilation: ( C: case-sys -- )
001210  1                  ;	Mark the end of the CASE. . .OF. . .ENDOF. . .ENDCASE structure. Use case-sys to resolve
001210  1                  ;	the entire structure. Append the run-time semantics given below to the current definition.
001210  1                  ; Run-time: ( x -- )
001210  1                  ;	Discard the case selector x and continue execution.
001210  1               EndCase:
001210  1               	lda #$e8e8	; inx; inx  drop selector
001210  1               	jsr CommaA
001210  1               	lda 2,x
001210  1               	cmp #Case
001210  1               	bne @90
001210  1               	ldy 0,x		;fix endof jmp list
001210  1               	beq @19
001210  1               @11:	lda a:1,y
001210  1               	pha
001210  1               	lda MPtr
001210  1               	sta a:1,y
001210  1               	ply
001210  1               	bne @11
001210  1               @19:	jmp DDrop
001210  1               
001210  1               @90:	jsr Abort
001210  1               
001210  1               	.endif
001210  1               
001210  1               
001210  1  44 6F 42 12   FHdr 'Do',ha_immediate	; ( n1 n2 -- ) (execute)
001214  1  00           
001215  1               			; ( addr n -- ) (compile)
001215  1                  ; Occurs in a colon-definition in form:
001215  1                  ;	DO ... LOOP
001215  1                  ;	DO ... +LOOP
001215  1                  ; At run time, DO begins a sequence with repetitive execution controlled by a
001215  1                  ; loop limit n1 and an index with initial valie n2.  DO removes these from the
001215  1                  ; stack.  Upon reaching LOOP the index is incremented by one.  Until the new
001215  1                  ; index equals or exceeds the limit, execution loops back to just after DO ;
001215  1                  ; otherwise the loop parameters are discarded and execution continues ahead.
001215  1                  ; Both n1 and n2 are determined at run-time and may be the results of other
001215  1                  ; operations.  Within a loop 'I' will copy the current value of the index to
001215  1                  ; the stack.  See I Loop +LOOP LEAVE .
001215  1                  ; When compiling within the colon-definitions, DO compiles (DO) , leaves the
001215  1                  ; following addresss addr and n for later error checking.
001215  1                  ; https://forth-standard.org/standard/core/DO
001215  1  90 12 21     Do:	LDAL PDo		; compile "jsr PDo"
001218  1  79 10 D7     	JSRD JsrCommaA
00121B  1  79 0C 01     	JSRD Here		; push addr
00121E  1  71 0A 6D     	JMPD Three		; push DO pairing code, & return
001221  1               
001221  1               PDo: ; runtime
001221  1  71 03 C4     	JMPD TwoToR
001224  1               ;	LDAX ZW,ModBRPB,0	; pop index
001224  1               ;	LDBX ZW,ModBRPB,0	; pop limit
001224  1               ;	STBX SW,ModBMRB,0	; push limit
001224  1               ;	STAX SW,ModBMRB,0	; push index
001224  1               ;	RSR			; return
001224  1               
001224  1               
001224  1               	.if 0
001224  1                FHdr '?DO',ha_immediate
001224  1                  ; Interpretation:
001224  1                  ;   Interpretation semantics for this word are undefined.
001224  1                  ; Compilation:
001224  1                  ;   ( C: -- do-sys )
001224  1                  ;   Put do-sys onto the control-flow stack. Append the run-time semantics given below to the current definition.
001224  1                  ;   The semantics are incomplete until resolved by a consumer of do-sys such as LOOP.
001224  1                  ;
001224  1                  ; Run-time:
001224  1                  ;   ( n1 | u1 n2 | u2 -- ) ( R: -- loop-sys )
001224  1                  ;   If n1 | u1 is equal to n2 | u2, continue execution at the location given by the consumer of do-sys.
001224  1                  ;   Otherwise set up loop control parameters with index n2 | u2 and limit n1 | u1 and continue executing immediately following ?DO. Anything already on the return stack becomes unavailable until the loop control parameters are discarded. An ambiguous condition exists if n1 | u1 and n2 | u2 are not both of the same type.
001224  1                  ; https://forth-standard.org/standard/core/qDO
001224  1               	.endif
001224  1               
001224  1               
001224  1  4C 65 61 76   FHdr 'Leave',0 ; ( -- )
001228  1  65 05 12 15  
00122C  1                  ; Force termination of a DO-LOOP at the next opportunity by setting the loop limit
00122C  1                  ; equal to the current value of the index.  The index itself remains unchanged, and
00122C  1                  ; execution proceeds normally until LOOP or +LOOP is encountered.
00122C  1                  ; https://forth-standard.org/standard/core/LEAVE
00122C  1  95 A8 02     Leave:	LDAX SW,ModNBRB,2	; limit=index
00122F  1  BD           	STAA SW
001230  1  09           	RSR			; return
001231  1               
001231  1               
001231  1               	.if 0
001231  1                FHdr 'Unloop',ha_immedate
001231  1                  ; Interpretation:
001231  1                  ;   Interpretation semantics for this word are undefined.
001231  1                  ; Execution:
001231  1                  ;   ( -- ) ( R: loop-sys -- )
001231  1                  ;   Discard the loop-control parameters for the current nesting level.
001231  1                  ;   An UNLOOP is required for each nesting level before the definition may be EXITed.
001231  1                  ;   An ambiguous condition exists if the loop-control parameters are unavailable.
001231  1               Unloop:	INR SW,4	; rdrop index & limit
001231  1               	RSR
001231  1               	.endif
001231  1               
001231  1               
001231  1  49 01 12 2C   FHdr 'I',0 ; ( -- n )
001235  1                  ; Used within a DO-LOOP to copy the loop index to the stack.
001235  1                  ; Other use is implementation dependent.
001235  1                  ; See R .
001235  1                  ; https://forth-standard.org/standard/core/I
001235  1  9D           I:	LDAA SW			; get 1st DO index
001236  1  B5 82        	STAX ZW,ModBMRB,0	; push it
001238  1  09           	RSR			; return
001239  1               
001239  1               
001239  1  4A 01 12 35   FHdr 'J',0 ; ( -- n )
00123D  1                  ; Used within a DO-LOOP to copy the loop limit to the stack.
00123D  1                  ; Other use is implementation dependent.
00123D  1                  ; See I .
00123D  1                  ; https://forth-standard.org/standard/core/J
00123D  1  95 A8 04     J:	LDAX SW,ModNBRB,4	; get 2nd DO index
001240  1  B5 82        	STAX ZW,ModBMRB,0	; push it
001242  1  09           	RSR			; return
001243  1               
001243  1               
001243  1  4C 6F 6F 70   FHdr 'Loop',ha_immediate; ( addr n -- ) (compiling)
001247  1  44 12 3D     
00124A  1                  ; Occurs in a colon-definition in form:
00124A  1                  ;	DO ... LOOP
00124A  1                  ; At run-time, LOOP selectively controls branching back to the corresponding
00124A  1                  ; DO based on the loop index and limit.  The loop index is incremented by one
00124A  1                  ; and compared to the limit.  The branch back to DO occurs until the index >= limit;
00124A  1                  ; at than time, the parameters are discarded and execution continues ahead.
00124A  1                  ;
00124A  1                  ; At compile-time, uses addr to calculate an offset to DO .  n is used for error testing.
00124A  1                  ; https://forth-standard.org/standard/core/LOOP
00124A  1  90 00 03     Loop:	LDAL 3			; verify we're paired with a DO, & compiling
00124D  1  79 0F 81     	JSRD QPairsA
001250  1               
001250  1  90 12 5B     	LDAL PLoop		; compile "jsr PLoop"
001253  1  79 10 D7     Loop7:	JSRD JsrCommaA
001256  1  80 16        	LDABL $16		; compile "BM addr", & return
001258  1  71 11 31     	JMPD BranchCommaA
00125B  1               
00125B  1               ;	FHdr '(Loop)',0 ; ( -- )  LOOP runtime
00125B  1               PLoop:
00125B  1  9D           	LDAA SW			; increment index
00125C  1  38           	INA
00125D  1  BD           	STAA SW
00125E  1  D5 A8 02     	LDBX SW,ModNBRB,2	; signed compare to limit
001261  1  59           	SAB
001262  1  13 01        	BNF @Run2		; if overflow
001264  1  3B           	IVA			;   correct sign
001265  1               @Run2:
001265  1  16 03        	BM @Run9		; if limit reached
001267  1  30 A3        	INR SW,4		;   rdrop index & limit
001269  1  3A           	CLA			;   clear neg flag to indicate fall thru
00126A  1  09           @Run9:	RSR			; returns negative flag: clear=fall thru, set=loop back
00126B  1               
00126B  1               
00126B  1  2B 4C 6F 6F   FHdr '+Loop',ha_immediate ; (      n1 -- ) (run)
00126F  1  70 45 12 4A  
001273  1               			   ; ( addr n2 -- ) (compile)
001273  1                  ; Used in a colon-definition in the form:
001273  1                  ;	DO  ...  n1 +LOOP
001273  1                  ; At run-time, +LOOP selectively controls branching back to the corresponding
001273  1                  ; DO based on n1, the loop index and the loop limit.  The signed increment
001273  1                  ; n1 is added to the index and the total compared to the limit.  The branch
001273  1                  ; back to DO occurs until the new index is >= the limit (n1>0), or until the
001273  1                  ; new index is <= the limit (n1<0).  Upon exiting the loop, the parameters
001273  1                  ; are discarded and execution continues ahead.
001273  1                  ;
001273  1                  ; At compile time, +LOOP compiles the run-time word (+LOOP) and the branch
001273  1                  ; offset from HERE to the address left on the stack by DO.  n2 is used for
001273  1                  ; compile time error checking.
001273  1                  ; https://forth-standard.org/standard/core/PlusLOOP
001273  1               PlusLoop:
001273  1  90 00 03     	LDAL 3		; verify we're paired with a DO , & compiling
001276  1  79 0F 81     	JSRD QPairsA
001279  1  90 12 7E     	LDAL PPlusLoop	; compile "jsr PPlusLoop"
00127C  1  73 D5        	JMPR Loop7	; & finish
00127E  1               
00127E  1               
00127E  1               ; FHdr '(+Loop)',0 ; ( n -- )  The run-time procecdure compiled by +LOOP,
00127E  1               		; which increments the loop index by n and tests for loop completion.
00127E  1               PPlusLoop:
00127E  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
001280  1  5C           	XAY
001281  1  DD           	LDBA SW			; add n to index
001282  1  58           	AAB
001283  1  FD           	STBA SW
001284  1  12 0C        	BF @Quit		; if overflow, we're done for sure
001286  1  95 A8 02     	LDAX SW,ModNBRB,2	; compare index with limit
001289  1  51 20        	SUB AW,BW
00128B  1  13 01        	BNF @3			; overflow?
00128D  1  3B           	IVA			;   correct overflowed sign
00128E  1  54 60        @3:	ORE AW,YW		; take into account the sign of n
001290  1  16 03        	BM @9			; if limit reached
001292  1  30 A3        @Quit:	INR SW,4		;   rdrop index & limit
001294  1  3A           	CLA			;   clear negative flag
001295  1  09           @9:	RSR			; returns negative flag: clear=fall thru, set=loop back
001296  1               
001296  1               
001296  1  43 72 65 61   FHdr 'Create',0 ;
00129A  1  74 65 06 12  
00129E  1  73           
00129F  1                  ; A defining word used in the form:
00129F  1                  ;	CREATE cccc
00129F  1                  ; by such words as CODE and CONSTANT to create a dictionary header for a Forth
00129F  1                  ; definition.  The code field contains the address of the words parameter field.
00129F  1                  ; The new word is created in the CURRENT vocabulary.
00129F  1                  ; https://forth-standard.org/standard/core/CREATE
00129F  1  79 12 B7     Create:	JSRD HeaderComma	; compile word header
0012A2  1  90 12 A8     	LDAL @Run		; compile "jsr @Run", & return
0012A5  1  71 10 D7     	JMPD JsrCommaA
0012A8  1               
0012A8  1  6D 82        @Run:	STXX ZW,ModBMRB,0	; push pfa
0012AA  1  65 A1        	LDXX SW,ModBRPB,0	; return to my caller's caller
0012AC  1  09           	RSR
0012AD  1               
0012AD  1               
0012AD  1  48 65 61 64   FHdr 'Header,',0 ; ( "name" -- )  compile a word header
0012B1  1  65 72 2C 07  
0012B5  1  12 9F        
0012B7  1                  ; name is next word in input buffer.
0012B7  1               HeaderComma:
0012B7  1  79 15 0F     	JSRD DFind		; check for name redefinition
0012BA  1               				; DFind also stores the name at HERE, including a preceding length
0012BA  1               				; byte that we don't use, but haven't discarded here yet.
0012BA  1  95 81        	LDAX ZW,ModBRPB,0	; found an existing word of the same name?
0012BC  1  14 0E        	BZ @2163
0012BE  1  30 81        	INR ZW,2		;   drop flags
0012C0  1               ;	JSRD CFA		;   CFA & NFA are the same in this implementation
0012C0  1  79 15 A1     	JSRD IdDot		;   type name
0012C3  1  90 00 04     	LDAL Err_IsntUnique	;   type message
0012C6  1  79 1A B9     	JSRD MessageA
0012C9  1  79 0C F6     	JSRD Space		;   type space
0012CC  1               @2163:
0012CC  1  3A           	CLA			; get name length
0012CD  1  82 70 70     	LDABI VDP
0012D0  1  C0 20        	LDBBL ha_length+1	; name too long?
0012D2  1  49           	SABB
0012D3  1  10 18        	BL @NameTooLong
0012D5  1  B5 A2        	STAX SW,ModBMRB,0	; save name length on return stack
0012D7  1               
0012D7  1  38           	INA			;   ???include the unused leading string char count byte
0012D8  1  79 0F C8     	JSRD AllotA		; skip over stored name
0012DB  1               
0012DB  1  95 A1        	LDAX SW,ModBRPB,0	; get original length
0012DD  1  79 11 10     	JSRD CCommaA		; store flags & length
0012E0  1               
0012E0  1  92 70 80     	LDAI VCurrent		; store dictionary link
0012E3  1  79 10 F6     	JSRD CommaA
0012E6  1  91 70 70     	LDAD VDP		; link into current vocabulary
0012E9  1  B2 70 80     	STAI VCurrent
0012EC  1               
0012EC  1  09           	RSR			; return
0012ED  1               
0012ED  1               @NameTooLong:
0012ED  1  79 17 82     	JSRD Abort
0012F0  1               
0012F0  1               
0012F0  1  49 6E 6C 69   FHdr 'Inline',0 ; ( -- )
0012F4  1  6E 65 06 12  
0012F8  1  B7           
0012F9  1                  ; Mark the most recently made definition so that when encountered at compile time,
0012F9  1                  ; it will be copied inline instead of JSRd to.
0012F9  1               Inline:
0012F9  1  79 13 A3     	JSRD Exit		; compile 2nd RSR as an end-of-word marker
0012FC  1  80 80        	LDABL ha_inline
0012FE  1  73 1B        	JMPR XorFlags
001300  1               
001300  1               
001300  1  49 6D 6D 65   FHdr 'Immediate',0 ; ( -- )
001304  1  64 69 61 74  
001308  1  65 09 12 F9  
00130C  1                  ; Mark the most recently made definition so that when encountered at compile time,
00130C  1                  ; it will be executed rather than being compiled.  i.e. the precedence bit in its
00130C  1                  ; header is set.  This method allows definitions to handle unusual compiling
00130C  1                  ; situations, rather than build them into the fundamental compiler.  The user may
00130C  1                  ; force compilation of an immediate definition by preceding it with [COMPILE] .
00130C  1                  ; https://forth-standard.org/standard/core/IMMEDIATE
00130C  1               Immediate:
00130C  1  80 40        	LDABL ha_immediate
00130E  1  73 0B        	JMPR XorFlags
001310  1               
001310  1               
001310  1  53 6D 75 64   FHdr 'Smudge',0 ; ( -- )
001314  1  67 65 06 13  
001318  1  0C           
001319  1                  ; Used during word definition to toggle the "smudge bit" in a definitions' name
001319  1                  ; field.  This prevents an uncompleted definition from being found during
001319  1                  ; dictionary searches, until compiling is completed without error.
001319  1  80 20        Smudge:	LDABL ha_smudge
00131B  1               XorFlags:
00131B  1  5C           	XAY			; Y=bits
00131C  1  D2 70 80     	LDBI VCurrent		; B=word ptr
00131F  1  85 28 FD     	LDABX BW,ModNBRB,$fd	; xor flags
001322  1  44 71        	OREB AL,YL
001324  1  A5 28 FD     	STABX BW,ModNBRB,$fd
001327  1  09           	RSR
001328  1               
001328  1               
001328  1  56 61 72 69   FHdr 'Variable',0 ; ( "name" n -- )
00132C  1  61 62 6C 65  
001330  1  08 13 19     
001333  1                  ; A defining word used in the form:
001333  1                  ;	n VARIABLE cccc
001333  1                  ; When VARIABLE is executed, it creates the definition cccc with its parameter field
001333  1                  ; initialized to n.  When cccc is later executed, the address of it's parameter field
001333  1                  ; (containing n) is left on the stack, so that a fetch or store may access this location.
001333  1                  ; https://forth-standard.org/standard/core/VARIABLE
001333  1               Variable:
001333  1  79 12 9F     	JSRD Create	; create a word that pushes it's parameter address
001336  1  3A           Varia2:	CLA
001337  1  71 10 F6     	JMPD CommaA	; alloc data space & store initial value
00133A  1               
00133A  1               
00133A  1  32 56 61 72   FHdr '2Variable',0 ; ( "name" n -- )
00133E  1  69 61 62 6C  
001342  1  65 09 13 33  
001346  1                  ; A defining word used in the form:
001346  1                  ;	d 2VARIABLE cccc
001346  1                  ; When 2VARIABLE is executed, it creates the definition cccc with its parameter field
001346  1                  ; initialized to d.  When cccc is later executed, the address of it's parameter field
001346  1                  ; (containing d) is left on the stack, so that a fetch or store may access this location.
001346  1                  ; https://forth-standard.org/standard/double/TwoVARIABLE
001346  1               TwoVariable:
001346  1  7B EB        	JSRR Variable		; header & 1st 2 bytes
001348  1  73 EC        	JMPR Varia2		; 2nd 2 bytes
00134A  1               
00134A  1               
00134A  1  43 6F 6E 73   FHdr 'Constant',0 ; ( n "name" -- )
00134E  1  74 61 6E 74  
001352  1  08 13 46     
001355  1                  ; A definining word used in the form:
001355  1                  ;	n CONSTANT cccc
001355  1                  ; to create word cccc.
001355  1                  ; When cccc is lated executed, it will push the value of n to the stack.
001355  1                  ; https://forth-standard.org/standard/core/CONSTANT
001355  1               Constant:
001355  1  79 12 B7     	JSRD HeaderComma	; compile a word header
001358  1  79 15 D1     	JSRD LitComma		; compile "lda #n", "sta (-z)"
00135B  1  71 13 A3     	JMPD Exit		; compile "rsr", & return
00135E  1               
00135E  1               
00135E  1  32 43 6F 6E   FHdr '2Constant',0 ; ( d "name" -- )
001362  1  73 74 61 6E  
001366  1  74 09 13 55  
00136A  1                  ; A definining word used in the form:
00136A  1                  ;	d 2CONSTANT cccc
00136A  1                  ; to create word cccc.
00136A  1                  ; When cccc is lated executed, it will push the value of d to the stack.
00136A  1                  ; https://forth-standard.org/standard/double/TwoCONSTANT
00136A  1               TwoConstant:
00136A  1  79 12 B7     	JSRD HeaderComma	; compile a word header
00136D  1  79 11 17     	JSRD LdbaComma		; compile "lda #d.lo; ldb #d.hi
001370  1  90 02 F9     	LDAL PushBA 		; compile "JMPD PushBA"
001373  1  71 10 EA     	JMPD JmpCommaA
001376  1               
001376  1               
001376  1               	.if 0
001376  1               
001376  1                FHdr 'Value',0
001376  1                  ; https://forth-standard.org/standard/core/VALUE
001376  1               Value:	JMPR Constant
001376  1               
001376  1               
001376  1                FHdr '2Value',0
001376  1                  ; https://forth-standard.org/standard/double/TwoVALUE
001376  1               TwoValue:
001376  1               	JMPR TwoConstant
001376  1               
001376  1               
001376  1                FHdr 'To',0
001376  1                  ; Interpretation:
001376  1                  ;   ( i * x "<spaces>name" -- )
001376  1                  ;   Skip leading spaces and parse name delimited by a space. Perform the "TO name run-time" semantics given in the definition for the defining word of name. An ambiguous condition exists if name was not defined by a word with "TO name run-time" semantics.
001376  1                  ;
001376  1                  ; Compilation:
001376  1                  ; ( "<spaces>name" -- )
001376  1                  ;   Skip leading spaces and parse name delimited by a space. Append the "TO name run-time" semantics given
001376  1                  ;   in the definition for the defining word of name to the current definition.
001376  1                  ;   An ambiguous condition exists if name was not defined by a word with "TO name run-time" semantics.
001376  1                  ; https://forth-standard.org/standard/core/TO
001376  1               To:	JSRD Abort ;???
001376  1               
001376  1               	.endif
001376  1               
001376  1               
001376  1  3A 41 13 6A   FHdr ':',ha_immediate ; ( "name" -- )  Start compiling a word
00137A  1                  ; Used in the form:
00137A  1                  ;	: ccc  ...  ;
00137A  1                  ; Creates a dictionary entry defining ccc as equivalent to the following
00137A  1                  ; sequence of Forth word definitions '...' until the next ';' or ';CODE'.
00137A  1                  ; The compiling process is done by the text interpreter as long as STATE is
00137A  1                  ; non-zero.  Other details are that the CONTEXT vocabulary is set to the CURRENT
00137A  1                  ; vocabulary and that WORDS with the precedence bit set (P) are executed
00137A  1                  ; rather that being compiled.
00137A  1                  ; https://forth-standard.org/standard/core/Colon
00137A  1  79 12 B7     Colon:	JSRD HeaderComma	; compile word header
00137D  1  79 13 19     	JSRD Smudge		; smudge the word so we won't find it until done
001380  1  79 0F 6D     Colon3:	JSRD QExec		; verify we're not already compiling
001383  1  79 0F 92     	JSRD SCSP		; save param stack index to compare later
001386  1  91 70 80     	LDAD VCurrent		; Context vocabulary = current vocabulary
001389  1  B1 70 7E     	STAD VContext
00138C  1  73 27        	JMPR RBracket		; set compile mode, & return
00138E  1               
00138E  1               
00138E  1  3B 41 13 7A   FHdr ';',ha_immediate ; ( -- )  Terminates a colon-definition and stop further compilation.
001392  1                  ; https://forth-standard.org/standard/core/Semi
001392  1  79 0F 9F     Semi:	JSRD QCSP		; check that param stack index = when we started compiling
001395  1  7B 0C        	JSRR Exit		; compile "rsr"
001397  1  79 13 19     	JSRD Smudge		; Un-smudge the word header
00139A  1  73 10        	JMPR LBracket		; set interpret mode, & return
00139C  1               
00139C  1               
00139C  1               	.if 0
00139C  1                FHdr ':Noname',0 ; ( C: -- colon-sys ) ( S: -- xt )
00139C  1                  ; Create an execution token xt, enter compilation state and start the current definition, producing colon-sys.
00139C  1                  ; Append the initiation semantics given below to the current definition.
00139C  1                  ;
00139C  1                  ; The execution semantics of xt will be determined by the words compiled into the body of the definition.
00139C  1                  ; This definition can be executed later by using xt EXECUTE.
00139C  1                  ;
00139C  1                  ; If the control-flow stack is implemented using the data stack, colon-sys shall be the topmost item on the data stack.
00139C  1                  ; See 3.2.3.2 Control-flow stack.
00139C  1               CNoname:
00139C  1               	LDABL ha_smudge
00139C  1               	JSRD CCommaA		; compile flags & length
00139C  1               	CLA
00139C  1               	JSRD CommaA		; compile fake dictionary link
00139C  1               	JSRD Here		; push xt
00139C  1               	JMPR Colon3
00139C  1               	.endif
00139C  1               
00139C  1               
00139C  1  45 78 69 74   FHdr 'Exit',ha_immediate ; ( -- ) https://forth-standard.org/standard/core/EXIT
0013A0  1  44 13 92     
0013A3  1                  ; Interpretation: Interpretation semantics for this word are undefined.
0013A3  1                  ; Execution: ( -- ) ( R: nest-sys -- )
0013A3  1                  ;	Return control to the calling definition specified by nest-sys. Before executing EXIT
0013A3  1                  ;	within a do-loop, a program shall discard the loop-control parameters by executing UNLOOP.
0013A3  1  80 09        Exit:	LDABL $09		; compile a RSR ( replaces ;S call )
0013A5  1  71 11 10     	JMPD CCommaA
0013A8  1               
0013A8  1               
0013A8  1  5B 41 13 A3   FHdr '[',ha_immediate ; ( -- )  Suspend compilation.
0013AC  1                  ; Used in a colon-definition in form:
0013AC  1                  ;	: xxx  [ words ]  more ;
0013AC  1                  ; The words after [ are executed, not compiled.  This allows
0013AC  1                  ; calculation or compilation exceptions before resuming compilation with ] .
0013AC  1                  ; See LITERAL ]
0013AC  1                  ; https://forth-standard.org/standard/core/Bracket
0013AC  1               LBracket:
0013AC  1  3A           	CLA
0013AD  1  B1 70 82     LBrac3:	STAD VState	; set state to interpreting
0013B0  1  09           	RSR		; return
0013B1  1               
0013B1  1               
0013B1  1  5D 01 13 AC   FHdr ']',0 ; ( -- )  Resume compilation, to the completion of a colon-definition.
0013B5  1                  ; See [
0013B5  1               RBracket:
0013B5  1  32 01        	CLR AW,1	; set state to compiling (store non-zero)
0013B7  1  73 F4        	JMPR LBrac3
0013B9  1               
0013B9  1               
0013B9  1               	.if 0
0013B9  1                FHdr 'Synonym',0 ; ( "<spaces>newname" "<spaces>oldname" -- )
0013B9  1                  ; For both strings skip leading space delimiters. Parse newname and oldname delimited by a space.
0013B9  1                  ; Create a definition for newname with the semantics defined below.
0013B9  1                  ; Newname may be the same as oldname; when looking up oldname, newname shall not be found.
0013B9  1                  ;
0013B9  1                  ; An ambiguous conditions exists if oldname can not be found or IMMEDIATE is applied to newname.
0013B9  1                  ; https://forth-standard.org/standard/tools/SYNONYM
0013B9  1               Synonym:
0013B9  1               	JSRD Colon	; start a new word
0013B9  1               	JSRD Tick	; look up old word
0013B9  1               	LDABL $71	; build JMPD
0013B9  1               	JSRD CCommaA
0013B9  1               	JSRD Comma
0013B9  1               	JMPD Semi	; end new word
0013B9  1               	.endif
0013B9  1               
0013B9  1               
0013B9  1  3B 43 6F 64   FHdr ';Code',ha_immediate
0013BD  1  65 45 13 B5  
0013C1  1                  ; Used in the form:
0013C1  1                  ;	: ccc  ....  ;CODE
0013C1  1                  ;		assembly mnemonics
0013C1  1                  ; Stop compilation and terminate a new defining word cccc by compiling (;CODE) .
0013C1  1                  ; Set the CONTEXT vocabulary to ASSEMBLER, assembling to machine code the following
0013C1  1                  ; menmonics.
0013C1  1                  ;
0013C1  1                  ; When cccc later executes in the form:
0013C1  1                  ;	cccc nnnn
0013C1  1                  ; the word nnnn will be created with its execution procedure given by the machine
0013C1  1                  ; code following cccc.  That is, when nnnn is executed, it does so by jumping to the
0013C1  1                  ; code after nnnn.  An existing defining word must exist in cccc prior to ;CODE .
0013C1  1                  ; https://forth-standard.org/standard/tools/SemiCODE
0013C1  1  79 0F 9F     SCode:	JSRD QCSP	; make sure param stack is the same depth as when compile started
0013C4  1  90 13 CF     	LDAL PSCode	; compile "jsr PSCode"
0013C7  1  79 10 D7     	JSRD JsrCommaA
0013CA  1               
0013CA  1  7B E0        	JSRR LBracket	; state=interpret
0013CC  1  71 13 19     	JMPD Smudge	; un-smudge the word header
0013CF  1               
0013CF  1               
0013CF  1               ; FHdr '(;Code)',0 ;
0013CF  1                  ; The run-time procedure compiled by ;CODE, that rewrites the code field of the
0013CF  1                  ; most recently defined word to point to the following machine code sequence.
0013CF  1                  ; See ;CODE.
0013CF  1  D2 70 80     PSCode: LDBI VCurrent		; B=ptr to current word
0013D2  1  6D 28 01     	STXX BW,ModNBRB,1	; store in jsr operand of current word
0013D5  1  65 A1        	LDXX SW,ModBRPB,0	; pop my caller's addr
0013D7  1  09           	RSR
0013D8  1               
0013D8  1               
0013D8  1               	.if 0
0013D8  1                FHdr '<Builds',0 ;
0013D8  1                  ; Used within a colon-definition:
0013D8  1                  ;	: cccc <BUILDS ...
0013D8  1                  ;		DOES> ... ;
0013D8  1                  ; Each time cccc is executed, <BUILDS defines a new word with a high-level
0013D8  1                  ; execution procedure.  Executing cccc in the form:
0013D8  1                  ;	cccc nnnn
0013D8  1                  ; uses <BUILDS to create a dictionary entry for nnnn with a call to the DOES>
0013D8  1                  ; part for nnnn.  When nnnn is later executed, it has the address of its
0013D8  1                  ; parameter area on the stack and executes the words after DOES> in cccc.
0013D8  1                  ; <BUILDS and DOES> allow run-time procedures to be written in high-level
0013D8  1                  ; rather than in assembler code (as required by ;CODE ).
0013D8  1               Builds:	JMPD Create		; start a word with jsr, "jsr" address will be patched later
0013D8  1               	.endif
0013D8  1               
0013D8  1               
0013D8  1  44 6F 65 73   FHdr 'Does>',ha_immediate ;
0013DC  1  3E 45 13 C1  
0013E0  1                  ; A word which defines the run-time action withing a high-level defining word.
0013E0  1                  ; DOES> alters the code field and first parameter of the new word to execute
0013E0  1                  ; the sequence of compiled word addresses following DOES> .
0013E0  1                  ; Used in combination with <BUILDS . When the DOES> part executes it begins with the
0013E0  1                  ; address of the first parameter of the new word on the stack.
0013E0  1                  ; This allows interpretation using this area or its contents.
0013E0  1                  ; Typical uses include the Forth assembler, multidimensional arrays, and compiler generation.
0013E0  1                  ; https://forth-standard.org/standard/core/DOES
0013E0  1  90 13 CF     DoesG:	LDAL PSCode
0013E3  1  79 10 D7     	JSRD JsrCommaA
0013E6  1               
0013E6  1  90 6D 82     	LDAL $6D82	; compile "STXX ZW,ModBMRB,0" to push PFA
0013E9  1  79 10 F6     	JSRD CommaA
0013EC  1  90 65 A1     	LDAL $65A1	; compile "LDXX SW,ModBRPB,0" to fix return stack
0013EF  1  71 10 F6     	JMPD CommaA
0013F2  1               
0013F2  1               
0013F2  1  2E 28 42 13   FHdr '.(',ha_immediate ;  https://forth-standard.org/standard/core/Dotp
0013F6  1  E0           
0013F7  1                  ; Compilation:
0013F7  1                  ;   Perform the execution semantics given below.
0013F7  1                  ; Execution:
0013F7  1                  ;   ( "ccc<paren>" -- )
0013F7  1                  ; Parse and display ccc delimited by ) (right parenthesis). .( is an immediate word.
0013F7  1  D0 00 29     DotP:	LDBL ')'		; push ')'
0013FA  1  F5 82        DotP3:	STBX ZW,ModBMRB,0
0013FC  1  79 09 23     	JSRD Word		; get counted string
0013FF  1  79 0C 01     	JSRD Here		; push counted string addr
001402  1  79 08 58     	JSRD Count		; convert to addr & len
001405  1  71 0D 16     	JMPD Type		; type it & return
001408  1               
001408  1               
001408  1  2E 22 42 13   FHdr '."',ha_immediate ;
00140C  1  F7           
00140D  1                  ; Used in the form
00140D  1                  ;	." cccc"
00140D  1                  ; Compiles an in-line string cccc (delimited by the trailing ") with an
00140D  1                  ; execution procedure to transmit the text to the selected output device.
00140D  1                  ; If execute outside a definition, ." will immediately print the text until
00140D  1                  ; the final ".  The maximum number of chars may be an installation depended
00140D  1                  ; value.  See (.") .
00140D  1                  ; https://forth-standard.org/standard/core/Dotq
00140D  1  D0 00 22     DotQ:	LDBL '"'
001410  1  91 70 82     	LDAD VState		; interpreting?
001413  1  14 E5        	BZ DotP3
001415  1               
001415  1  90 14 2E     	LDAL PDotQuote		; compile "jsr PDotQuote"
001418  1  79 10 D7     	JSRD JsrCommaA
00141B  1  73 00        	JMPR CountedStringComma
00141D  1               
00141D  1               
00141D  1               CountedStringComma: ; compile a counted string
00141D  1  90 00 22     	LDAL '"'		; push '"'
001420  1  B5 82        	STAX ZW,ModBMRB,0
001422  1  79 09 23     	JSRD Word		; get counted string
001425  1  D1 70 70     	LDBD VDP		; alloc the space the string is using, & return
001428  1  3A           	CLA
001429  1  89           	LDABA BW
00142A  1  38           	INA
00142B  1  71 0F C8     	JMPD AllotA
00142E  1               
00142E  1               
00142E  1               ; FHdr '(.")',0 ; ( -- )
00142E  1                  ; The run-time procedure, compiled by ." which transmits the following
00142E  1                  ; in-line text to the selected output device.  See ."
00142E  1               PDotQuote:
00142E  1  3A           	CLA		; get length
00142F  1  85 41        	LDABX XW,ModBRPB,0
001431  1  6D 82        	STXX ZW,ModBMRB,0 ; push adr for TYPE
001433  1  B5 82        	STAX ZW,ModBMRB,0 ; push length for TYPE
001435  1  50 04        	ADD XW,AW	; fix my return addr
001437  1  71 0D 16     	JMPD Type	; Type & return
00143A  1               
00143A  1               
00143A  1               	.if 0
00143A  1                FHdr 'SLiteral',0
00143A  1                  ; Interpretation:
00143A  1                  ;    Interpretation semantics for this word are undefined.
00143A  1                  ; Compilation:
00143A  1                  ;   ( c-addr1 u -- )
00143A  1                  ;   Append the run-time semantics given below to the current definition.
00143A  1                  ;
00143A  1                  ; Run-time:
00143A  1                  ;   ( -- c-addr2 u )
00143A  1                  ;   Return c-addr2 u describing a string consisting of the characters specified by c-addr1 u
00143A  1                  ;   during compilation. A program shall not alter the returned string.
00143A  1                  ; https://forth-standard.org/standard/string/SLITERAL
00143A  1               SLiteral:
00143A  1               	JSRD Abort ;???
00143A  1               	.endif
00143A  1               
00143A  1               
00143A  1  53 22 42 14   FHdr 'S"',ha_immediate ; “s-quote” https://forth-standard.org/standard/core/Seq
00143E  1  0D           
00143F  1                  ; Modified to append a null to the string, so it's also zero-terminated.
00143F  1                  ; Interpretation: ( "string" -- addr len )
00143F  1                  ; Compilation: ( “ccc(quote)” -- )
00143F  1                  ;	Parse ccc delimited by " (double-quote). Append the run-time semantics given below to
00143F  1                  ;	the current definition.
00143F  1                  ; Run-time: ( -- c-addr u )
00143F  1                  ;	Return c-addr and u describing a string consisting of the characters ccc. A program shall
00143F  1                  ;	not alter the returned string.
00143F  1  91 70 82     SQuote:	LDAD VState		; compiling?
001442  1  14 06        	BZ @19
001444  1  90 14 6C     	LDAL SQuoteR		;   compile JSRD
001447  1  79 10 D7     	JSRD JsrCommaA
00144A  1               @19:
00144A  1               
00144A  1  90 00 22     	LDAL '"'		; get the counted string to VDP
00144D  1  B5 82        	STAX ZW,ModBMRB,0
00144F  1  79 09 23     	JSRD Word
001452  1  D1 70 70     	LDBD VDP
001455  1  3A           	CLA
001456  1  85 21        	LDABX BW,ModBRPB,0
001458  1  F5 82        	STBX ZW,ModBMRB,0	; push addr
00145A  1  B5 82        	STAX ZW,ModBMRB,0	; push length
00145C  1  38           	INA			; allocate the space, & return
00145D  1  79 0F C8     	JSRD AllotA
001460  1  3A           	CLA			; append a null
001461  1  79 11 10     	JSRD CCommaA
001464  1               
001464  1  91 70 82     	LDAD VState		; compiling?
001467  1  14 02        	BZ @39
001469  1  30 83        	INR ZW,4		;   drop addr & length
00146B  1               @39:
00146B  1  09           	RSR
00146C  1               
00146C  1               
00146C  1               ; FHdr '(S")',0 ; ( -- c-addr u )	run-time code for S"
00146C  1  3A           SQuoteR: CLA			; get length byte
00146D  1  85 41        	LDABX XW,ModBRPB,0
00146F  1  6D 82        	STXX ZW,ModBMRB,0	; push addr
001471  1  B5 82        	STAX ZW,ModBMRB,0	; push length
001473  1  50 04        	ADD XW,AW		; advance over the string data
001475  1  3E           	INXC			; also skip the trailing null
001476  1  09           	RSR
001477  1               
001477  1               
001477  1               	.if 0
001477  1                FHdr 'S\"',0
001477  1                  ; Interpretation:
001477  1                  ;   Interpretation semantics for this word are undefined.
001477  1                  ; Compilation:
001477  1                  ;   ( "ccc<quote>" -- )
001477  1                  ;   Parse ccc delimited by " (double-quote), using the translation rules below. Append the run-time semantics
001477  1                  ;   given below to the current definition.
001477  1               	JSRD Abort ;???
001477  1               	.endif
001477  1               
001477  1               
001477  1               	.if 0
001477  1                FHdr 'Environment?',0 ; ( c-addr u -- false | i * x true )
001477  1               EnvironmentQ:
001477  1               	JSRD Abort ;???
001477  1               	.endif
001477  1               
001477  1               
001477  1  28 46 69 6E   FHdr '(Find)',0 ; ( addr1 addr2 -- cfa b true ) (found)
00147B  1  64 29 06 14  
00147F  1  3F           
001480  1               		; ( addr1 addr2 --      false ) (notfound)
001480  1                  ; Searches the dictionary starting at the code address addr2,
001480  1                  ; matching to the counted string at addr1.
001480  1                  ; Returns name address (= code address), length byte of name field and boolean true for a good match.
001480  1                  ; If not match is found, only a boolean false is left.
001480  1               PFind:
001480  1  6D A2        	STXX SW,ModBMRB,0	; push X
001482  1               @addr2 = 0	; current word addr; must be offset 0
001482  1               @charlen = 2
001482  1               @nameadr = 4	; * last char of pattern name
001482  1               @len	= 6
001482  1               @zw	= 8
001482  1  55 80        	XFR AW,ZW
001484  1  B5 A2        	STAX SW,ModBMRB,0	; @zw
001486  1  65 88 02     	LDXX ZW,ModNBRB,2	; get addr1
001489  1  3A           	CLA			; get length
00148A  1  85 41        	LDABX XW,ModBRPB,0
00148C  1  B5 A2        	STAX SW,ModBMRB,0	; @len
00148E  1  5D           	XAB
00148F  1  50 42        	ADD BW,XW
001491  1  F5 A2        	STBX SW,ModBMRB,0	; @nameadr
001493  1  C5 28 FF     	LDBBX BW,ModNBRB,$ff	; get last char of name
001496  1  45 30        	XFRB AH,BL
001498  1  B5 A2        	STAX SW,ModBMRB,0	; @charlen
00149A  1  55 80        	XFR AW,ZW		; @addr2
00149C  1  30 01        	INR AW,2
00149E  1  B5 A2        	STAX SW,ModBMRB,0
0014A0  1               
0014A0  1  65 A0        @21:	LDXX SW,ModBRB,@addr2	; reload word ptr
0014A2  1  95 A8 02     	LDAX SW,ModNBRB,@charlen ; reload constant regs
0014A5  1  5E           	XAZ
0014A6  1  90 DF 3F     	LDAL $df*$100+ha_length+ha_smudge
0014A9  1  65 48 FE     @23:	LDXX XW,ModNBRB,$fe	; follow dictionary link to next word
0014AC  1  14 4D        	BZ @notfound
0014AE  1  D5 48 FC     	LDBX XW,ModNBRB,$fc	; check last char & length
0014B1  1  54 82        	ORE BW,ZW		;   saved @charlen
0014B3  1  5A           	NAB			;   saved bitmask
0014B4  1  15 F3        	BNZ @23
0014B6  1  6D A0        	STXX SW,ModBRB,@addr2	; save word ptr
0014B8  1               
0014B8  1  31 42        	DCR XW,3		; X=1 + end of name in word
0014BA  1  95 A8 04     	LDAX SW,ModNBRB,@nameadr ; Y=1 + end of name pattern
0014BD  1  5C           	XAY
0014BE  1  95 A8 06     	LDAX SW,ModNBRB,@len	; Z=# chars in name
0014C1  1  5E           	XAZ
0014C2  1  80 DF        	LDABL $df
0014C4  1  45 18        	XFRB ZH,AL
0014C6  1               @32:				; for each char
0014C6  1  21 90        	DCRB ZL			;   decrement length
0014C8  1  16 1A        	BM @found
0014CA  1  85 42        	LDABX XW,ModBMRB,0	;   get name char
0014CC  1  C5 62        	LDBBX YW,ModBMRB,0	;   get pattern char
0014CE  1  44 13        	OREB BL,AL		;   compare for exact match
0014D0  1  14 F4        	BZ @32
0014D2  1  42 83        	ANDB BL,ZH		;   just a case mismatch?
0014D4  1  15 CA        	BNZ @21
0014D6  1  42 81        	ANDB AL,ZH		;   cvt char to uppercase
0014D8  1  C0 41        	LDBBL 'A'		;   >='A'
0014DA  1  49           	SABB
0014DB  1  11 C3        	BNL @21
0014DD  1  C0 5B        	LDBBL 'Z'+1		;   <='Z'
0014DF  1  49           	SABB
0014E0  1  11 E4        	BNL @32
0014E2  1  73 BC        	JMPR @21
0014E4  1               
0014E4  1               @found:
0014E4  1  65 A0        	LDXX SW,ModBRB,@addr2	; get addr2
0014E6  1  30 A7        	INR SW,@zw		; rdrop the work area
0014E8  1  95 A1        	LDAX SW,ModBRPB,0	; restore ZW
0014EA  1  5E           	XAZ
0014EB  1  6D 88 02     	STXX ZW,ModNBRB,2	; save cfa
0014EE  1  3A           	CLA			; save b
0014EF  1  85 48 FD     	LDABX XW,ModNBRB,$fd
0014F2  1  BC           	STAA ZW
0014F3  1  90 00 01     	LDAL 1			; push flag
0014F6  1  B5 82        	STAX ZW,ModBMRB,0
0014F8  1  65 A1        	LDXX SW,ModBRPB,0	; pop X
0014FA  1  09           	RSR
0014FB  1               
0014FB  1               @notfound:
0014FB  1  30 A7        	INR SW,@zw		; rdrop the work area
0014FD  1  95 A1        	LDAX SW,ModBRPB,0	; restore ZW
0014FF  1  5E           	XAZ
001500  1  30 81        	INR ZW,2		; drop addr2
001502  1  3A           	CLA			; set flag false
001503  1  BC           	STAA ZW
001504  1  65 A1        	LDXX SW,ModBRPB,0	; pop X
001506  1  09           	RSR			; return
001507  1               
001507  1               
001507  1               	.if 0
001507  1                FHdr 'Find',0 ; ( c-addr -- c-addr 0 | xt 1 | xt -1 )
001507  1                  ; https://forth-standard.org/standard/core/FIND
001507  1               	JSRD Abort ;???
001507  1               	.endif
001507  1               
001507  1               
001507  1  2D 46 69 6E   FHdr '-Find',0	; ( "name" -- cfa b true  ) (found)
00150B  1  64 05 14 80  
00150F  1               		; ( "name" --       false ) (not found)
00150F  1                  ; Accepts the next text word (delimited by blanks) in the input stream to HERE,
00150F  1                  ; and searches the CONTEXT and then CURRENT vocabularies for a matching entry.
00150F  1                  ; If found, the dictionary entry's name field address (= CFA), its length byte,
00150F  1                  ; and a bool true is left.  Otherwise, only a bool false is left.
00150F  1  79 0A 78     DFind:	JSRD Bl			; get next word
001512  1  79 09 23     	JSRD Word
001515  1               
001515  1               	.if 0  ; debugging
001515  1               	JSRD PDotQuote
001515  1               	.byte 13," found word '"
001515  1               	JSRD Here
001515  1               	JSRD Count
001515  1               	JSRD Type
001515  1               	JSRD PDotQuote
001515  1               	.byte 2,"' "
001515  1               	.endif
001515  1               
001515  1  79 0C 01     	JSRD Here		; search Context
001518  1  92 70 7E     	LDAI VContext
00151B  1  B5 82        	STAX ZW,ModBMRB,0
00151D  1  79 14 80     	JSRD PFind
001520  1  9C           	LDAA ZW			; if not found
001521  1  15 0D        	BNZ @2073
001523  1  30 81        	INR ZW,2		;    drop the false
001525  1  79 0C 01     	JSRD Here		;    search Current
001528  1  92 70 80     	LDAI VCurrent
00152B  1  B5 82        	STAX ZW,ModBMRB,0
00152D  1  79 14 80     	JSRD PFind
001530  1  09           @2073:	RSR
001531  1               
001531  1               
001531  1  27 41 15 0F   FHdr "'",ha_immediate ; ( "name" -- nfa )
001535  1                  ; Used in the form:
001535  1                  ;	' nnnn
001535  1                  ; Leaves the code address of dictionary word nnnn.  As a compiler
001535  1                  ; directive, executes in a colon-definition to compile the address as a
001535  1                  ; literal.  If the word is not found after a search of CONTEXT and CURRENT,
001535  1                  ; an appropriate error message is given.  Pronounced "tick".
001535  1                  ; https://forth-standard.org/standard/core/Tick
001535  1  7B 03        Tick:	JSRR TickNew
001537  1  71 15 CB     	JMPD Literal		; handle addr as literal
00153A  1               
00153A  1               TickNew: ; ANSI style
00153A  1  79 15 0F     	JSRD DFind		; get name string, search active dictionarys
00153D  1  79 05 B5     	JSRD ZEqual		; throw exception if not found
001540  1  32 20        	CLR BW,Err_0
001542  1  79 0F 49     	JSRD QErrY
001545  1  30 81        	INR ZW,2		; drop word flags
001547  1  09           	RSR
001548  1               
001548  1               
001548  1  4C 46 41 03   FHdr 'LFA',0 ; ( pfa -- lfa )
00154C  1  15 35        
00154E  1                  ; Convert the Parameter Field Address of a word to its Link Field Address.
00154E  1  9C           LFA:	LDAA ZW
00154F  1  31 04        	DCR AW,3+2
001551  1  BC           	STAA ZW
001552  1  09           	RSR
001553  1               
001553  1               
001553  1  43 46 41 03   FHdr 'CFA',0 ; ( pfa -- cfa )
001557  1  15 4E        
001559  1                  ; Convert the Parameter Field Address of a word to its Code Field Address.
001559  1  9C           CFA:	LDAA ZW
00155A  1  31 02        	DCR AW,3
00155C  1  BC           	STAA ZW
00155D  1  09           	RSR
00155E  1               
00155E  1               
00155E  1  4E 46 41 03   FHdr 'NFA',0; ( pfa -- nfa )
001562  1  15 59        
001564  1                  ; Convert the Parameter Field Address of a word to its Name Field Address.
001564  1  73 F3        NFA:	JMPR CFA		; NFA=CFA in this inplementaion
001566  1               
001566  1               
001566  1  50 46 41 03   FHdr 'PFA',0 ; ( nfa -- pfa )
00156A  1  15 64        
00156C  1                  ; Convert the Name Field Address of a word to its Parameter Field Address.
00156C  1  9C           PFA:	LDAA ZW			; NFA=CFA in this implementation
00156D  1  30 02        	INR AW,3
00156F  1  BC           	STAA ZW
001570  1  09           	RSR
001571  1               
001571  1               
001571  1  3E 42 6F 64   FHdr '>Body',0 ; ( xt -- a-addr )
001575  1  79 05 15 6C  
001579  1                  ; a-addr is the data-field address corresponding to xt.
001579  1                  ; An ambiguous condition exists if xt is not for a word defined via CREATE.
001579  1                  ; https://forth-standard.org/standard/core/toBODY
001579  1  73 F1        ToBody:	JMPR PFA
00157B  1               
00157B  1               
00157B  1               	.if 0
00157B  1               
00157B  1                FHdr 'Name>Compile',0 ; ( nt -- x xt )
00157B  1                  ; x xt represents the compilation semantics of the word nt.
00157B  1                  ; The returned xt has the stack effect ( i * x x -- j * x ).
00157B  1                  ; Executing xt consumes x and performs the compilation semantics of the word represented by nt.
00157B  1                  ; https://forth-standard.org/standard/tools/NAMEtoCOMPILE
00157B  1               NameToCompile:
00157B  1               	JSRD Abort ;???
00157B  1               
00157B  1               
00157B  1                FHdr 'Name>Interpret',0 ; ( nt -- xt | 0 )
00157B  1                  ; xt represents the interpretation semantics of the word nt.
00157B  1                  ; If nt has no interpretation semantics, NAME>INTERPRET returns 0.
00157B  1                  ; https://forth-standard.org/standard/tools/NAMEtoINTERPRET
00157B  1               NameToInterpret:
00157B  1               	JSRD Abort ;???
00157B  1               
00157B  1               	.endif
00157B  1               
00157B  1               
00157B  1  4E 61 6D 65   FHdr 'Name>String',0 ; ( nfa -- c_addr u )
00157F  1  3E 53 74 72  
001583  1  69 6E 67 0B  
001587  1  15 79        
001589  1                  ; Get a word's name from its Name Field Address (aka CFA).
001589  1                  ;   https://forth-standard.org/standard/tools/NAMEtoSTRING
001589  1               NameToString:
001589  1  9C           	LDAA ZW		; get nfa
00158A  1  31 02        	DCR AW,3
00158C  1  5C           	XAY		; Y=cfa-3 (ptr to length & flags)
00158D  1  8B           	LDABA YW	; get length
00158E  1  D0 00 1F     	LDBL ha_length
001591  1  52 20        	ANDC AW,BW
001593  1  B5 82        	STAX ZW,ModBMRB,0 ; store length
001595  1  51 60        	SUB AW,YW	; calc start addr
001597  1  B5 88 02     	STAX ZW,ModNBRB,2 ; store addr
00159A  1  09           	RSR
00159B  1               
00159B  1               ;@6:
00159B  1               ; ???handle limited stored chars
00159B  1               ;	bit #$80
00159B  1               ;	beq @3
00159B  1               ;	bra @7
00159B  1               ;@6:	lda #'-'
00159B  1               ;	jsr EmitA
00159B  1               ;@7:	DCR N
00159B  1               ;	bpl @6
00159B  1               
00159B  1               ;	pla
00159B  1               ;	jmp Space
00159B  1               
00159B  1               
00159B  1  49 64 2E 03   FHdr 'Id.',0 ; ( nfa -- )  Print a definition's name from its code field address.
00159F  1  15 89        
0015A1  1  7B E6        IdDot:	JSRR NameToString
0015A3  1  79 0D 16     	JSRD Type
0015A6  1  71 0C F6     	JMPD Space
0015A9  1               
0015A9  1               
0015A9  1  5B 43 6F 6D   FHdr '[Compile]',ha_immediate
0015AD  1  70 69 6C 65  
0015B1  1  5D 49 15 A1  
0015B5  1               ; Used in a colon-definition in form:
0015B5  1               ;	: xxx [COMPILE] FORTH ;
0015B5  1               ; [COMPILE] will force the compilation of an immediate definition, that would otherwise
0015B5  1               ; execute during compilation.  The above example will select the FORTH vocabulary when xxx
0015B5  1               ; executes, rather than at compile time.
0015B5  1               BCompile:
0015B5  1  79 13 AC     	JSRD LBracket		; dont' have Tick compile it's results
0015B8  1  79 15 35     	JSRD Tick		; lookup the word
0015BB  1               ;	JSRR CFA		; CFA=NFA in this implementation
0015BB  1  79 10 B2     	JSRD CompileComma	; compile call
0015BE  1  71 13 B5     	JMPD RBracket		; back to compiling, & return
0015C1  1               
0015C1  1               
0015C1  1  4C 69 74 65   FHdr 'Literal',ha_immediate ; ( n -- ) (compiling)
0015C5  1  72 61 6C 47  
0015C9  1  15 B5        
0015CB  1               ; If compiling, then compile the stack value n as a 16 bit literal. This
0015CB  1               ; definition is immediate so that it will execute during a colon definition.
0015CB  1               ; The intended use is:
0015CB  1               ;	: xxx [ calculate ] LITERAL ;
0015CB  1               ; Compilation is suspended for the compile time calculation of a value.
0015CB  1               ; Compilation is resumed and LITERAL compiles this value.
0015CB  1               ; https://forth-standard.org/standard/core/LITERAL
0015CB  1               Literal:
0015CB  1  91 70 82     	LDAD VState		; interpreting?
0015CE  1  15 01        	BNZ LitComma
0015D0  1  09           	RSR
0015D1  1               
0015D1  1               LitComma:
0015D1  1  79 11 1F     	JSRD LdaImmedComma	; compile "LDAL n"
0015D4  1               PushAComma:			; compile "sta (-z)"
0015D4  1  90 B5 82     	LDAL $B582
0015D7  1  71 10 F6     	JMPD CommaA
0015DA  1               
0015DA  1               
0015DA  1               
0015DA  1  32 4C 69 74   FHdr '2Literal',ha_immediate ; ( d -- d ) (executing)
0015DE  1  65 72 61 6C  
0015E2  1  48 15 CB     
0015E5  1               			     ; ( d --   ) (compiling)
0015E5  1                  ; If compiling, compile a stack double number into a literal.  Later execution
0015E5  1                  ; of the definition containing the literal will push it to the stack.
0015E5  1                  ; If executing, the number will remain on the stack.
0015E5  1                  ; https://forth-standard.org/standard/double/TwoLITERAL
0015E5  1               TwoLiteral:
0015E5  1  91 70 82     	LDAD VState		; interpreting?
0015E8  1  14 0C        	BZ @2242
0015EA  1               
0015EA  1  79 11 17     	JSRD LdbaComma		; compile "ldy #d.hi" "lda #d.lo"
0015ED  1  79 15 D4     	JSRD PushAComma		; compile "STAX ZW,ModBMRB,0"
0015F0  1  90 F5 82     	LDAL $F582		; compile "STBX ZW,ModBMRB,0"
0015F3  1  71 10 F6     	JMPD CommaA
0015F6  1               
0015F6  1  09           @2242:	RSR			; return
0015F7  1               
0015F7  1               
0015F7  1  5B 43 68 61   FHdr '[Char]',ha_immediate ; compile a character literal
0015FB  1  72 5D 46 15  
0015FF  1  E5           
001600  1                  ; compile: ( "c" -- )
001600  1                  ; run: ( -- c )
001600  1                  ; Also: Number interprets 'c' as a character literal.
001600  1               ; https://forth-standard.org/standard/core/BracketCHAR
001600  1  7B 09        BChar:	JSRR Char
001602  1  73 C7        	JMPR Literal		; make a literal, & return
001604  1               
001604  1               
001604  1  43 68 61 72   FHdr 'Char',0 ; ( "<spaces>name" -- char )  Get value of ASCII char
001608  1  04 16 00     
00160B  1                  ; https://forth-standard.org/standard/core/CHAR
00160B  1                  ; Skip leading space delimiters. Parse name delimited by a space. Put the value of its first character onto the stack.
00160B  1  79 0A 78     Char:	JSRD Bl			; get next word
00160E  1  79 09 23     	JSRD Word
001611  1  D1 70 70     	LDBD VDP		; point at counted string
001614  1  3A           	CLA			; get 1st char
001615  1  85 28 01     	LDABX BW,ModNBRB,1
001618  1  B5 82        	STAX ZW,ModBMRB,0	; push it
00161A  1  09           	RSR
00161B  1               
00161B  1               
00161B  1  5B 27 5D 43   FHdr "[']",ha_immediate ; compile a word address literal
00161F  1  16 0B        
001621  1                  ; https://forth-standard.org/standard/core/BracketTick
001621  1  79 15 35     BTB:	JSRD Tick
001624  1  73 A5        	JMPR Literal
001626  1               
001626  1               
001626  1  3B 53 02 16   FHdr ';S',0 ; ( -- )  Stop interpretation of a screen.
00162A  1  21           
00162B  1                  ; Not anymore!: ;S was also the run-time word compiled at the
00162B  1                  ; end of a colon-defintion which returns execution to the calling procedure.
00162B  1  65 A1        SemiS:	LDXX SW,ModBRPB,0 ; drop our RSR addr, so we'll return to Interpret's caller
00162D  1  09           	RSR		; return
00162E  1               
00162E  1               
00162E  1  00 41 16 2B   FHdr 0,ha_immediate ; ( -- )  end-of-buffer
001632  1                  ; This is the dictionary entry for a name of one char of ASCII null.
001632  1                  ; It is the execution procedure to terminate interpretation of a line of text from the terminal
001632  1                  ; or within a disc buffer, as disk buffers always have a null just beyond the end.
001632  1  91 70 74     X_:	LDAD VBlk	; terminal?
001635  1  14 F4        	BZ SemiS
001637  1               
001637  1  3A           	CLA
001638  1  B1 70 76     	STAD VIn	; at the beginning of the Blk
00163B  1  91 70 74     	LDAD VBlk	; step to next Blk
00163E  1  30 0F        	INR AW
001640  1  B1 70 74     	STAD VBlk
001643  1  B5 82        	STAX ZW,ModBMRB,0 ; push Blk
001645  1  79 0A 50     	JSRD Zero	;   as a double
001648  1  79 0A A1     	JSRD BScr	; divide by blocks/screen
00164B  1  79 06 DA     	JSRD UMSlashMod	;  ( u_rem u_quot )
00164E  1  30 81        	INR ZW,2	; drop quot
001650  1  95 81        	LDAX ZW,ModBRPB,0 ; at end_of_screen?
001652  1  15 05        	BNZ @1828
001654  1  79 0F 6D     	JSRD QExec	;   verify we're interpreting
001657  1  65 A1        	LDXX SW,ModBRPB,0 ;   pop my RSR addr, so we'll return to Interpret's caller
001659  1  09           @1828:	RSR		; return
00165A  1               
00165A  1               
00165A  1  49 6E 74 65   FHdr 'Interpret',0 ;
00165E  1  72 70 72 65  
001662  1  74 09 16 32  
001666  1                  ; The other text interpreter which sequentially executes or compiles text from the
001666  1                  ; input stream (terminal or disc) depending on STATE .  If the word name cannot be
001666  1                  ; found after a search of CONTEXT and then CURRENT it is converted to a number
001666  1                  ; according to the current base.  That also failing, an error message echoing the
001666  1                  ; name with a " ?" will be given.
001666  1                  ; Text input will be taken according to the convention for WORD.  If a decimal point
001666  1                  ; is found as part of a number, a double number value will be left.  The decimal
001666  1                  ; point has no other purpose than to force this action.
001666  1                  ; See NUMBER
001666  1               Interpret:
001666  1  79 0F 26     @2272:	JSRD QStack		; check stack bounds
001669  1               
001669  1  81 70 90     	LDABD VLineComment	; ignore remainder of line?
00166C  1  14 19        	BZ @49
00166E  1  3A           	CLA
00166F  1  A1 70 90     	STABD VLineComment
001672  1  D1 70 74     	LDBD VBlk		; reading from disk?
001675  1  15 02        	BNZ @51
001677  1  7B B9        	JSRR X_			;  do end-of-line
001679  1  91 70 76     @51:	LDAD VIn		; go fwd to next C/L boundary
00167C  1  D0 00 3F     	LDBL 64-1		; C/L 1-
00167F  1  58           	AAB
001680  1  90 FF C0     	LDAL $FFC0		; C/L Invert
001683  1  5A           	NAB
001684  1  F1 70 76     	STBD VIn
001687  1               @49:
001687  1  79 15 0F     	JSRD DFind		; get next word from input & lookup
00168A  1  95 81        	LDAX ZW,ModBRPB,0	; found?
00168C  1  14 16        	BZ @2289
00168E  1  95 81        	LDAX ZW,ModBRPB,0	; get flags & name_length
001690  1  D1 70 82     	LDBD VState		; compiling?
001693  1  14 0A        	BZ @2284
001695  1  C0 40        	LDBBL ha_immediate	; immediate flag set?
001697  1  4A           	NABB
001698  1  15 05        	BNZ @2284
00169A  1               ;	JSRD CFA		; pfa to cfa
00169A  1  79 10 B2     	JSRD CompileComma	; compile a jsr to it
00169D  1  73 C7        	JMPR @2272		; next word
00169F  1               
00169F  1               @2284:
00169F  1               ;	JSRD CFA		; pfa to cfa
00169F  1  79 08 4E     	JSRD Execute		; execute it
0016A2  1  73 C2        	JMPR @2272		; next word
0016A4  1               
0016A4  1  79 0C 01     @2289:	JSRD Here		; convert it to a number
0016A7  1  79 09 DD     	JSRD Number
0016AA  1  91 70 86     	LDAD VDPL		; contained a '.'?
0016AD  1  38           	INA
0016AE  1  14 05        	BZ @2299
0016B0  1  79 15 E5     	JSRD TwoLiteral		; compile a double-cell literal
0016B3  1  73 B1        	JMPR @2272		; next word
0016B5  1               
0016B5  1  30 81        @2299:	INR ZW,2		; convert double-cell number to single-cell (drop hi cell)
0016B7  1  79 15 CB     	JSRD Literal		; compile a single-cell literal
0016BA  1  73 AA        	JMPR @2272
0016BC  1               
0016BC  1               
0016BC  1  56 6F 63 61   FHdr 'Vocabulary',0 ; ( "name" -- )
0016C0  1  62 75 6C 61  
0016C4  1  72 79 0A 16  
0016C8  1  66           
0016C9  1                  ; A defining word used in the form:
0016C9  1                  ;	VOCABULARY cccc
0016C9  1                  ; to create a vocabulary definition cccc .  Subsequent use of cccc will make it the CONTEXT
0016C9  1                  ; vocabulary which is searched first by INTERPRET .  The sequence "cccc DEFINITIONS" will
0016C9  1                  ; also make ccc the CURRENT vocabulary into which new definitions are placed.
0016C9  1                  ;
0016C9  1                  ; In fig-FORTH, cccc will be so chained as to include all definitions of the
0016C9  1                  ; vocabulary in which cccc is itself defined.  All vocabularys ultimately chain back to
0016C9  1                  ; Forth .  By convention, vocabulary names are to be declared IMMEDIATE .
0016C9  1                  ; See VOC-LINK
0016C9  1                  ; See Forth for a sample vocabulary word.
0016C9  1               Vocabulary:
0016C9  1  79 12 B7     	JSRD HeaderComma	; compile a word header
0016CC  1  79 13 0C     	JSRD Immediate		; make it immediate
0016CF  1  90 16 E7     	LDAL DoVoc		; compile "jsr DoVoc"
0016D2  1  79 10 D7     	JSRD JsrCommaA
0016D5  1               
0016D5  1  92 70 80     	LDAI VCurrent		; compile dictionary anchor
0016D8  1  79 10 F6     	JSRD CommaA
0016DB  1  D1 70 70     	LDBD VDP		; link into vocabulary chain
0016DE  1  91 70 72     	LDAD VVoc_Link
0016E1  1  F1 70 72     	STBD VVoc_Link
0016E4  1  71 10 F6     	JMPD CommaA
0016E7  1               
0016E7  1               
0016E7  1               DoVoc: ; set Context to this vocabulary
0016E7  1  69 70 7E     	STXD VContext
0016EA  1  65 A1        	LDXX SW,ModBRPB,0	; pop pfa
0016EC  1  09           	RSR			; return
0016ED  1               
0016ED  1               
0016ED  1  46 6F 72 74   FHdr 'Forth',ha_immediate ; The primary vocabulary.
0016F1  1  68 45 16 C9  
0016F5  1                  ; Execution makes FORTH the CONTEXT vocabulary.
0016F5  1                  ; Until additional user vocabularies are defined, new user definitions become part
0016F5  1                  ; of FORTH .  FORTH is immediate, so it will execute during the creation of a
0016F5  1                  ; colon-definition, to select this vocabularty at compile time.
0016F5  1  79 16 E7     Forth:	JSRD DoVoc	; use direct addressing, so PFA offset looks like other Vocab words
0016F8  1  00 00        XFor:	.dbyt 0		; points to latest word in this vocabulary
0016FA  1  00 00        	.dbyt 0		; vocab link, ends at zero
0016FC  1               
0016FC  1               
0016FC  1  44 65 66 69   FHdr 'Definitions',0 ; Set the CURRENT vocabulary to the CONTEXT vocabulary.
001700  1  6E 69 74 69  
001704  1  6F 6E 73 0B  
001708  1  16 F5        
00170A  1                  ; Used in the form:
00170A  1                  ;	cccc DEFINITIONS
00170A  1                  ; In the example, executing vocabulary name cccc made it the CONTEXT vocabulary
00170A  1                  ; and executing DEFINITIONS made both specify vocabulary cccc .
00170A  1                  ; https://forth-standard.org/standard/search/DEFINITIONS
00170A  1               Definitions:
00170A  1  91 70 7E     	LDAD VContext		; get context dictionary
00170D  1  B1 70 80     	STAD VCurrent		; set as current dictionary
001710  1  09           	RSR
001711  1               
001711  1               
001711  1  28 41 17 0A   FHdr '(',ha_immediate ;
001715  1                  ; Used in the form:
001715  1                  ;	( cccc)
001715  1                  ; Ignore a comment that will be delimited by a right parenthesis on the same line.
001715  1                  ; May occur during execution or in a colon-definition.
001715  1                  ; A blank after the leading parenthesis is required.
001715  1                  ; https://forth-standard.org/standard/core/p
001715  1  90 00 29     OParen:	LDAL ')'	; push ')'
001718  1  B5 82        	STAX ZW,ModBMRB,0
00171A  1  71 09 23     	JMPD Word	; get the string delimited by ')', & return
00171D  1               
00171D  1               
00171D  1  5C 41 17 15   FHdr '\',ha_immediate ; ignore rest of input line
001721  1                  ; https://forth-standard.org/standard/block/bs
001721  1                  ; https://forth-standard.org/standard/core/bs
001721  1  32 01        	CLR AW,1
001723  1  A1 70 90     	STABD VLineComment
001726  1  09           	RSR
001727  1               
001727  1               
001727  1               	.if 0
001727  1                FHdr 'Refill',0 ; ( -- flag )
001727  1                  ; Attempt to fill the input buffer from the input source, returning a true flag if successful.
001727  1                  ; When the input source is the user input device, attempt to receive input into the terminal input buffer.
001727  1                  ; If successful, make the result the input buffer, set >IN to zero, and return true.
001727  1                  ; Receipt of a line containing no characters is considered successful.
001727  1                  ; If there is no input available from the current input source, return false.
001727  1                  ;
001727  1                  ; When the input source is a string from EVALUATE, return false and perform no other action.
001727  1                  ; https://forth-standard.org/standard/block/REFILL
001727  1               	JSRD Abort ;???
001727  1               	.endif
001727  1               
001727  1               
001727  1  51 75 69 74   FHdr 'Quit',0 ; ( -- )
00172B  1  04 17 21     
00172E  1                  ; Clear the return stack, stop compilation, and return control to the operators
00172E  1                  ; terminal.  No message is given.
00172E  1                  ; https://forth-standard.org/standard/core/QUIT
00172E  1  3A           Quit:	CLA
00172F  1  A1 70 90     	STABD VLineComment	; disable line ignore
001732  1  B1 70 74     	STAD VBlk		; input from console
001735  1  B1 70 82     	STAD VState		; interpret mode
001738  1               @2388:				; begin
001738  1  79 02 31     	JSRD EmptyRStack	;   empty return stack
00173B  1  79 0C E1     	JSRD CR			;   newline
00173E  1  79 0E AF     	JSRD Query		;   get string to TIB
001741  1  79 16 66     	JSRD Interpret		;   interpret words in the string
001744  1  91 70 82     	LDAD VState		;   compiling?
001747  1  15 07        	BNZ @2399
001749  1  79 14 2E     	JSRD PDotQuote		;     type " OK"
00174C  1  03 20 4F 4B  	.byte 3,' OK'
001750  1               @2399:
001750  1  73 E6        	JMPR @2388		;  again
001752  1               
001752  1               
001752  1  41 62 6F 72   FHdr 'Abort"',ha_immediate ; Abort with inline message
001756  1  74 22 46 17  
00175A  1  2E           
00175B  1                  ; compile: ( "string" -- )
00175B  1                  ; run: ( f -- )
00175B  1  79 0F 56     AbortQ:	JSRD QComp		; verify we're compiling
00175E  1  90 17 67     	LDAL @Run		; compile JSR
001761  1  79 10 D7     	JSRD JsrCommaA
001764  1  71 14 1D     	JMPD CountedStringComma
001767  1               
001767  1               @Run: ; runtime
001767  1  3A           	CLA			; get inline string length
001768  1  85 41        	LDABX XW,ModBRPB,0
00176A  1  D5 81        	LDBX ZW,ModBRPB,0	; pop f
00176C  1  15 03        	BNZ @RunErr
00176E  1  50 04        	ADD XW,AW		; skip inline string
001770  1  09           	RSR
001771  1               
001771  1  F5 82        @RunErr: STBX ZW,ModBMRB,0	; push string addr
001773  1  B5 82        	STAX ZW,ModBMRB,0	; push string length
001775  1  79 0D 16     	JSRD Type		; type it
001778  1  73 08        	JMPR Abort		; abort
00177A  1               
00177A  1               
00177A  1  41 62 6F 72   FHdr 'Abort',0 ;
00177E  1  74 05 17 5B  
001782  1                  ; Clears the stacks and enter the execution state.  Return control to the
001782  1                  ; operators terminal, printing a message appropriate to the installation.
001782  1  79 02 45     Abort:	JSRD EmptyStack		; empty the param stack
001785  1  79 03 A6     	JSRD RAt		; type address that called us
001788  1  79 1D 02     	JSRD EX4
00178B  1  79 0D 3F     	JSRD Decimal		; set base to decimal
00178E  1  79 18 A8     	JSRD DR0		; select disc drive 0
001791  1  79 0C E1     	JSRD CR			; newline
001794  1  79 14 2E     	JSRD PDotQuote		; type literal
001797  1  19 66 69 67  	.byte 25,'fig-FORTH CPU6 subroutine'
00179B  1  2D 46 4F 52  
00179F  1  54 48 20 43  
0017A3  1  50 55 36 20  
0017A7  1  73 75 62 72  
0017AB  1  6F 75 74 69  
0017AF  1  6E 65        
0017B1  1  79 16 F5     	JSRD Forth		; make Forth vocabulary current
0017B4  1  79 17 0A     	JSRD Definitions	;   & definitions
0017B7  1  71 17 2E     	JMPD Quit		; restart the interpreter
0017BA  1               
0017BA  1               
0017BA  1  43 6F 6C 64   FHdr 'Cold',0 ;	Cold start the system.
0017BE  1  04 17 82     
0017C1  1                  ; May be called from the terminal to remove application programs and restart.
0017C1  1               Cold:
0017C1  1               ;	LDABL $40	; Add & link test 1
0017C1  1               ;	LDBBL $80
0017C1  1               ;	AABB
0017C1  1               ;	BNL @11
0017C1  1               ;	HLT
0017C1  1               ;@11:
0017C1  1               
0017C1  1               ;	LDABL $40	; Add & link test 2
0017C1  1               ;	LDBBL $fe
0017C1  1               ;	AABB
0017C1  1               ;	BL @12
0017C1  1               ;	HLT
0017C1  1               ;@12:
0017C1  1               
0017C1  1               ;	LDBBL $40	; Sub & link test 1
0017C1  1               ;	LDABL 2
0017C1  1               ;	SABB
0017C1  1               ;	BNL @13		;   no borrow
0017C1  1               ;	HLT
0017C1  1               ;@13:
0017C1  1               
0017C1  1               ;	LDBBL $40		; Sub & link test 2
0017C1  1               ;	LDABL $42
0017C1  1               ;	SABB
0017C1  1               ;	BL @14			;   borrow
0017C1  1               ;	HLT
0017C1  1               ;@14:
0017C1  1               
0017C1  1               ;	LDAL $c000
0017C1  1               ;	XAS
0017C1  1               ;	LDAL $8800		; to diag ROM CPU test
0017C1  1               ;	XAZ
0017C1  1               ;	JMPD $8849
0017C1  1               
0017C1  1  3A           	CLA			; disable RAM disk
0017C2  1  B1 70 5C     	STAD RamDiskCount
0017C5  1               
0017C5  1  91 02 0C     	LDAD ORIG+$0C		; Initialize Forth vocabulary
0017C8  1  B1 16 F8     	STAD XFor
0017CB  1  80 16        	LDABL 2+VVoc_Link-VUser	; user variables to initialize
0017CD  1  73 02        	JMPR L2433
0017CF  1               
0017CF  1               Warm: ; warm start the system
0017CF  1  80 10        	LDABL 2+VWarning-VUser	; user variaboles to initialize
0017D1  1               L2433:
0017D1  1  60 02 0C     	LDXL ORIG+$0c		; init some user variables from cold start area
0017D4  1  D0 70 5E     	LDBL VUser
0017D7  1  55 26        	XFR YW,BW
0017D9  1  C5 41        @2437:	LDBBX XW,ModBRPB,0
0017DB  1  E5 61        	STBBX YW,ModBRPB,0
0017DD  1  29           	DCAB
0017DE  1  17 F9        	BP @2437
0017E0  1               
0017E0  1  79 02 31     	JSRD EmptyRStack	; empty return stack
0017E3  1               
0017E3  1  79 02 45     	JSRD EmptyStack		; empty param stack
0017E6  1  79 0D 3F     	JSRD Decimal
0017E9  1               ;	JSRD UMStarTest1
0017E9  1               ;	JSRD UMSlashModTest1
0017E9  1               ;	JSRD MSlashModTest1
0017E9  1               
0017E9  1               ;	LDAL 12345		; test decimal print
0017E9  1               ;	STAX ZW,ModBMRB,0
0017E9  1               ;	JSRD Dot
0017E9  1               
0017E9  1  71 17 82     	JMPD Abort		; And off we go!
0017EC  1               
0017EC  1               
0017EC  1               	.if 0
0017EC  1                FHdr 'Using',0 ; ( "filename" -- )  Open a block file
0017EC  1               Using:	JSRD Bl
0017EC  1               	JSRD Word
0017EC  1               	HLT ; open the filename as a block file
0017EC  1               	RSR
0017EC  1               	.endif
0017EC  1               
0017EC  1               
0017EC  1  55 73 65 03   FHdr 'Use',0 ; ( -- addr )  variable:
0017F0  1  17 C1        
0017F2  1  90 70 00     Use:	LDAL VUse
0017F5  1  B5 82        	STAX ZW,ModBMRB,0
0017F7  1  09           	RSR
0017F8  1               
0017F8  1               
0017F8  1  50 72 65 76   FHdr 'Prev',0 ; ( -- adr )  variable:
0017FC  1  04 17 F2     
0017FF  1  90 70 02     Prev:	LDAL VPrev
001802  1  B5 82        	STAX ZW,ModBMRB,0
001804  1  09           	RSR
001805  1               
001805  1               
001805  1  46 69 72 73   FHdr 'First',0 ; ( -- adr )  constant: address of the first (lowest) block buffer.
001809  1  74 05 17 FF  
00180D  1  90 71 A1     First:	LDAL DArea
001810  1  B5 82        	STAX ZW,ModBMRB,0
001812  1  09           	RSR
001813  1               
001813  1               
001813  1  4C 69 6D 69  FHdr 'Limit',0 ; ( -- adr )  constant: address just above the highest memory available
001817  1  74 05 18 0D  
00181B  1               		; for a disc buffer.
00181B  1  90 75 B1     Limit:	LDAL DAreaEnd
00181E  1  B5 82        	STAX ZW,ModBMRB,0
001820  1  09           	RSR
001821  1               
001821  1               
001821  1  2B 42 75 66   FHdr '+Buf',0 ; ( addr1 -- addr2 f )
001825  1  04 18 1B     
001828  1               ; Advance the disc buffer address addr1 to the address of the next buffer addr2.
001828  1               ; Bool f is false when addr2 is the buffer presently pointed to by variable PREV.
001828  1  90 01 04     PBuf:	LDAL 2+SectorSize+2	 ; hold block #, one sector, ??? two num
00182B  1  DC           	LDBA ZW
00182C  1  50 20        	ADD AW,BW
00182E  1  D1 18 1C     	LDBD Limit+1
001831  1  59           	SAB
001832  1  10 03        	BL @2691
001834  1  91 18 0E     	LDAD First+1
001837  1  BC           @2691:	STAA ZW
001838  1  D1 70 02     	LDBD VPrev
00183B  1  54 20        	ORE AW,BW
00183D  1  B5 82        	STAX ZW,ModBMRB,0
00183F  1  09           	RSR
001840  1               
001840  1               
001840  1  55 70 64 61   FHdr 'Update',0 ; ( -- )
001844  1  74 65 06 18  
001848  1  28           
001849  1                  ; Marks the most recently referenced block (pointed to by PREV ) as altered.
001849  1                  ; The block will subsequently be transferred automatically to disc should its
001849  1                  ; buffer be required for storage of a different block.
001849  1                  ; https://forth-standard.org/standard/block/UPDATE
001849  1  D0 80 00     Update:	LDBL $8000	; set the hi bit of the block # in the PREV block
00184C  1  91 70 02     	LDAD VPrev
00184F  1  5C           	XAY
001850  1  9B           	LDAA YW
001851  1  53 20        	ORI AW,BW
001853  1  BB           	STAA YW
001854  1  09           	RSR
001855  1               
001855  1               
001855  1               	.if 0
001855  1                FHdr 'Save-Buffers',0 ; ( -- )  Transfer the contents of each UPDATEd block buffer to mass storage. Mark all buffers as unmodified.
001855  1                  ; https://forth-standard.org/standard/block/SAVE-BUFFERS
001855  1               Save_Buffers:
001855  1               	JSRD Abort ;???
001855  1               	.endif
001855  1               
001855  1               
001855  1  46 6C 75 73   FHdr 'Flush',0 ; ( -- )  Flush modified blocks back to disk
001859  1  68 05 18 49  
00185D  1                  ; https://forth-standard.org/standard/block/FLUSH
00185D  1  91 18 0E     Flush:	LDAD First+1		; for each available block buffer
001860  1  B5 A2        @2835:	STAX SW,ModBMRB,0
001862  1  90 7F FF     	LDAL $7FFF		;   alloc a buffer for block $7fff
001865  1  B5 82        	STAX ZW,ModBMRB,0	;     ( removing the existing contents )
001867  1  79 18 C1     	JSRD Buffer
00186A  1  30 81        	INR ZW,2		;   drop the addr
00186C  1  95 A1        	LDAX SW,ModBRPB,0	;  next available block buffer
00186E  1  D0 01 04     	LDBL SectorSize+4
001871  1  50 20        	ADD AW,BW
001873  1  D1 18 1C     	LDBD Limit+1
001876  1  59           	SAB
001877  1  11 E7        	BNL @2835
001879  1  09           	RSR			; return
00187A  1               
00187A  1               
00187A  1  45 6D 70 74   FHdr "Empty-Buffers",0 ; ( -- )  Mark all block-buffers as empty
00187E  1  79 2D 42 75  
001882  1  66 66 65 72  
001886  1  73 0D 18 5D  
00188A  1                  ; not necessarily affecting the contents.
00188A  1                  ; Updated blocks are not written to the disc.
00188A  1                  ; This is also an initialization procedure before first use of the disc.
00188A  1                  ; https://forth-standard.org/standard/block/EMPTY-BUFFERS
00188A  1               Empty_Buffers:
00188A  1  91 18 0E     	LDAD First+1		; init Use & Prev
00188D  1  B1 70 00     	STAD VUse
001890  1  B1 70 02     	STAD VPrev
001893  1               
001893  1  79 18 0D     	JSRD First	; zero all the disc buffer bytes, & return
001896  1  79 18 1B     	JSRD Limit
001899  1  79 02 CC     	JSRD Over
00189C  1  79 05 11     	JSRD Subtract
00189F  1  71 0C 8D     	JMPD Erase
0018A2  1               
0018A2  1               
0018A2  1  44 52 30 03  	FHdr 'DR0',0 ; ( -- )  select disc drive 0
0018A6  1  18 8A        
0018A8  1  3A           DR0:	CLA
0018A9  1  B1 70 7C     DRA:	STAD VOffset	; Offset=0
0018AC  1  09           	RSR		; return
0018AD  1               
0018AD  1               
0018AD  1  44 52 31 03  	FHdr 'DR1',0 ; ( -- )  select disc drive 1
0018B1  1  18 A8        
0018B3  1  90 03 20     DR1:	LDAL Sectors	; Offset=sectors	(sectors per drive)
0018B6  1  73 F1        	JMPR DRA
0018B8  1               
0018B8  1               
0018B8  1  42 75 66 66   FHdr 'Buffer',0 ; ( n -- addr )  Obtain the next memory buffer, assigning it to block n.
0018BC  1  65 72 06 18  
0018C0  1  B3           
0018C1  1                  ; If the contents of the buffer is marked as updated, it is written to the disk.
0018C1  1                  ; The block is not read from the disc.
0018C1  1                  ; The address left is the first cell within the buffer for data storage.
0018C1  1                  ; https://forth-standard.org/standard/block/BUFFER
0018C1  1  91 70 00     Buffer:	LDAD VUse
0018C4  1  B5 82        	STAX ZW,ModBMRB,0
0018C6  1  79 18 28     @2758:	JSRD PBuf
0018C9  1  95 81        	LDAX ZW,ModBRPB,0
0018CB  1  14 F9        	BZ @2758
0018CD  1               
0018CD  1  D1 70 00     	LDBD VUse		;modified?
0018D0  1  99           	LDAA BW
0018D1  1  17 10        	BP @2776
0018D3  1  30 21        	INR BW,2		;  write old buffer contents
0018D5  1  F5 82        	STBX ZW,ModBMRB,0
0018D7  1  D0 7F FF     	LDBL $7fff
0018DA  1  5A           	NAB
0018DB  1  F5 82        	STBX ZW,ModBMRB,0
0018DD  1  79 0A 50     	JSRD Zero
0018E0  1  79 1B 16     	JSRD RSlashW
0018E3  1               @2776:
0018E3  1               
0018E3  1  95 81        	LDAX ZW,ModBRPB,0	; save this block buffer address
0018E5  1  B1 70 00     	STAD VUse
0018E8  1  5C           	XAY
0018E9  1               
0018E9  1  D5 81        	LDBX ZW,ModBRPB,0	; store block #
0018EB  1  FB           	STBA YW
0018EC  1  D0 01 02     	LDBL 2+SectorSize	; insert terminating nulls
0018EF  1  58           	AAB
0018F0  1  3A           	CLA
0018F1  1  B9           	STAA BW
0018F2  1  55 60        	XFR AW,YW
0018F4  1  B1 70 02     	STAD VPrev
0018F7  1               
0018F7  1  38           	INA			; return data buffer addr
0018F8  1  38           	INA
0018F9  1  B5 82        	STAX ZW,ModBMRB,0
0018FB  1  09           	RSR
0018FC  1               
0018FC  1               
0018FC  1  42 6C 6F 63   FHdr 'Block',0 ; ( n -- addr )  Leave the memory address of the block buffer containing block n.
001900  1  6B 05 18 C1  
001904  1                  ; If the block
001904  1                  ; is not already in memory, it is transferred from disc to which ever buffer was
001904  1                  ; least recently written.  If the block occupying that buffer has been marked as
001904  1                  ; updated, it is rewritten to disc before block n is read into the buffer.
001904  1                  ; See also BUFFER, R/W UPDATE FLUSH
001904  1                  ; https://forth-standard.org/standard/block/BLOCK
001904  1  95 81        Block:	LDAX ZW,ModBRPB,0	; calc physical block #
001906  1  D1 70 7C     	LDBD VOffset
001909  1  58           	AAB
00190A  1  B5 A2        	STAX SW,ModBMRB,0
00190C  1               
00190C  1  91 70 02     	LDAD VPrev		; Start at VPrev
00190F  1  B5 81        	STAX ZW,ModBRPB,0
001911  1  9C           	LDAA ZW			; if not block match
001912  1  98           	LDAA AW
001913  1  DD           	LDBA SW
001914  1  54 20        	ORE AW,BW
001916  1  3D           	SLA
001917  1  14 31        	BZ @2830
001919  1               
001919  1               @2805:				;   begin
001919  1  79 18 28     	JSRD PBuf		;     step to next buffer
00191C  1  95 81        	LDAX ZW,ModBRPB,0	;     if it is VUse
00191E  1  15 1E        	BNZ @2818
001920  1  30 81        	INR ZW,2		;       drop
001922  1  79 03 A6     	JSRD RAt		;       allocate buffer
001925  1  79 18 C1     	JSRD Buffer
001928  1  79 02 E9     	JSRD Dup		;       read contents
00192B  1  79 03 A6     	JSRD RAt
00192E  1  79 0A 59     	JSRD One
001931  1  79 1B 16     	JSRD RSlashW
001934  1  DC           	LDBA ZW			;       point at header
001935  1  31 21        	DCR BW,2
001937  1  FC           	STBA ZW
001938  1  90 01 02     	LDAL 2+SectorSize	;       insert terminating nulls
00193B  1  58           	AAB
00193C  1  3A           	CLA
00193D  1  B9           	STAA BW
00193E  1               @2818:				;      then
00193E  1  9C           	LDAA ZW			;    until block match
00193F  1  98           	LDAA AW
001940  1  DD           	LDBA SW
001941  1  54 20        	ORE AW,BW
001943  1  3D           	SLA
001944  1  15 D3        	BNZ @2805
001946  1  9C           	LDAA ZW			;   set VPrev
001947  1  B1 70 02     	STAD VPrev
00194A  1               
00194A  1               @2830:				;  then
00194A  1  30 A1        	INR SW,2		; rdrop
00194C  1  71 04 B3     	JMPD TwoPlus		; point at data
00194F  1               
00194F  1               
00194F  1  28 4C 69 6E   FHdr '(Line)',0 ; ( n_line n_screen -- addr count )
001953  1  65 29 06 19  
001957  1  04           
001958  1                  ; Convert the line number n_line and the screen n_screen to the disc buffer address
001958  1                  ; containing the data.  A count of 64 indicates the full line text length.
001958  1  79 03 B9     PLine:	JSRD ToR		; save n_screen
00195B  1  79 0A 85     	JSRD CSlashL		; get chars per line
00195E  1  79 0A 93     	JSRD BBuf		; get bytes per disc buffer
001961  1  79 07 C1     	JSRD StarSlashMod	; convert n_line to disc block # & offset
001964  1  79 03 AF     	JSRD RFrom		; get n_screen
001967  1  79 0A A1     	JSRD BScr		; get disc blocks per screen
00196A  1  79 07 8B     	JSRD Star		; convert screen to disc blocks
00196D  1  79 04 D2     	JSRD Plus		; add screen blocks to line blocks
001970  1  7B 92        	JSRR Block		; read the disc block
001972  1  79 04 D2     	JSRD Plus		; add offset
001975  1  71 0A 85     	JMPD CSlashL		; get chars per line, & return
001978  1               
001978  1               
001978  1  2E 4C 69 6E   FHdr '.Line',0 ; ( n_line n_screen -- )
00197C  1  65 05 19 58  
001980  1               DotLine:
001980  1  79 19 58     	JSRD PLine
001983  1  79 08 8C     	JSRD DTrailing
001986  1  71 0D 16     	JMPD Type
001989  1               
001989  1               
001989  1  4D 65 73 73   FHdr 'Message',0 ; ( n -- )
00198D  1  61 67 65 07  
001991  1  19 80        
001993  1                  ; Print on the selected output device the text of line n relative to screen 4
001993  1                  ; of drive 0.  n may be positive or negative.  MESSAGE may be used to print
001993  1                  ; incidental text such as report headers.  If WARNING is zero, the message will
001993  1                  ; simply be printed as a number (disc unavailable).
001993  1               Message:
001993  1  9C           	LDAA ZW		; n=0 gives no message
001994  1  14 20        	BZ @2886
001996  1  D0 00 17     	LDBL @IndexCount ; built-in message?
001999  1  59           	SAB
00199A  1  11 2A        	BNL @Int
00199C  1  D1 70 6C     @Ext:	LDBD VWarning	; short messages?
00199F  1  14 18        	BZ @2888
0019A1  1  90 00 04     	LDAL 4		; messages start in block 4
0019A4  1  B5 82        	STAX ZW,ModBMRB,0
0019A6  1  91 70 7C     	LDAD VOffset
0019A9  1  B5 82        	STAX ZW,ModBMRB,0
0019AB  1  79 0A A1     	JSRD BScr
0019AE  1  79 07 A9     	JSRD Slash
0019B1  1  79 05 11     	JSRD Subtract
0019B4  1  73 CA        	JMPR DotLine	; type the line, & return
0019B6  1               
0019B6  1  30 81        @2886:	INR ZW,2	; drop n
0019B8  1  09           	RSR		; return
0019B9  1               
0019B9  1  79 14 2E     @2888:	JSRD PDotQuote	; type literal
0019BC  1  06 4D 73 67  	.byte 6,'Msg # '
0019C0  1  20 23 20     
0019C3  1  71 0E 57     	JMPD Dot	; type n, & return
0019C6  1               
0019C6  1               
0019C6  1               @Int:	; internal message text?
0019C6  1  D0 19 D9     	LDBL @Index	; get index
0019C9  1  58           	AAB
0019CA  1  3A           	CLA
0019CB  1  89           	LDABA BW
0019CC  1  14 CE        	BZ @Ext		; if we don't have one, try external
0019CE  1  D0 19 F0     	LDBL @Msg
0019D1  1  58           	AAB
0019D2  1  FC           	STBA ZW
0019D3  1  79 08 58     	JSRD Count
0019D6  1  71 0D 16     	JMPD Type
0019D9  1               
0019D9  1  00 01 0D 00  @Index:	.byte 0,@Msg1-@Msg,@Msg2-@Msg,0
0019DD  1  1D 00 2A 35  	.byte @Msg4-@Msg,0,@Msg6-@Msg,@Msg7-@Msg
0019E1  1  44 00 00 00  	.byte @Msg8-@Msg,0,0,0
0019E5  1  00 00 00 00  	.byte 0,0,0,0
0019E9  1  00 51 5E 6B  	.byte 0,@Msg17-@Msg,@Msg18-@Msg,@Msg19-@Msg
0019ED  1  83 9B B3     	.byte @Msg20-@Msg,@Msg21-@Msg,@Msg22-@Msg
0019F0  1               @IndexCount = *-@Index
0019F0  1               
0019F0  1  00           @Msg:	.byte 0
0019F1  1  0B 45 6D 70  @Msg1:	.byte 11,'Empty stack'
0019F5  1  74 79 20 73  
0019F9  1  74 61 63 6B  
0019FD  1  0F 44 69 63  @Msg2:	.byte 15,'Dictionary full'
001A01  1  74 69 6F 6E  
001A05  1  61 72 79 20  
001A09  1  66 75 6C 6C  
001A0D  1  0C 49 73 6E  @Msg4:	.byte 12,"Isn't unique"
001A11  1  27 74 20 75  
001A15  1  6E 69 71 75  
001A19  1  65           
001A1A  1  0A 44 69 73  @Msg6:	.byte 10,'Disc range'
001A1E  1  63 20 72 61  
001A22  1  6E 67 65     
001A25  1  0E 53 74 61  @Msg7:	.byte 14,"Stack overflow"
001A29  1  63 6B 20 6F  
001A2D  1  76 65 72 66  
001A31  1  6C 6F 77     
001A34  1  0C 44 69 73  @Msg8:	.byte 12,"Disk I/O err"
001A38  1  6B 20 49 2F  
001A3C  1  4F 20 65 72  
001A40  1  72           
001A41  1  0C 43 6F 6D  @Msg17:	.byte 12,'Compile only'
001A45  1  70 69 6C 65  
001A49  1  20 6F 6E 6C  
001A4D  1  79           
001A4E  1  0C 45 78 65  @Msg18:	.byte 12,'Execute only'
001A52  1  63 75 74 65  
001A56  1  20 6F 6E 6C  
001A5A  1  79           
001A5B  1  17 43 6F 6E  @Msg19:	.byte 23,'Conditionals not paired'
001A5F  1  64 69 74 69  
001A63  1  6F 6E 61 6C  
001A67  1  73 20 6E 6F  
001A6B  1  74 20 70 61  
001A6F  1  69 72 65 64  
001A73  1  17 44 65 66  @Msg20:	.byte 23,'Definition not finished'
001A77  1  69 6E 69 74  
001A7B  1  69 6F 6E 20  
001A7F  1  6E 6F 74 20  
001A83  1  66 69 6E 69  
001A87  1  73 68 65 64  
001A8B  1  17 49 6E 20  @Msg21:	.byte 23,'In protected dictionary'
001A8F  1  70 72 6F 74  
001A93  1  65 63 74 65  
001A97  1  64 20 64 69  
001A9B  1  63 74 69 6F  
001A9F  1  6E 61 72 79  
001AA3  1  15 55 73 65  @Msg22:	.byte 21,'Use only when loading'
001AA7  1  20 6F 6E 6C  
001AAB  1  79 20 77 68  
001AAF  1  65 6E 20 6C  
001AB3  1  6F 61 64 69  
001AB7  1  6E 67        
001AB9  1               
001AB9  1               
001AB9  1               MessageA: ; entry with n in A
001AB9  1  B5 82        	STAX ZW,ModBMRB,0
001ABB  1  71 19 93     	JMPD Message
001ABE  1               
001ABE  1               
001ABE  1               	.if 0
001ABE  1               
001ABE  1                FHdr 'Source',0 ; ( -- c-addr u )
001ABE  1                  ; c-addr is the address of, and u is the number of characters in, the input buffer.
001ABE  1                  ; https://forth-standard.org/standard/core/SOURCE
001ABE  1               	JSRD Abort ;???
001ABE  1               
001ABE  1               
001ABE  1                FHdr 'Source-Id',0 ; ( -- 0 | -1 )
001ABE  1                  ; Identifies the input source as follows:
001ABE  1                  ; SOURCE-ID	Input source
001ABE  1                  ;   -1	String (via EVALUATE)
001ABE  1                  ;    0	User input device
001ABE  1                  ; https://forth-standard.org/standard/core/SOURCE-ID
001ABE  1               	JSRD Abort ;???
001ABE  1               
001ABE  1               
001ABE  1                FHdr 'Restore-Input',0 ; ( xn ... x1 n -- flag )
001ABE  1                  ; Attempt to restore the input source specification to the state described by x1 through xn.
001ABE  1                  ; flag is true if the input source specification cannot be so restored.
001ABE  1                  ;
001ABE  1                  ; An ambiguous condition exists if the input source represented by the arguments is not the same as the current input source.
001ABE  1                  ; https://forth-standard.org/standard/core/RESTORE-INPUT
001ABE  1               	JSRD Abort ;???
001ABE  1               
001ABE  1               
001ABE  1                FHdr 'Save-Input',0 ; ( -- xn ... x1 n )
001ABE  1                  ; x1 through xn describe the current state of the input source specification for later use by RESTORE-INPUT.
001ABE  1                  ; https://forth-standard.org/standard/core/SAVE-INPUT
001ABE  1               	JSRD Abort ;???
001ABE  1               
001ABE  1               
001ABE  1                FHdr 'Evaluate',0 ; ( i * x c-addr u -- j * x )
001ABE  1                  ; https://forth-standard.org/standard/block/EVALUATE
001ABE  1                  ; https://forth-standard.org/standard/core/EVALUATE
001ABE  1               Evaluate:
001ABE  1               	JSRD Abort ;???
001ABE  1               
001ABE  1               	.endif
001ABE  1               
001ABE  1               
001ABE  1  4C 6F 61 64   FHdr 'Load',0 ; ( n -- )  Begin interpretation of screen n.
001AC2  1  04 19 93     
001AC5  1                  ; Loading will terminate at the end of the screen or at ;S .
001AC5  1                  ; See ;S -->
001AC5  1                  ; https://forth-standard.org/standard/block/LOAD
001AC5  1  91 70 74     Load:	LDAD VBlk	; save existing Blk & In
001AC8  1  B5 A2        	STAX SW,ModBMRB,0
001ACA  1  91 70 76     	LDAD VIn
001ACD  1  B5 A2        	STAX SW,ModBMRB,0
001ACF  1  3A           	CLA
001AD0  1  B1 70 76     	STAD VIn	; In=0
001AD3  1  79 0A A1     	JSRD BScr	; Blk=n*(blocks_per_screen)
001AD6  1  79 07 8B     	JSRD Star
001AD9  1  95 81        	LDAX ZW,ModBRPB,0
001ADB  1  B1 70 74     	STAD VBlk
001ADE  1               
001ADE  1  79 16 66     	JSRD Interpret	; interpret the disc block
001AE1  1               
001AE1  1  95 A1        	LDAX SW,ModBRPB,0 ; restore Blk & In
001AE3  1  B1 70 76     	STAD VIn
001AE6  1  95 A1        	LDAX SW,ModBRPB,0
001AE8  1  B1 70 74     	STAD VBlk
001AEB  1  09           	RSR		; return
001AEC  1               
001AEC  1               
001AEC  1  2D 2D 3E 43   FHdr '-->',ha_immediate ; ( -- )  Continue interpretation with the next disc screen.
001AF0  1  1A C5        
001AF2  1  79 0F B5     NextB:	JSRD QLoad	; verify that we're LOADing
001AF5  1  3A           	CLA
001AF6  1  B1 70 76     	STAD VIn	; offset in block =0
001AF9  1  79 0A A1     	JSRD BScr	; move Blk to start of next screen
001AFC  1  91 70 74     	LDAD VBlk
001AFF  1  B5 82        	STAX ZW,ModBMRB,0
001B01  1  79 02 CC     	JSRD Over
001B04  1  79 07 B4     	JSRD Mod
001B07  1  79 05 11     	JSRD Subtract
001B0A  1  79 0B 28     	JSRD Blk
001B0D  1  71 07 DD     	JMPD PlusStore
001B10  1               
001B10  1               
001B10  1               	.if 0
001B10  1                FHdr 'Thru',0 ; ( i * x u1 u2 -- j * x )
001B10  1                  ; LOAD the mass storage blocks numbered u1 through u2 in sequence.
001B10  1                  ; Other stack effects are due to the words LOADed.
001B10  1                  ; https://forth-standard.org/standard/block/THRU
001B10  1               Thru:	JSRD Abort ;???
001B10  1               	.endif
001B10  1               
001B10  1               
001B10  1               	.if 0
001B10  1                FHdr 'Include',0 ; ( "filename" -- )  Interpret text from the file
001B10  1               	JSRD Abort ; ???do something
001B10  1               	RSR
001B10  1               	.endif
001B10  1               
001B10  1               
001B10  1  52 2F 57 03   FHdr 'R/W',0 ; ( addr blk f -- )  The fig-FORTH standard disc read-write linkage.
001B14  1  1A F2        
001B16  1                  ; addr specifies the source or destination block buffer,
001B16  1                  ; blk is the sequential number of the referenced block;
001B16  1                  ; and f is a flag for f=0 write and f=1 read.
001B16  1                  ; R/W determines the location on mass storage, performs the read-write and
001B16  1                  ; performs any error checking.
001B16  1               RSlashW:
001B16  1  D1 70 5C     	LDBD RamDiskCount	; is the RAM disk initialized?
001B19  1  15 03        	BNZ @RD
001B1B  1               
001B1B  1               	; we have no disk yet!
001B1B  1  79 17 82     @Abort:	JSRD Abort
001B1E  1               
001B1E  1               @RD: ; Use RAM disk
001B1E  1  95 88 02     	LDAX ZW,ModNBRB,2	; block # in range?
001B21  1  59           	SAB
001B22  1  10 F7        	BL @Abort
001B24  1  35 07        	SLR AW,8		; cvt to bytes
001B26  1  D1 70 5A     	LDBD RamDiskStart
001B29  1  58           	AAB
001B2A  1  9C           	LDAA ZW			; get f
001B2B  1  14 0F        	BZ @RdWrite
001B2D  1               
001B2D  1               @RdRead:			; move from RAM disk to buffer
001B2D  1  95 88 04     	LDAX ZW,ModNBRB,4
001B30  1  F5 88 04     	STBX ZW,ModNBRB,4
001B33  1  B5 88 02     	STAX ZW,ModNBRB,2
001B36  1  90 01 00     @Rd2:	LDAL 256
001B39  1  71 0C 1E     	JMPD CMove
001B3C  1               
001B3C  1               @RdWrite:			; move from buffer to RAM disk
001B3C  1  F5 88 02     	STBX ZW,ModNBRB,2
001B3F  1  73 F5        	JMPR @Rd2
001B41  1               
001B41  1               
001B41  1  52 61 6D 44   FHdr 'RamDisk',0 ; ( n -- )  alloc n blocks of RAM disk, & init
001B45  1  69 73 6B 07  
001B49  1  1B 16        
001B4B  1  D1 70 70     	LDBD VDP		; remember where RAM disk starts
001B4E  1  F1 70 5A     	STBD RamDiskStart
001B51  1  9C           	LDAA ZW
001B52  1  F5 82        	STBX ZW,ModBMRB,0
001B54  1  B1 70 5C     	STAD RamDiskCount
001B57  1  35 07        	SLR AW,8
001B59  1  BC           	STAA ZW
001B5A  1  B5 82        	STAX ZW,ModBMRB,0
001B5C  1  79 0F C6     	JSRD Allot
001B5F  1  71 0C 8D     	JMPD Erase
001B62  1               
001B62  1               
001B62  1  46 6F 72 67   FHdr 'Forget',0 ; ( "name" -- )
001B66  1  65 74 06 1B  
001B6A  1  4B           
001B6B  1                  ; https://forth-standard.org/standard/tools/FORGET
001B6B  1                  ; Executed in the form:
001B6B  1                  ;	FORGET cccc
001B6B  1                  ; Deletes definition named cccc from the dictionary with all entries
001B6B  1                  ; physically following it.  In fig-FORTH, an error message will occur
001B6B  1                  ; if the CURRENT and CONTEXT vocabularies are not currently the same.
001B6B  1  79 15 35     Forget:	JSRD Tick		; get "name" text & look up in dictionary
001B6E  1  9C           	LDAA ZW			; check Fence (assumes startup image is below user dictionary space)
001B6F  1  D1 70 6E     	LDBD VFence
001B72  1  59           	SAB
001B73  1  10 06        	BL @3
001B75  1  D0 00 15     	LDBL Err_InProtectedDictionary
001B78  1  79 0F 5F     	JSRD ErrorY
001B7B  1               @3:
001B7B  1               
001B7B  1  9C           @3220:	LDAA ZW			; while addr < latest vocabulary word
001B7C  1  D1 70 72     	LDBD VVoc_Link
001B7F  1  59           	SAB
001B80  1  10 0F        	BL @3225
001B82  1  79 16 F5     	JSRD Forth
001B85  1  79 17 0A     	JSRD Definitions
001B88  1  91 70 72     	LDAD VVoc_Link		;   unlink
001B8B  1  98           	LDAA AW
001B8C  1  B1 70 72     	STAD VVoc_Link
001B8F  1  73 EA        	JMPR @3220
001B91  1               @3225:
001B91  1               
001B91  1  95 81        	LDAX ZW,ModBRPB,0	; pop forgotten word ptr
001B93  1  5C           	XAY
001B94  1  31 62        	DCR YW,3		; point at flags & length byte
001B96  1               
001B96  1  3A           	CLA
001B97  1  8B           	LDABA YW		; fix VDP
001B98  1  C0 1F        	LDBBL ha_length
001B9A  1  5A           	NAB
001B9B  1               ;	cmp VWidth		;   name truncated?
001B9B  1               
001B9B  1  51 62        	SUB BW,YW
001B9D  1  31 20        	DCR BW,1		;  -1 for junk name length count
001B9F  1  F1 70 70     	STBD VDP
001BA2  1               
001BA2  1  95 68 01     	LDAX YW,ModNBRB,1	; fix dictionary
001BA5  1  D1 70 72     	LDBD VVoc_Link
001BA8  1  B5 28 FE     	STAX BW,ModNBRB,$fe
001BAB  1               
001BAB  1  09           	RSR
001BAC  1               
001BAC  1               
001BAC  1               	.if 0
001BAC  1                FHdr 'Marker',0 ; ( "<spaces>name" -- )
001BAC  1                  ;   Skip leading space delimiters. Parse name delimited by a spac'e.
001BAC  1                  ;   Create a definition for name with the execution semantics defined below.
001BAC  1                  ; name Execution:
001BAC  1                  ;   ( -- )
001BAC  1                  ;   Restore all dictionary allocation and search order pointers to the state they had just prior to the definition of name.
001BAC  1                  ;   Remove the definition of name and all subsequent definitions. Restoration of any structures still existing that could refer to deleted definitions or deallocated data space is not necessarily provided. No other contextual information such as numeric base is affected.
001BAC  1               Marker:	JSRD Abort ;???
001BAC  1               	.endif
001BAC  1               
001BAC  1               
001BAC  1               	.if 0
001BAC  1                FHdr 'TraverseE-WordList',0 ; ( i * x xt wid -- j * x )
001BAC  1                  ; Remove wid and xt from the stack. Execute xt once for every word in the wordlist wid, passing the name token nt of the word to xt,
001BAC  1                  ; until the wordlist is exhausted or until xt returns false.
001BAC  1                  ;
001BAC  1                  ; The invoked xt has the stack effect ( k * x nt -- l * x flag ).
001BAC  1                  ;
001BAC  1                  ; If flag is true, TRAVERSE-WORDLIST will continue with the next name, otherwise it will return.
001BAC  1                  ; TRAVERSE-WORDLIST does not put any items other than nt on the stack when calling xt,
001BAC  1                  ; so that xt can access and modify the rest of the stack.
001BAC  1                  ;
001BAC  1                  ; TRAVERSE-WORDLIST may visit words in any order, with one exception: words with the same name are called in the order
001BAC  1                  ; newest-to-oldest (possibly with other words in between).
001BAC  1                  ;
001BAC  1                  ; An ambiguous condition exists if words are added to or deleted from the wordlist wid during the execution of TRAVERSE-WORDLIST.
001BAC  1                  ; https://forth-standard.org/standard/tools/TRAVERSE-WORDLIST
001BAC  1               Traverse_WordList:
001BAC  1               	JSRD Abort ;???
001BAC  1               	.endif
001BAC  1               
001BAC  1               
001BAC  1  4C 69 73 74   FHdr 'List',0 ; ( n -- )  Display the ASCII text of screen n on the selected output device.
001BB0  1  04 1B 6B     
001BB3  1                  ; SCR contains the screen number during and after this process.
001BB3  1                  ; https://forth-standard.org/standard/block/LIST
001BB3  1  79 0D 3F     List:	JSRD Decimal	; Base=decimal
001BB6  1  79 0C E1     	JSRD CR		; newline
001BB9  1  9C           	LDAA ZW		; Scr=n
001BBA  1  B1 70 7A     	STAD VScr
001BBD  1  79 14 2E     	JSRD PDotQuote	; type literal
001BC0  1  06 53 43 52  	.byte 6,'SCR # '
001BC4  1  20 23 20     
001BC7  1  79 0E 57     	JSRD Dot	; type n
001BCA  1  3A           	CLA		; for line=0 to 16
001BCB  1  B5 A2        @3620:	STAX SW,ModBMRB,0 ;   save line#
001BCD  1  79 0C E1     	JSRD CR		;   newline
001BD0  1  79 03 A6     	JSRD RAt	;   type current line# in 3 chars
001BD3  1  79 0A 6D     	JSRD Three
001BD6  1  79 0E 2E     	JSRD DotR
001BD9  1  79 0C F6     	JSRD Space	;   type a space
001BDC  1  79 03 A6     	JSRD RAt	;   type the line
001BDF  1  91 70 7A     	LDAD VScr
001BE2  1  B5 82        	STAX ZW,ModBMRB,0
001BE4  1  79 19 80     	JSRD DotLine
001BE7  1  95 A1        	LDAX SW,ModBRPB,0 ;  next line
001BE9  1  38           	INA
001BEA  1  C0 10        	LDBBL 16
001BEC  1  49           	SABB
001BED  1  15 DC        	BNZ @3620
001BEF  1  71 0C E1     	JMPD CR		; newline, & return
001BF2  1               
001BF2  1               
001BF2  1  49 6E 64 65   FHdr 'Index',0 ; ( from to -- )  Print the first line of each screen over the range from, to.
001BF6  1  78 05 1B B3  
001BFA  1                  ; This is used to view the comment lines of an area on disc screens.
001BFA  1  79 0C E1     Index:	JSRD CR		; newline
001BFD  1  9C           	LDAA ZW		; to++
001BFE  1  38           	INA
001BFF  1  BC           	STAA ZW
001C00  1               @3647:			; for screen#=from to to
001C00  1  79 0C E1     	JSRD CR		;   newline
001C03  1  79 02 CC     	JSRD Over	;   type screen# in 3 chars
001C06  1  79 0A 6D     	JSRD Three
001C09  1  79 0E 2E     	JSRD DotR
001C0C  1  79 0C F6     	JSRD Space	;   type space
001C0F  1  79 0A 50     	JSRD Zero	;   type 1st line of screen
001C12  1  79 02 CC     	JSRD Over
001C15  1  79 19 80     	JSRD DotLine
001C18  1  79 0C B6     	JSRD QTerminalA	;   console key available?
001C1B  1  15 0B        	BNZ @break
001C1D  1  95 88 02     	LDAX ZW,ModNBRB,2 ;  next
001C20  1  38           	INA
001C21  1  B5 88 02     	STAX ZW,ModNBRB,2
001C24  1  DC           	LDBA ZW
001C25  1  59           	SAB
001C26  1  10 D8        	BL @3647
001C28  1  30 83        @break:	INR ZW,4	; drop parameters
001C2A  1  80 0C        	LDABL $0C	; form feed for printer, & return
001C2C  1  71 0C CC     	JMPD EmitA
001C2F  1               
001C2F  1               
001C2F  1  54 72 69 61   FHdr 'Triad',0 ; ( scr -- )
001C33  1  64 05 1B FA  
001C37  1                  ; Display on the selected output device the three screens which include that numbered
001C37  1                  ; scr, beginning with a screen evenly divisable by 3.  Output is suitable for source text
001C37  1                  ; records, and includes a reference line at the bottom taken from line 15 of screen 4.
001C37  1  79 0A 6D     Triad:	JSRD Three	; floor scr to multiple of 3
001C3A  1  79 07 A9     	JSRD Slash
001C3D  1  79 0A 6D     	JSRD Three
001C40  1  79 07 8B     	JSRD Star
001C43  1  79 0A 6D     	JSRD Three	; end=scr+3
001C46  1  79 02 CC     	JSRD Over
001C49  1  79 04 D2     	JSRD Plus
001C4C  1  79 02 A1     	JSRD Swap
001C4F  1  79 12 21     	JSRD PDo		; (Do)
001C52  1               @3681:
001C52  1  79 0C E1     	JSRD CR		;   newline
001C55  1  79 12 35     	JSRD I		;   type screen I
001C58  1  79 1B B3     	JSRD List
001C5B  1  79 12 5B     	JSRD PLoop	;  (Loop)
001C5E  1  16 F2        	BM @3681
001C60  1  79 0C E1     	JSRD CR		; newline
001C63  1  90 00 0F     	LDAL Err_TriadFooter ; type message $F
001C66  1  79 1A B9     	JSRD MessageA
001C69  1  79 0C E1     	JSRD CR		; newline
001C6C  1  80 0C        	LDABL $0C	; form feed for printer, & return
001C6E  1  71 0C CC     	JMPD EmitA
001C71  1               
001C71  1               
001C71  1               	.if 0
001C71  1               
001C71  1                FHdr 'Parse-Name',0 ; ( "<spaces>name<space>" -- c-addr u )
001C71  1                  ; Skip leading space delimiters. Parse name delimited by a space.
001C71  1                  ;
001C71  1                  ; c-addr is the address of the selected string within the input buffer and u is its length in characters.
001C71  1                  ; If the parse area is empty or contains only white space, the resulting string has length zero.
001C71  1                  ; https://forth-standard.org/standard/core/PARSE-NAME
001C71  1               
001C71  1               
001C71  1                FHdr 'Parse',0 ; ( char "ccc<char>" -- c-addr u )  Parse ccc delimited by the delimiter char.
001C71  1                  ;
001C71  1                  ; c-addr is the address (within the input buffer) and u is the length of the parsed string.
001C71  1                  ; If the parse area was empty, the resulting string has a zero length.
001C71  1                  ; https://forth-standard.org/standard/core/PARSE
001C71  1               
001C71  1               	.endif
001C71  1               
001C71  1               
001C71  1  56 4C 69 73   FHdr 'VList',0 ; ( -- )  FIG alias
001C75  1  74 05 1C 37  
001C79  1  73 08        	JMPR Words
001C7B  1               
001C7B  1               
001C7B  1  57 6F 72 64   FHdr 'Words',0 ; ( -- )  List the names of the definitions in the context vocabulary.
001C7F  1  73 05 1C 79  
001C83  1                  ; https://forth-standard.org/standard/tools/WORDS
001C83  1  92 70 7E     Words:	LDAI VContext	; start at head of dictionary in Context vocabulary
001C86  1  B5 82        	STAX ZW,ModBMRB,0
001C88  1  73 09        	JMPR @3710
001C8A  1               
001C8A  1  91 70 78     @3706:	LDAD VOut	; out of screen width?
001C8D  1  D1 0A 86     	LDBD CSlashL+1
001C90  1  59           	SAB
001C91  1  11 07        	BNL @3716
001C93  1  79 0C E1     @3710:	JSRD CR		;   newline
001C96  1  3A           	CLA
001C97  1  B1 70 78     	STAD VOut	;   Out=0
001C9A  1               @3716:
001C9A  1  79 02 E9     	JSRD Dup	; type name
001C9D  1  79 15 A1     	JSRD IdDot
001CA0  1  79 0C F6     	JSRD Space	; type space
001CA3  1  79 0C B6     	JSRD QTerminalA	; terminal input char?
001CA6  1  15 07        	BNZ @9
001CA8  1  9C           	LDAA ZW		; goto next dictionary entry
001CA9  1  95 08 FE     	LDAX AW,ModNBRB,$fe
001CAC  1  BC           	STAA ZW
001CAD  1  15 DB        	BNZ @3706	; end of dictionary?
001CAF  1  30 81        @9:	INR ZW,2	; drop addr
001CB1  1  09           	RSR		; return
001CB2  1               
001CB2  1               
001CB2  1  42 79 65 03  	FHdr 'Bye',0 ; ( - )  Exit to the system monitor, leaving a re-entry to Forth, if possible.
001CB6  1  1C 83        
001CB8  1                  ; https://forth-standard.org/standard/tools/BYE
001CB8  1               Bye:
001CB8  1  00           	HLT		; stop the simulator
001CB9  1  09           	RSR		; return
001CBA  1               
001CBA  1               
001CBA  1               ;----------------------------------------------------------------------
001CBA  1               ; Additional words
001CBA  1               
001CBA  1               
001CBA  1  2E 53 02 1C   FHdr '.S',0 ; ( ... -- ... ) non-destructive param stack print
001CBE  1  B8           
001CBF  1                  ; https://forth-standard.org/standard/tools/DotS
001CBF  1  91 70 64     DotS:	LDAD VS0		;start at top-of-stack
001CC2  1  73 0B        	JMPR @8
001CC4  1               
001CC4  1  D5 02        @1:	LDBX AW,ModBMRB,0	; get next cell value
001CC6  1  B5 A2        	STAX SW,ModBMRB,0	; save ptr
001CC8  1  F5 82        	STBX ZW,ModBMRB,0	; print value
001CCA  1  79 0E 57     	JSRD Dot
001CCD  1  95 A1        	LDAX SW,ModBRPB,0	; restore ptr
001CCF  1  55 82        @8:	XFR BW,ZW		; done?
001CD1  1  59           	SAB
001CD2  1  15 F0        	BNZ @1
001CD4  1               
001CD4  1  09           	RSR
001CD5  1               
001CD5  1               
001CD5  1               ; FHdr 'EX1',0 ; ( n -- )  type 1 hex digit
001CD5  1  95 81        EX1:	LDAX ZW,ModBRPB,0	; pop n
001CD7  1  D0 00 0F     EX1A:	LDBL $f			; get lo 4 bits
001CDA  1  52 20        	ANDC AW,BW
001CDC  1  C0 0A        	LDBBL 10		; convert to ASCII char
001CDE  1  49           	SABB
001CDF  1  11 04        	BNL @3
001CE1  1  C0 07        	LDBBL 7
001CE3  1  40 31        	ADDB AL,BL
001CE5  1  C0 30        @3:	LDBBL '0'
001CE7  1  40 31        	ADDB AL,BL
001CE9  1  71 0C CC     	JMPD EmitA		; type, & return
001CEC  1               
001CEC  1               
001CEC  1  45 58 32 03   FHdr 'EX2',0 ; ( n -- )  type 2 hex digits
001CF0  1  1C BF        
001CF2  1  95 81        EX2:	LDAX ZW,ModBRPB,0
001CF4  1  B5 82        EX2A:	STAX ZW,ModBMRB,0
001CF6  1  34 03        	SRR AW,4
001CF8  1  7B DD        	JSRR EX1A
001CFA  1  73 D9        	JMPR EX1
001CFC  1               
001CFC  1               
001CFC  1  45 58 34 03   FHdr 'EX4',0 ; ( n -- ) type 4 hex digits
001D00  1  1C F2        
001D02  1  8C           EX4:	LDABA ZW		; type hi byte
001D03  1  7B EF        	JSRR EX2A
001D05  1  73 EB        	JMPR EX2		; type lo byte, & return
001D07  1               
001D07  1  B5 82        EX4A:	STAX ZW,ModBMRB,0
001D09  1  73 F7        	JMPR EX4
001D0B  1               
001D0B  1               
001D0B  1  45 58 38 03   FHdr 'EX8',0 ; ( d -- ) type 8 hex digits
001D0F  1  1D 02        
001D11  1  7B EF        EX8:	JSRR EX4		; type hi word
001D13  1  73 ED        	JMPR EX4		; type lo word, & return
001D15  1               
001D15  1               
001D15  1  44 75 6D 70   FHdr 'Dump',0 ; ( adr len -- )  Dump memory range
001D19  1  04 1D 11     
001D1C  1                  ; https://forth-standard.org/standard/tools/DUMP
001D1C  1               Dump:
001D1C  1               @11:				; begin
001D1C  1  79 0C E1     	JSRD CR			;   newline
001D1F  1  79 02 CC     	JSRD Over		;   type addr
001D22  1  7B DE        	JSRR EX4
001D24  1  C0 10        	LDBBL 16		;   for each byte in line
001D26  1  E5 A2        @21:	STBBX SW,ModBMRB,0
001D28  1  79 0C F6     	JSRD Space
001D2B  1  D5 88 02     	LDBX ZW,ModNBRB,2	;     get byte
001D2E  1  85 21        	LDABX BW,ModBRPB,0
001D30  1  F5 88 02     	STBX ZW,ModNBRB,2
001D33  1  7B BF        	JSRR EX2A		;     type byte
001D35  1  C5 A1        	LDBBX SW,ModBRPB,0
001D37  1  9C           	LDAA ZW			;     decrement len
001D38  1  39           	DCA
001D39  1  BC           	STAA ZW
001D3A  1  14 06        	BZ @end
001D3C  1  21 30        	DCRB BL			;    next byte in line
001D3E  1  15 E6        	BNZ @21
001D40  1  73 DA        	JMPR @11		;  next line
001D42  1               
001D42  1  30 83        @end:	INR ZW,4		; drop len & adr
001D44  1  71 0C F6     	JMPD Space
001D47  1               
001D47  1               
001D47  1  53 65 65 4C   FHdr 'SeeLatest',0 ; ( -- )  dump latest word's code
001D4B  1  61 74 65 73  
001D4F  1  74 09 1D 1C  
001D53  1               SeeLatest:
001D53  1  D2 70 80     	LDBI VCurrent		; start of last word
001D56  1  F5 82        	STBX ZW,ModBMRB,0
001D58  1  91 70 70     	LDAD VDP		; length
001D5B  1  59           	SAB
001D5C  1  F5 82        	STBX ZW,ModBMRB,0
001D5E  1  73 BC        	JMPR Dump		; dump, & return
001D60  1               
001D60  1               
001D60  1               ; FHdr 'CC@',0 ; ( -- ud )  Get emulator cycle counter
001D60  1               ;CCAt:	cop?? $f5	; get simulator cycle count in BA
001D60  1               ;	STAX ZW,ModBMRB,0 ; push it
001D60  1               ;	STBX ZW,ModBMRB,0
001D60  1               ;	RSR
001D60  1               
001D60  1               
001D60  1               
001D60  1               	.if 0
001D60  1                FHdr 'Modify',0 ; ( adr -- )  \ Centurion TOS-like memory modify
001D60  1               	JSRD Abort
001D60  1               @l:
001D60  1               	JSRD Space
001D60  1               	LDABX ZW,ModABRB,0	; type existing value
001D60  1               	JSRD EX2A
001D60  1               
001D60  1               	CLR ZW,0    ; get the byte
001D60  1               	JSRR @HKey
001D60  1               	BL @9
001D60  1               	JSRR @HKey
001D60  1               	BL @9
001D60  1               
001D60  1               
001D60  1               
001D60  1               
001D60  1               
001D60  1               
001D60  1               
001D60  1               
001D60  1               @HKey:	PUSH YW,2
001D60  1               	JSRD KeyA
001D60  1               	POP YW,2
001D60  1               	LDBBL 'A'		; alpha?
001D60  1               	SABB
001D60  1               	BNL @HKNum
001D60  1               	LDABL $5f		; uppercase
001D60  1               	NABB
001D60  1               	LDABL 10
001D60  1               	ADDB AL,BL
001D60  1               	LDBBL 16
001D60  1               	SABB
001D60  1               	BNL @HKOK
001D60  1               @HKErr:	SL
001D60  1               	RSR
001D60  1               
001D60  1               @HKOK:	SHL YW,4
001D60  1               	ORIB YL,BL
001D60  1               	RL
001D60  1               	RSR
001D60  1               
001D60  1               @HkNum:	LDBBL '0'
001D60  1               	SABB
001D60  1               	BNL @HKErr
001D60  1               	XFRB AL,BL
001D60  1               	LDABL 10
001D60  1               	SABB
001D60  1               	BNL @HKOK
001D60  1               	JMPR @HKErr
001D60  1               
001D60  1               	.endif
001D60  1               
001D60  1               ;-----------------------------------------------------------------------------
001D60  1               ; CCDP interface
001D60  1               ; https://github.com/tergav17/CCDP
001D60  1               
001D60  1               ; status
001D60  1               ;	0: Successful, 0 bytes returned
001D60  1               ;	1: Successful, 16 bytes returned
001D60  1               ;	2: Successful, 256 bytes returned
001D60  1               ;	254: Execution Failure, 0 bytes returned
001D60  1               ;	255: Communication Failure, 0 bytes returned
001D60  1               
001D60  1               combuf		= $1C0  ; command line text
001D60  1               
001D60  1  53 79 73 5F   FHdr 'Sys_Done',0 ; ( -- )  Returns to the CCDP command prompt
001D64  1  44 6F 6E 65  
001D68  1  08 1D 53     
001D6B  1  71 01 00     	JMPD $100	; return to CCDP (also just RSR)
001D6E  1               
001D6E  1  54 74 79 5F   FHdr 'Tty_PutC',0 ; ( c -- )  Puts a character on the terminal
001D72  1  50 75 74 43  
001D76  1  08 1D 6B     
001D79  1               Tty_PutC:
001D79  1  D5 81        	LDBX ZW,ModBRPB,0	; pop c
001D7B  1               Tty_PutC_A:
001D7B  1  71 01 03     	JMPD $103
001D7E  1               
001D7E  1  54 74 79 5F   FHdr 'Tty_PutB',0 ; ( n -- )  Puts a byte in hex on the terminal
001D82  1  50 75 74 42  
001D86  1  08 1D 79     
001D89  1               Tty_PutB:
001D89  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n
001D8B  1  71 01 06     	JMPD $106
001D8E  1               
001D8E  1  54 74 79 5F   FHdr 'Tty_PutW',0 ; ( n -- )  Puts a word in hex on the terminal
001D92  1  50 75 74 57  
001D96  1  08 1D 89     
001D99  1               Tty_PutW:
001D99  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n
001D9B  1  71 01 09     	JMPD $109
001D9E  1               
001D9E  1  54 74 79 5F   FHdr 'Tty_PutS',0 ; ( adr -- )  Puts a string on the terminal (zero terminated)
001DA2  1  50 75 74 53  
001DA6  1  08 1D 99     
001DA9  1               Tty_PutS:
001DA9  1  D5 81        	LDBX ZW,ModBRPB,0	; pop adr
001DAB  1  71 01 0C     	JMPD $10C	; type .asciz string pointed to by BW
001DAE  1               
001DAE  1  54 74 79 5F   FHdr 'Tty_GetC',0 ; ( -- c )  Gets a character from the terminal
001DB2  1  47 65 74 43  
001DB6  1  08 1D A9     
001DB9  1               Tty_GetC_A = $10f
001DB9  1               Tty_GetC:
001DB9  1  79 01 0F     	JSRD Tty_GetC_A
001DBC  1  22 00        TtPs1:	CLRB AH
001DBE  1  B5 82        	STAX ZW,ModBMRB,0	; push c
001DC0  1  09           	RSR
001DC1  1               
001DC1  1  54 74 79 5F   FHdr 'Tty_GetS',0 ; ( adr len -- )  Gets a line of characters from the terminal
001DC5  1  47 65 74 53  
001DC9  1  08 1D B9     
001DCC  1               Tty_GetS:
001DCC  1  95 81        	LDAX ZW,ModBRPB,0	; pop len
001DCE  1  39           	DCA
001DCF  1  D5 81        	LDBX ZW,ModBRPB,0	; pop adr
001DD1  1  71 01 12     	JMPD $112
001DD4  1               
001DD4  1  54 74 79 5F   FHdr 'Tty_Next',0 ; ( -- f )  Is there is a character to read?
001DD8  1  4E 65 78 74  
001DDC  1  08 1D CC     
001DDF  1               Tty_Next_A = $12d
001DDF  1               Tty_Next:
001DDF  1  79 01 2D     	JSRD Tty_Next_A
001DE2  1  73 D8        	JMPR TtPs1		; push f
001DE4  1               
001DE4  1  46 73 5F 4F   FHdr 'Fs_Open',0 ; ( fn_addr -- status )  Opens up a file for use, any currently opened file is closed
001DE8  1  70 65 6E 07  
001DEC  1  1D DF        
001DEE  1               Fs_Open:
001DEE  1  DC           	LDBA ZW			; get fn_addr
001DEF  1  79 01 15     	JSRD $115
001DF2  1  73 54        	JMPR FsSt1		; store status
001DF4  1               
001DF4  1  46 73 5F 43   FHdr 'Fs_Close',0 ; ( -- status )
001DF8  1  6C 6F 73 65  
001DFC  1  08 1D EE     
001DFF  1               Fs_Close:
001DFF  1  79 01 18     	JSRD $118
001E02  1  73 B8        	JMPR TtPs1		; push status
001E04  1               
001E04  1  46 73 5F 4D   FHdr 'Fs_Make',0 ; ( fn_addr -- status )  Makes a new file, but does not open it
001E08  1  61 6B 65 07  
001E0C  1  1D FF        
001E0E  1               Fs_Make:
001E0E  1  DC           	LDBA ZW			; get fn_addr
001E0F  1  79 01 1B     	JSRD $11B
001E12  1  73 34        	JMPR FsSt1		; store status
001E14  1               
001E14  1  46 73 5F 44   FHdr 'Fs_Delete',0 ; ( fn_addr -- status )  Deletes an existing file
001E18  1  65 6C 65 74  
001E1C  1  65 09 1E 0E  
001E20  1               Fs_Delete:
001E20  1  DC           	LDBA ZW			; get fn_addr
001E21  1  79 01 1E     	JSRD $11E
001E24  1  73 22        	JMPR FsSt1		; store status
001E26  1               
001E26  1  46 73 5F 4C   FHdr 'Fs_List',0 ; ( n_entry buf_addr -- status )  Lists a filename and size from the directory
001E2A  1  69 73 74 07  
001E2E  1  1E 20        
001E30  1               Fs_List:
001E30  1  D5 81        	LDBX ZW,ModBRPB,0	; pop buf_adddr
001E32  1  9C           	LDAA ZW			; get n_entry
001E33  1  79 01 21     	JSRD $121
001E36  1  73 10        	JMPR FsSt1		; store status
001E38  1               
001E38  1  46 73 5F 52   FHdr 'Fs_Read',0 ; ( buf_addr block -- status )  Reads a block from a file
001E3C  1  65 61 64 07  
001E40  1  1E 30        
001E42  1               Fs_Read:
001E42  1  95 81        	LDAX ZW,ModBRPB,0	; pop block
001E44  1  DC           	LDBA ZW			; get buf_addr
001E45  1  79 01 24     	JSRD $124
001E48  1  22 00        FsSt1:	CLRB AH			; store status
001E4A  1  BC           	STAA ZW
001E4B  1  09           	RSR
001E4C  1               
001E4C  1  46 73 5F 57   FHdr 'Fs_Write',0 ; ( buf_addr block -- status )  Writes a block to a file
001E50  1  72 69 74 65  
001E54  1  08 1E 42     
001E57  1               Fs_Write:
001E57  1  95 81        	LDAX ZW,ModBRPB,0	; pop block
001E59  1  DC           	LDBA ZW			; get buf_addr
001E5A  1  79 01 27     	JSRD $127
001E5D  1  73 E9        	JMPR FsSt1
001E5F  1               
001E5F  1  47 65 6E 5F   FHdr 'Gen_HToL',0 ; ( ascii -- u )  Converts a hex number in ASCII into a value
001E63  1  48 54 6F 4C  
001E67  1  08 1E 57     
001E6A  1               Gen_HToL:
001E6A  1  DC           	LDBA ZW		; get ascii
001E6B  1  79 01 2A     	JSRD $12A
001E6E  1  73 D8        	JMPR FsSt1	; store u
001E70  1               
001E70  1               ;-----------------------------------------------------------------------------
001E70  1               ; Assembler & disassembler
001E70  1               
001E70  1               
001E70  1  53 79 6D 03   FHdr 'Sym',0 ; ( adr -- )  Type symbolic version of any adr
001E74  1  1E 6A        
001E76  1  95 81        Sym:	LDAX ZW,ModBRPB,0
001E78  1  B5 A2        SymA:	STAX SW,ModBMRB,0
001E7A  1  31 AB        	DCR SW,@adr		; alloc work area
001E7C  1               @adr	 = 12 ; adr to convert
001E7C  1               @voc	 = 10 ;	adr of vocabulary
001E7C  1               @cur	 =  8 ; adr of current word (nfa, cfa)
001E7C  1               @off	 =  6 ; offset this time
001E7C  1               @bestadr =  4 ; adr of best word (nfa, cfa)
001E7C  1               @bestoff =  2 ; offset from best word
001E7C  1               @type	 =  0 ; type of word
001E7C  1               
001E7C  1  90 FF FF     	LDAL .loword(-1)
001E7F  1  B5 A8 02     	STAX SW,ModNBRB,@bestoff
001E82  1               
001E82  1  91 70 72     	LDAD VVoc_Link		;for each vocabulary
001E85  1  B5 A8 0A     @71:	STAX SW,ModNBRB,@voc
001E88  1               
001E88  1  95 08 FE     	LDAX AW,ModNBRB,$fe	;  for each word in the vocabulary
001E8B  1  B5 A8 08     @01:	STAX SW,ModNBRB,@cur
001E8E  1  14 25        	BZ @09
001E90  1  5C           	XAY
001E91  1               
001E91  1  D5 A8 0C     	LDBX SW,ModNBRB,@adr	;    check current word
001E94  1  55 60        	XFR AW,YW
001E96  1  51 20        	SUB AW,BW
001E98  1  D5 A8 02     	LDBX SW,ModNBRB,@bestoff
001E9B  1  59           	SAB
001E9C  1  10 0C        	BL @04
001E9E  1  B5 A8 02     	STAX SW,ModNBRB,@bestoff
001EA1  1  55 62        	XFR BW,YW
001EA3  1  F5 A8 04     	STBX SW,ModNBRB,@bestadr
001EA6  1  3A           	CLA
001EA7  1  B5 A8 00     	STAX SW,ModNBRB,@type
001EAA  1               @04:
001EAA  1               
001EAA  1               ;	LDABA YW		;  a special kind of word?
001EAA  1               ;	LDBBL $79		;    (jsrd)
001EAA  1               ;	SABB
001EAA  1               ;	BZ @21
001EAA  1               ;	LDBBL $90		;    (ldal)
001EAA  1               ;	SABB
001EAA  1               ;	BNZ @06
001EAA  1               
001EAA  1               ;	LDAX YW,ModNBRB,3	;  a literal?
001EAA  1               ;	HLT ;LDBL $??		;    STAX ZW,ModBMRB,0
001EAA  1               ;	BNZ @06
001EAA  1               ;	LDABX YW,ModNBRB,5
001EAA  1               ;	LDBBL $09		;    RSR
001EAA  1               ;	SABB
001EAA  1               ;	BNZ @06
001EAA  1               ; HLT ;??	lda @adr		;    check literal value
001EAA  1               ;	sec
001EAA  1               ;	sbc a:1,y
001EAA  1               ;	sec
001EAA  1               ;	bra @27
001EAA  1               
001EAA  1               ;@21:	rep #pm			;  a variable?
001EAA  1               ;	lda a:1,y
001EAA  1               ;	cmp #PCreate
001EAA  1               ;	bne @06
001EAA  1               ;	lda @adr
001EAA  1               ;	sec
001EAA  1               ;	sbc @cur
001EAA  1               ;	dec a
001EAA  1               ;	dec a
001EAA  1               ;	dec a
001EAA  1               
001EAA  1               ;@27:	cmp @bestoff
001EAA  1               ;	bcs @06
001EAA  1               ;	sta @bestoff
001EAA  1               ;	sty @bestadr
001EAA  1               ;	lda #$8000
001EAA  1               ;	sta @type
001EAA  1               
001EAA  1  95 68 FE     @06:	LDAX YW,ModNBRB,$fe	;  next word
001EAD  1  15 DC        	BNZ @01
001EAF  1  D5 A8 0A     	LDBX SW,ModNBRB,@voc	; next vocabulary
001EB2  1  99           	LDAA BW
001EB3  1  15 D0        	BNZ @71
001EB5  1               @09:
001EB5  1               ;-------------------
001EB5  1  95 A8 02     	LDAX SW,ModNBRB,@bestoff
001EB8  1  45 00        	XFRB AH,AH
001EBA  1  15 24        	BNZ @69
001EBC  1               
001EBC  1  79 14 2E     	JSRD PDotQuote
001EBF  1  03 20 7B 20  	.byte 3," { "
001EC3  1               
001EC3  1               ;	bit @type
001EC3  1               ;	bpl @8
001EC3  1               ;	JSRD DotQuoteR
001EC3  1               ;	.byte 2,"' "
001EC3  1               ;@8:
001EC3  1  95 A8 04     	LDAX SW,ModNBRB,@bestadr ; type name
001EC6  1  B5 82        	STAX ZW,ModBMRB,0
001EC8  1  79 15 A1     	JSRD IdDot
001ECB  1               
001ECB  1  95 A8 02     	LDAX SW,ModNBRB,@bestoff
001ECE  1  14 0B        	BZ @7
001ED0  1  80 2B        	LDABL '+'
001ED2  1  79 0C CC     	JSRD EmitA
001ED5  1  95 A8 02     	LDAX SW,ModNBRB,@bestoff
001ED8  1  79 1D 07     	JSRD EX4A
001EDB  1               @7:
001EDB  1  79 14 2E     	JSRD PDotQuote
001EDE  1  01 7D        	.byte 1,"}"
001EE0  1               @69:
001EE0  1               
001EE0  1  30 AD        	INR SW,@adr+2		; rdrop work area
001EE2  1  09           	RSR
001EE3  1               
001EE3  1               
001EE3  1               	.if 0
001EE3  1               
001EE3  1                FHdr "See",0 ; ( “(spaces)name” -- )	; https://forth-standard.org/standard/tools/SEE
001EE3  1                  ; Display a disassembly of the named word’s definition.
001EE3  1               See:	JSRD Tick
001EE3  1               	JSRR DisAsm
001EE3  1               	INR ZW,2
001EE3  1               	RSR
001EE3  1               
001EE3  1               
001EE3  1                FHdr "SeeLatest",0 ; ( -- ) ; disassemble latest word
001EE3  1               SeeLatest:
001EE3  1               	LDAI VCurrrent
001EE3  1               	STAX ZW,ModBMRB,0
001EE3  1               @1:	JSRD Disasm1
001EE3  1               	LDAA ZW
001EE3  1               	LDBD MPtr
001EE3  1               	SAB
001EE3  1               	BNL @1
001EE3  1               	INR ZW,2
001EE3  1               	JSRD CR
001EE3  1               	JMPD CR
001EE3  1               
001EE3  1               
001EE3  1                FHdr "DisAsm",0 ; ( adr -- adr )	Disasemble a run of code
001EE3  1               DisAsm:	LDAL 100
001EE3  1               @2:	STAX SW,ModBMRB,0	; Y=adr
001EE3  1               	LDAA ZW
001EE3  1               	XAY
001EE3  1               	LDABA AW		; get opcode
001EE3  1               	LDBBL $71		;  JMPD
001EE3  1               	SABB
001EE3  1               	BZ @jmp
001EE3  1               	LDBBL $73		;  JMPR
001EE3  1               	SAB
001EE3  1               	BZ @4
001EE3  1               	LDBBL $09		;  RSR
001EE3  1               	SABB
001EE3  1               	BZ @4
001EE3  1               ;	LDBBL $79		;  JSRD
001EE3  1               ;	SABB
001EE3  1               ;	BNZ @5
001EE3  1               ;	LDAX YW,ModNBRB,1
001EE3  1               ;	LDBL FConsR
001EE3  1               ;	SAB
001EE3  1               ;	BZ @4
001EE3  1               ;	jsr PushAddrQ
001EE3  1               ;	bne @5
001EE3  1               @4:	LDBBL 1
001EE3  1               	STBA SW
001EE3  1               @5:
001EE3  1               	JSRD ADsm
001EE3  1               ;	JSRD dsn
001EE3  1               	LDAX SW,ModBRPB,0
001EE3  1               	DCA
001EE3  1               	BNZ @2
001EE3  1               	JMPD CR
001EE3  1               
001EE3  1               @jmp:	LDAX YW,ModNBRB,$fe
001EE3  1               	LDBL $fff0
001EE3  1               	NAB
001EE3  1               	LDABL $1003
001EE3  1               	SAB
001EE3  1               	BNZ @4
001EE3  1               	JMPR @5
001EE3  1               
001EE3  1               ;---------------------------------------------------------------------------
001EE3  1               
001EE3  1                FHdr "Disasm1",0 ; ( addr-1 -- addr-2 )  Disassemble 1 CPU6 instruction
001EE3  1                  ; Using self contained tables
001EE3  1               Disasm1:
001EE3  1               	JSRD CR			; new line
001EE3  1               	JSRD PDotQuote		; tab over hex part
001EE3  1               	.byte 2,9,9
001EE3  1               	LDBA ZW			; save starting addr
001EE3  1               	STBX SW,ModBMRB,0
001EE3  1               
001EE3  1               	JSRD @Fetch1		; fetch opcode
001EE3  1               	SLA			; get @Code table entry
001EE3  1               	LDBL @Code
001EE3  1               	AAB
001EE3  1               	LDBA BW
001EE3  1               	STBX ZW,ModBMRB,0
001EE3  1               
001EE3  1               	CLA			;type opcode name
001EE3  1               	XFR AL,BH
001EE3  1               	LDBL @Mnemonics
001EE3  1               	AAB
001EE3  1               	JMPR @18
001EE3  1               @11:	STBX SW,ModBMRB,0
001EE3  1               	JSRD EmitA
001EE3  1               	LDBX SW,ModBMRB,0
001EE3  1               @18:	LDABX BW,ModBRPB,0
001EE3  1               	BNZ @11
001EE3  1               
001EE3  1               	JSRD Space
001EE3  1               
001EE3  1               	LDAX ZW,ModNBRB,1	; get format entry from @Code entry
001EE3  1               	CLRB AH
001EE3  1               	LDBL @Formats
001EE3  1               	AAB
001EE3  1               @FmtN2:	CLA			; get next format char
001EE3  1               	LDABX BW,ModBRPB,0
001EE3  1               	BZ @Fmt99
001EE3  1               	STBX ZW,ModBMRB,0
001EE3  1               	LDBBL $20		; a function?
001EE3  1               	SABB
001EE3  1               	BNL @FEmit
001EE3  1               
001EE3  1               	LDBL @Formats		; call format routine
001EE3  1               	AAB
001EE3  1               	JSRX BW,ModBRB,0
001EE3  1               @FmtN8:	LDBX ZW,ModBRPB,0	; get fmt ptr
001EE3  1               	JMPR @FmtN2
001EE3  1               
001EE3  1               @FEmit:	JSRD EmitA
001EE3  1               	JMPR @FmtN8
001EE3  1               
001EE3  1               @Fmt99:				; end of format string
001EE3  1               
001EE3  1               
001EE3  1                HLT ;	??pla		;discard opcode
001EE3  1               	JSRD PDotQuote	;to begin of line
001EE3  1               	.byte 1,$0d
001EE3  1               	LDAA ZW		;type addr
001EE3  1               	JSRD EX4A
001EE3  1               	JSRD Space
001EE3  1                HLT ;???	pla
001EE3  1               	ldy #5
001EE3  1               @22:	phy
001EE3  1               	pha
001EE3  1               	tay
001EE3  1               	lda a:0,y	;type bytes
001EE3  1               	jsr EX2A
001EE3  1               	pla
001EE3  1               	ply
001EE3  1               	dey
001EE3  1               	beq @28
001EE3  1               	ina
001EE3  1               	cmp 0,x
001EE3  1               	bcc @22
001EE3  1               @28:	rts ; jmp CR
001EE3  1               
001EE3  1               
001EE3  1               @Fetch1: ; fetch next byte
001EE3  1               	LDBA SW
001EE3  1               	CLA
001EE3  1               	LDABX BW,ModBRPB,0
001EE3  1               	STBA SW
001EE3  1               	RSB
001EE3  1               
001EE3  1               @Fetch2: ; fetch next word
001EE3  1               	LDBA SW
001EE3  1               	LDAX BW,ModBRPB,0
001EE3  1               	STBA SW
001EE3  1               	RSB
001EE3  1               
001EE3  1               
001EE3  1               @Formats:
001EE3  1               	.dbyt 0,@Fmt1,@Fmt2,@Fmt3
001EE3  1               	.dbyt @Fmt4,@Fmt5,@Fmt6,@Fmt7
001EE3  1               	.dbyt @Fmt8,@Fmt9,@Fmt10,@Fmt11
001EE3  1               	.dbyt @Fmt12,@Fmt13,@Fmt14
001EE3  1               
001EE3  1               @Fmt1: ; 1 byte literal
001EE3  1               	JSRD @Fetch1		; fetch a byte
001EE3  1               	JSRD EX2A
001EE3  1               	JMPD @FmtNext
001EE3  1               
001EE3  1               @Fmt2: ; 2 byte literal
001EE3  1               	JSRD @Fetch2		; fetch a word
001EE3  1               	JSRD EX4A
001EE3  1               	JMPD @FmtNext
001EE3  1               
001EE3  1               @Fmt3: ; 1byte relative
001EE3  1               	JSRD @Fetch1		; fetch a signed byte
001EE3  1               	XFRB AH,AL
001EE3  1               	SRR AW,8
001EE3  1               	AAB			; add to location
001EE3  1               	JSRD EX4A
001EE3  1               	JMPD @FmtNext
001EE3  1               
001EE3  1               @Fmt4: ; byte register
001EE3  1               	JSRD @Fetch1		; fetch a byte
001EE3  1               	STABX ZW,ModBMRB,0	; save a copy
001EE3  1               	JSRR @RegB		; do dest reg
001EE3  1               	LDABL ','
001EE3  1               	JSRD EmitA
001EE3  1               	LDAX ZW,ModBRPB,0	; do src reg
001EE3  1               	SLL AW,4
001EE3  1               	JSRD @RegB
001EE3  1               	JMPD @FmtNext
001EE3  1               
001EE3  1               @RegR:	STABX SW,ModBMRB,0	; save
001EE3  1               	SRA			; do register letter
001EE3  1               	LDAL 7
001EE3  1               	NAB
001EE3  1               	LDAL @RegRA
001EE3  1               	AAB
001EE3  1               	LDAA BW
001EE3  1               	JSRD EmitA
001EE3  1               	LDABX SW,ModBMRB,0	; do register part
001EE3  1               	RSR
001EE3  1               
001EE3  1               @RegRA:	.byte 'ABXYZSCP'
001EE3  1               
001EE3  1               @RegB:	JSRR @RegR
001EE3  1               	SRA
001EE3  1               	LDABL 'H'
001EE3  1               	BNL @RegB3
001EE3  1               	LDABL 'L'
001EE3  1               @RegB3:	JMPD EmitA
001EE3  1               
001EE3  1               @Fmt5: ; word register & constant+1
001EE3  1               	HLT ;???
001EE3  1               
001EE3  1               @Fmt6: ; word register & constant
001EE3  1               	HLT ;???
001EE3  1               
001EE3  1               @Fmt7: ; dest byte registers
001EE3  1               	HLT ;???
001EE3  1               
001EE3  1               @Fmt8: ; src byte register
001EE3  1               	HLT ;???
001EE3  1               
001EE3  1               @Fmt9: ; dest word register
001EE3  1               	HLT ;???
001EE3  1               
001EE3  1               @Fmt10: ; src word register
001EE3  1               	HLT ;???
001EE3  1               
001EE3  1               @Fmt11: ; word indexed
001EE3  1               	HLT ;???
001EE3  1               
001EE3  1               @Fmt12: ; byte indexed
001EE3  1               	HLT ;???
001EE3  1               
001EE3  1               @Fmt13: ; register in opcode
001EE3  1               	LDBA SW			; get opcode again
001EE3  1               	CLA
001EE3  1               	LDABX BW,ModBMRB,0
001EE3  1               	SLA
001EE3  1               	JSRD @RegR
001EE3  1                HLT ;???
001EE3  1               
001EE3  1               
001EE3  1               
001EE3  1               ; https://github.com/Nakazoto/CenturionComputer/wiki/Instructions
001EE3  1               
001EE3  1               
001EE3  1               ; Modifier	Note
001EE3  1               ;  0 ; (r)	Index
001EE3  1               ;  1 ; (r+)	Index; Index returned, incremented by ^
001EE3  1               ;  2 ; (-r)	Decrement and Index
001EE3  1               ;  4 ; @(r)	Index indirect
001EE3  1               ;  5 ; @(r+)	Index indirect; Index returned, incremented by ^
001EE3  1               ;  6 ; @(-r)	Decrement and index indirect
001EE3  1               ;  8 ; n(r)	Index with displacement
001EE3  1               ;  9 ; n(r+)	Index with displacement; Index returned, incremented by ^
001EE3  1               ; $A ; n(-r)	Decrement and index with displacement
001EE3  1               ; $C ; @n(r)	Index with displacement indirect
001EE3  1               ; $D ; @n(r+)	Index with displacement indirect, Index returned, incremented by ^
001EE3  1               ; $E ; @n(-r)	Decrement and index with displacement indirect
001EE3  1               
001EE3  1               @Inh:	.byte 0 ; inherent
001EE3  1               @Rel:	.byte " ",3 ; 8bit relative
001EE3  1               @RelInd: .byte " (",3,")",0 ; 8bit relative indirect
001EE3  1               @BReg:	.byte " ",4,0 ; byte register
001EE3  1               @WReg1:	.byte " ",5,0 ; word register & constant+1
001EE3  1               @WReg:	.byte " ",6,0 ; word register & constant
001EE3  1               @DRB:	.byte " ",7,",",8,0 ; src & dest byte registers
001EE3  1               @DRW:	.byte " ",9,",",10,0 ; src & dest word registers (& extensions)
001EE3  1               @LitW:	.byte " #",2,0 ; literal word
001EE3  1               @LitB:	.byte " #",1,0 ; literal byte
001EE3  1               @Direct: .byte " ",2,0 ; direct
001EE3  1               @Indirect: .byte " (",2,")",0 ; indirect
001EE3  1               @WX:	.byte " ",11,0 ; word indexed
001EE3  1               @BX:	.byte " ",12,0 ; byte indexed
001EE3  1               @A:	.byte " ",13,0 ; register in opcode
001EE3  1               
001EE3  1               
001EE3  1               @Mnemonics:
001EE3  1               @mIll:	.byte "??",0
001EE3  1               @mHlt:	.byte "HLT",0
001EE3  1               @mNop:	.byte "NOP",0
001EE3  1               @mSF:	.byte "SF",0
001EE3  1               @mRF:	.byte "RF",0
001EE3  1               @mEI:	.byte "EI",0
001EE3  1               @mDI:	.byte "DI",0
001EE3  1               @mSL:	.byte "SL",0
001EE3  1               @mRL:	.byte "RL",0
001EE3  1               @mCL:	.byte "CL",0
001EE3  1               @mRSR:	.byte "RSR",0
001EE3  1               @mRI:	.byte "RI",0
001EE3  1               @mRIM:	.byte "RIM",0
001EE3  1               @mELO:	.byte "ELO",0
001EE3  1               @mPCX:	.byte "PCX",0
001EE3  1               @mDLY:	.byte "DLY",0
001EE3  1               @mRSys:	.byte "RSYS",0
001EE3  1               
001EE3  1               @mBL:	.byte "BL",0
001EE3  1               @mBNL:	.byte "BNL",0
001EE3  1               @mBF:	.byte "BF",0
001EE3  1               @mBNF:	.byte "BNF",0
001EE3  1               @mBZ:	.byte "BZ",0
001EE3  1               @mBNZ:	.byte "BNZ",0
001EE3  1               @mBM:	.byte "BM",0
001EE3  1               @mBF:	.byte "BF",0
001EE3  1               @mBGZ:	.byte "BGZ",0
001EE3  1               @mBLE:	.byte "BLE",0
001EE3  1               @mBS1:	.byte "BS1",0
001EE3  1               @mBS2:	.byte "BS2",0
001EE3  1               @mBS3:	.byte "BS3",0
001EE3  1               @mBS4:	.byte "BS4",0
001EE3  1               @mBTM:	.byte "BTM",0
001EE3  1               @mBEP:	.byte "BEP",0
001EE3  1               
001EE3  1               @mINRB:	.byte "INRB",0
001EE3  1               @mDCRB:	.byte "DCRB",0
001EE3  1               @mCLRB:	.byte "CLRB",0
001EE3  1               @mIVRB:	.byte "IVRB",0
001EE3  1               @mSRRB:	.byte "SRRB",0
001EE3  1               @mSLRB:	.byte "SLRB",0
001EE3  1               @mRRRB:	.byte "RRRB",0
001EE3  1               @mRLRB:	.byte "RLRB",0
001EE3  1               @mINAB:	.byte "INAB",0
001EE3  1               @mDCAB:	.byte "DCAB",0
001EE3  1               @mCLAB:	.byte "CLAB",0
001EE3  1               @mIVAB:	.byte "IVAB",0
001EE3  1               @mSRAB:	.byte "SRAB",0
001EE3  1               @mSLAB:	.byte "SLAB",0
001EE3  1               
001EE3  1               @mINR:	.byte "INR",0
001EE3  1               @mDCR:	.byte "DCR",0
001EE3  1               @mCLR:	.byte "CLR",0
001EE3  1               @mIVR:	.byte "IVR",0
001EE3  1               @mSRR:	.byte "SRR",0
001EE3  1               @mSLR:	.byte "SLR",0
001EE3  1               @mRRR:	.byte "RRR",0
001EE3  1               @mRLR:	.byte "RLR",0
001EE3  1               @mINA:	.byte "INA",0
001EE3  1               @mDCA:	.byte "DCA",0
001EE3  1               @mCLA:	.byte "CLA",0
001EE3  1               @mIVA:	.byte "IVA",0
001EE3  1               @mSRA:	.byte "SRA",0
001EE3  1               @mSLA:	.byte "SLA",0
001EE3  1               @mINX:	.byte "INX",0
001EE3  1               @mDCX:	.byte "DCX",0
001EE3  1               
001EE3  1               @mADDB:	.byte "ADDB",0
001EE3  1               @mSUBB:	.byte "SUBB",0
001EE3  1               @mANDB:	.byte "ANDB",0
001EE3  1               @mORIB:	.byte "ORIB",0
001EE3  1               @mOREB:	.byte "OREB",0
001EE3  1               @mXFRB:	.byte "XFRB",0
001EE3  1               @mAABB:	.byte "AABB",0
001EE3  1               @mSABB:	.byte "SABB",0
001EE3  1               @mNABB:	.byte "NABB",0
001EE3  1               @mXAXB:	.byte "XAXB",0
001EE3  1               @mXAYB:	.byte "XAYB",0
001EE3  1               @mXABB:	.byte "XABB",0
001EE3  1               @mXAZB:	.byte "XAZB",0
001EE3  1               @mXASB:	.byte "XASB",0
001EE3  1               
001EE3  1               @mADD:	.byte "ADD",0
001EE3  1               @mSUB:	.byte "SUB",0
001EE3  1               @mAND:	.byte "AND",0
001EE3  1               @mORI:	.byte "ORI",0
001EE3  1               @mORE:	.byte "ORE",0
001EE3  1               @mXFR:	.byte "XFR",0
001EE3  1               @mAAB:	.byte "AAB",0
001EE3  1               @mSAB:	.byte "SAB",0
001EE3  1               @mNAB:	.byte "NAB",0
001EE3  1               @mXAX:	.byte "XAX",0
001EE3  1               @mXAY:	.byte "XAY",0
001EE3  1               @mXAB:	.byte "XAB".0
001EE3  1               @mXAZ:	.byte "XAZ",0
001EE3  1               @mXAS:	.byte "XAS",0
001EE3  1               
001EE3  1               @mLDX:	.byte "LDX",0
001EE3  1               @mSTX:	.byte "STX",0
001EE3  1               @mJMP:	.byte "JMP",0
001EE3  1               @mSYSCALL: .byte "SYSCALL",0
001EE3  1               @mJSR:	.byte "JSR",0
001EE3  1               
001EE3  1               @mLDAB:	.byte "LDAB",0
001EE3  1               @mLDA:	.byte "LDA",0
001EE3  1               
001EE3  1               @mSTAB:	.byte "STAB",0
001EE3  1               @mSTA:	.byte "STA",0
001EE3  1               
001EE3  1               @mLDBB:	.byte "LDBB",0
001EE3  1               @mLDB:	.byte "LDB",0
001EE3  1               
001EE3  1               @mSTBB:	.byte "STBB",0
001EE3  1               @mSTB:	.byte "STB",0
001EE3  1               
001EE3  1               @mPUSH:	.byte "PUSH",0
001EE3  1               @mPOP:	.byte "POP",0
001EE3  1               
001EE3  1               @mMUL:	.byte "MUL",0
001EE3  1               @mDIV:	.byte "DIV",0
001EE3  1               
001EE3  1               
001EE3  1                 .macro CodeE Mnem,Fmt
001EE3  1               	.byte Mnem-@Mnem,Fmt
001EE3  1               	.endmacro
001EE3  1               
001EE3  1               @Code: ; indexed by 1st opcode byte
001EE3  1                 CodeE @mHlt,@Inh	;00
001EE3  1                 CodeE @mNop,@Inh	;01
001EE3  1                 CodeE @mSF,@Inh	;02
001EE3  1                 CodeE @mRF,@Inh	;03
001EE3  1                 CodeE @mEI,@Inh	;04
001EE3  1                 CodeE @mDI,@Inh	;05
001EE3  1                 CodeE @mSL,@Imh	;06
001EE3  1                 CodeE @mRL,@Inh	;07
001EE3  1                 CodeE @mCL,@Inh	;08
001EE3  1                 CodeE @mRSR,@Inh	;09
001EE3  1                 CodeE @mRI,@Inh	;0a
001EE3  1                 CodeE @mRIM,@Inh	;0b
001EE3  1                 CodeE @mELO,@Inh	;0c
001EE3  1                 CodeE @mPCX,@Inh	;0d
001EE3  1                 CodeE @mDLY,@Inh	;0e
001EE3  1                 CodeE @mRSys,@Inh	;0f
001EE3  1                 CodeE @mBL,@Rel	;10
001EE3  1                 CodeE @mBNL,@Rel	;11
001EE3  1                 CodeE @mBF,@Rel	;12
001EE3  1                 CodeE @mBNF,@Rel	;13
001EE3  1                 CodeE @mBZ,@Rel	;14
001EE3  1                 CodeE @mBNZ,@Rel	;15 BNZ adr ; Branch if V (Z) flag clear
001EE3  1                 CodeE @mBM,@Rel	;16 BM adr ; Branch if Minus flag set
001EE3  1                 CodeE @mBF,@Rel	;17 BP adr ; Branch on Positive (Minus flag clear)
001EE3  1                 CodeE @mBGZ,@Rel	;18 BGZ adr ; Branch if Greater Than 0 (!V && !Minus)
001EE3  1                 CodeE @mBLE,@Rel	;19 BLE adr ; Branch if Less Than or Equal to 0 (V | Minus)
001EE3  1                 CodeE @mBS1,@Rel	;1a BS1 adr ; Branch if Sense Switch 1 Set
001EE3  1                 CodeE @mBS2,@Rel	;1b BS2 adr ; Branch if Sense Switch 2 Set
001EE3  1                 CodeE @mBS3,@Rel	;1c BS3 adr ; Branch if Sense Switch 3 Set
001EE3  1                 CodeE @mBS4,@Rel	;1d BS4 adr ; Branch if Sense Switch 4 Set
001EE3  1                 CodeE @mBTM,@Rel	;1e BTM Rel ; Branch on TTY Mark (Changed for CPU6?)
001EE3  1                 CodeE @mBEP,@Rel	;1f BEP Rel ; Branch on Even Parity (Changed for CPU6?)
001EE3  1                 CodeE @mINRB,@BReg	;20 increment register upper byte or lower byte
001EE3  1                 CodeE @mDCRB,@BReg	;21 decrement register upper byte or lower byte
001EE3  1                 CodeE @mCLRB,@BReg	;22 clear register upper byte or lower byte
001EE3  1                 CodeE @mIVRB,@BReg	;23 invert register byte
001EE3  1                 CodeE @mSRRB,@BReg	;24 shift register byte right (sign extend)
001EE3  1                 CodeE @mSLRB,@BReg	;25 shift register byte left (0 shifted in)
001EE3  1                 CodeE @mRRRB,@BReg	;26 rotate register byte right (thru link flag)
001EE3  1                 CodeE @mRLRB,@BReg	;27
001EE3  1                 CodeE @mINAB,@Inh	;28 Increment AL register
001EE3  1                 CodeE @mDCAB,@Inh	;29 Decrement AL register
001EE3  1                 CodeE @mCLAB,@Inh	;2a Clear AL register
001EE3  1                 CodeE @mIVAB,@Inh	;2b Invert AL register
001EE3  1                 CodeE @mSRAB,@Inh	;2c Shift AL register right (sign extend)
001EE3  1                 CodeE @mSLAB,@Inh	;2d Shift AL register left (0 shifted in)
001EE3  1                 CodeE @mIll,@Inh	;2e Memory mapping
001EE3  1                 CodeE @mIll,@Inh	;2f DMA
001EE3  1                 CodeE @mINR,@WReg1	;30 increment register word
001EE3  1                 CodeE @mDCR,@WReg1	;31 decrement register word
001EE3  1                 CodeE @mCLR,@WReg	;32 clear register word
001EE3  1                 CodeE @mIVR,@WReg	;33 invert register word
001EE3  1                 CodeE @mSRR,@WReg1	;34 shift register right (sign extend)
001EE3  1                 CodeE @mSLR,@WReg1	;35 shift register left (0 shifted in)
001EE3  1                 CodeE @mRRR,@WReg1	;36 rotate register right (thru link flag)
001EE3  1                 CodeE @mRLR,@WReg1	;37 rotate register left (thru link flag)
001EE3  1                 CodeE @mINA,@Inh	;38 Increment AW register
001EE3  1                 CodeE @mDCA,@Inh	;39 Decrement AW register
001EE3  1                 CodeE @mCLA,@Inh	;3a Clear AW register
001EE3  1                 CodeE @mIVA,@Inh	;3b Invert AW register
001EE3  1                 CodeE @mSRA,@Inh	;3c Shift AW register right (sign extend)
001EE3  1                 CodeE @mSLA,@Inh	;3d Shift AW register left (0 shifted in)
001EE3  1                 CodeE @mINX,@Inh	;3e Increment XW register
001EE3  1                 CoddE @mDCX,@Inh	;3f Decrement XW register
001EE3  1                 CodeE @mADDB,@DRB	;40 DestReg,SrcReg ; Add byte Src to Dest
001EE3  1                 CodeE @mSUBB,@DRB	;41 DestReg,SrcReg ; Subtract byte Src to Dest
001EE3  1                 CodeE @mANDB,@DRB	;42 DestReg,SrcReg ; AND byte Src to Dest
001EE3  1                 CodeE @mORIB,@DRB	;43 DestReg,SrcReg ; OR byte Src to Dest
001EE3  1                 CodeE @mOREB,@DRB	;44 DestReg,SrcReg ; XOR byte Src to Dest
001EE3  1                 CodeE @mXFRB,@DRB	;45 DestReg,SrcReg ; Copy byte of Src register into byte of Dest register
001EE3  1                 CodeE @mIll,@Inh	;46
001EE3  1                 CodeE @mIll,@Inh	;47
001EE3  1                 CodeE @mAABB,@Inh	;48 BL+=AL
001EE3  1                 CodeE @mSABB,@Inh	;49 BL=AL-BL
001EE3  1                 CodeE.@mNABB,@Inh	;4a BL&=AL
001EE3  1                 CodeE @mXAXB,@Inh	;4b XL=AL
001EE3  1                 CodeE @mXAYB,@Inh	;4c YL=AL
001EE3  1                 CodeE @mXABB,@Inh	;4d BL=AL
001EE3  1                 CodeE @mXAZB,@Inh	;4e ZL=AL
001EE3  1                 CodeE @mXASL,@Inh	;4f SL=AL
001EE3  1                 CodeE @mADD,@DRW	;50 DestReg,SrcReg ; Add word Src to Dest
001EE3  1                 CoddE @mSUB,@DRW	;51 DestReg,SrcReg ; Subtract byte Src to Dest
001EE3  1                 CodeE @mANDC,@DRW	;52 DestReg,SrcReg ; AND word Src to Dest
001EE3  1                 CodeE @mORI,@DRW	;53 DestReg,SrcReg ; OR word Src to Dest
001EE3  1                 CodeE @mORE,@DRW	;54 DestReg,SrcReg ; XOR word Src to Dest
001EE3  1                 CodeE @mXFR,@DRW	;55 DestReg,SrcReg ; Copy Src register into Dest register
001EE3  1                 CodeE @mIll,@Inh	;56 ??
001EE3  1                 CodeE @mIll,@Inh	;57 ??
001EE3  1                 CodeE @mAAB,@Inh	;58 BW+=AW
001EE3  1                 CodeE @mSAB,@Inh	;59 BW=AW-BW
001EE3  1                 CodeE @mNAB,@Inh	;5a BW&=AW
001EE3  1                 CodeE @mXAX,@Inh	;5b XW=AW
001EE3  1                 CodeE @mXAY,@Inh	;5c YW=AW
001EE3  1                 CodeE @mXAB,@Inh	;5d BW=AW
001EE3  1                 CodeE @mXAZ,@Inh	;5e ZW=AW
001EE3  1                 CodeE @mXAS,@Inh	;5f SW=AW
001EE3  1                 CodeE @mLDX,@LitW	;60 Load immediate into XW
001EE3  1                 CodeE @mLDX,@Direct	;61 Load direct address into XW
001EE3  1                 CodeE @mLDX,@Indirect	;62 Load indirect address into XW
001EE3  1                 CodeE @mLDX,@Rel	;63 Load direct Program Counter offset by N address into XW
001EE3  1                 CodeE @mLDX,@RelInd	;64 Load indirect Program Counter offset by N address into XW
001EE3  1                 CodeE @mLDX,@WX	;65 Load indexed mode register into XW
001EE3  1                 CodeE @mIll,@Inh	;66 ??
001EE3  1                 CodeE @mIll,@Inh	;67 ??
001EE3  1                 CodeE @mSTX,@LitW	;68 Store XW into literal address (Not possible?)
001EE3  1                 CoddE @mSTX,@Direct	;69 Store XW into direct address
001EE3  1                 CodeE @mSTX,@Indirect	;6a Store XW into indirect address
001EE3  1                 CodeE @mSTX,@Rel	;6b Store XW into direct Program Counter offset by N address
001EE3  1                 CodeE @mSTX,@RelInd	;6c Store XW into indirect Program Counter offset by N address
001EE3  1                 CodeE @mSTX,@WX	;6d Store XW into indexed register
001EE3  1                 CodeE @mIll,@Inh	;6E ??
001EE3  1                 CodeE @mIll,@Inh	;6F ??
001EE3  1                 CodeE @mIll,@Inh	;70 ??
001EE3  1                 CodeE @mJMP,@Direct	;71 Jump to direct address
001EE3  1                 CodeE @mJMP,@Indirect	;72 Jump to indirect address
001EE3  1                 CodeE @mJMP,@Rel	;73 Jump to direct Program Counter offset by N address
001EE3  1                 CodeE @mJMP,@RelInd	;74 Jump to indirect Program Counter offset by N address
001EE3  1                 CodeE @mJMP,@WX	;75 WReg,Mod,Offset ;Jump to indexed mode register
001EE3  1                 CodeE @mSYSCALL,@Inh	;76 Call interrupt level 15
001EE3  1                 CodeE @mMUL,@Inh	;77	multiply
001EE3  1                 CodeE @mDIV,@Inh	;78	divide
001EE3  1                 CodeE @mJSR,@Direct	,79
001EE3  1                 CodeE @mJSR,@Indirect	;7a
001EE3  1                 CodeE @mJSR,@Rel	;7b
001EE3  1                 CodeE @mJSR,@RelInd	;7c
001EE3  1                 CodeE @mJSR,@WX	;7d	WReg,Mod,Offset ; Jump to subroutine at indexed mode register
001EE3  1                 CodeE @mPUSH,@Inh	;7e	RegCountM1
001EE3  1                 CodeE @mPOP,@Inh	;7f	RegCountM1
001EE3  1                 CodeE @mLDAB,@LitB	;80	Load literal address into AL register
001EE3  1                 CodeE @mLDAB,@Direct	;81	Load direct address into AL register
001EE3  1                 CodeE @mLDAB,@Indirect ;82	Load indirect address into AL register
001EE3  1                 CodeE @mLDAB,@Rel	;83	Load direct Program Counter offset by N address into AL register
001EE3  1                 CodeE @mLDAB,@RelInd	;84	Load indirect Program Counter offset by N address into byte of AL register
001EE3  1                 CodeE @mLDAB,@BX	;85	WReg,Mod,Offset ; Load indexed register into byte of AL register
001EE3  1                 CodeE @mIll,@Inh	;86	??
001EE3  1                 CodeE @mIll,@Inh	;87	??
001EE3  1                 CodeE @mLDAB,@A	;88	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDAB,@A	;89	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDAB,@A	;8a	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDAB,@A	;8b	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDAB,@A	;8c	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDAB,@A	;8d	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDAB,@A	;8e	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDAB,@A	;8f	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDA,@LitW	;90	Load literal address into full word of AW register
001EE3  1                 CodeE @mLDA,@Direct	;91	Load direct address into full word of AW register
001EE3  1                 CodeE @mLDA,@Indirect	;92	Load indirect address into full word of AW register
001EE3  1                 CodeE @mLDA,@Rel	;93	Load direct Program Counter offset by N address into full word of AW register
001EE3  1                 CodeE @mLDA,@RelInd	;94	Load indirect Program Counter offset by N address into full word of AW register
001EE3  1                 CodeE @mLDA,@WX	;95	WReg,Mod,Offset ; Load indexed register into full word of AW register
001EE3  1                 CodeE @mIll,@Inh	;96	??
001EE3  1                 CodeE @mIll,@Inh	;97	??
001EE3  1                 CodeE @mLDA,@A	;98	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDA,@A	;99	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDA,@A	;9a	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDA,@A	;9b	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDA,@A	;9c	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDA,@A	;9d	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDA,@A	;9e	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mLDA,@A	;9f	WReg ; Load byte from memory address stored in WReg into AL register
001EE3  1                 CodeE @mSTAB,@LitB	;a0	Store byte of AL register into literal address (Not possible?)
001EE3  1                 CodeE @mSTAB,@Direct	;a1	Store byte of AL register into direct address
001EE3  1                 CodeE @mSTAB,@Indirect ;a2	Store byte of AL register into indirect address
001EE3  1                 CodeE @mSTAB,@Rel	;a3	Store byte of AL register into direct Program Counter offset by N address
001EE3  1                 CodeE @mSTAB,@RelInd	;a4	Store byte of AL register into indirect Program Counter offset by N address
001EE3  1                 CodeE @mSTAB,@BX	;a5	WReg,Mod,Offset ; Store byte of AL register into indexed register
001EE3  1                 CodeE @mIll,@Inh	;A6	??
001EE3  1                 CodeE @mIll,@Inh	;A7	??
001EE3  1                 CodeE @mSTAB,@A	;a8	Store AL register to memory address stored in WReg
001EE3  1                 CodeE @mSTAB,@A	;a9	Store AL register to memory address stored in WReg
001EE3  1                 CodeE @mSTAB,@A	;aa	Store AL register to memory address stored in WReg
001EE3  1                 CodeE @mSTAB,@A	;ab	Store AL register to memory address stored in WReg
001EE3  1                 CodeE @mSTAB,@A	;ac	Store AL register to memory address stored in WReg
001EE3  1                 CodeE @mSTAB,@A	;ad	Store AL register to memory address stored in WReg
001EE3  1                 CodeE @mSTAB,@A	;ae	Store AL register to memory address stored in WReg
001EE3  1                 CodeE @mSTAB,@A	;af	Store AL register to memory address stored in WReg
001EE3  1                 CodeE @mSTA,@LitW	;b0	Store word of AW register into literal address (Not possible?)
001EE3  1                 CodeE @mSTA,@Direct	;b1	Store word of AW register into direct address
001EE3  1                 CodeE @mSTA,@Indirect	;b2	Store word of AW register into indirect address
001EE3  1                 CodeE @mSTA,@Rel	;b3	Store word of AW register into direct Program Counter offset by N address
001EE3  1                 CodeE @mSTA,@RelInd	;b4	Store word of AW register into indirect Program Counter offset by N address
001EE3  1                 CodeE @mSTA,@WX	;b5	WReg,Mod,Offset ; Store word of AW register into indexed register
001EE3  1                 CodeE @mIll,@Inh	;b6	??
001EE3  1                 CodeE @mIll,@Inh	;b7	??
001EE3  1                 CodeE @mSTA,@A	;b8	WReg ; Store AW register to memory address stored in WReg
001EE3  1                 CodeE @mSTA,@A	;b9	WReg ; Store AW register to memory address stored in WReg
001EE3  1                 CodeE @mSTA,@A	;ba	WReg ; Store AW register to memory address stored in WReg
001EE3  1                 CodeE @mSTA,@A	;bb	WReg ; Store AW register to memory address stored in WReg
001EE3  1                 CodeE @mSTA,@A	;bc	WReg ; Store AW register to memory address stored in WReg
001EE3  1                 CodeE @mSTA,@A	;bd	WReg ; Store AW register to memory address stored in WReg
001EE3  1                 CodeE @mSTA,@A	;be	WReg ; Store AW register to memory address stored in WReg
001EE3  1                 CodeE @mSTA,@A	;bf	WReg ; Store AW register to memory address stored in WReg
001EE3  1                 CodeE @mLDBB,@LitB	;c0	Load literal address into BL register
001EE3  1                 CodeE @mLDBB,@Direct	;c1	Load direct address into BL register
001EE3  1                 CodeE @mLDBB,@Indirect ;c2	Load indirect address into BL register
001EE3  1                 CodeE @mLDBB,@Rel	;c3	Load direct Program Counter offset by N address into BL register
001EE3  1                 CodeE @mLDBB,@RelInd	;c4	Load indirect Program Counter offset by N address into BL register
001EE3  1                 CodeE @mLDBB,@BX	;c5	WReg,Mod,Offset ; Load indexed register into BL register
001EE3  1                 CodeE @mIll,@Inh	;C6	??
001EE3  1                 CodeE @mIll,@Inh	;C7	??
001EE3  1                 CodeE @mLDBB,@A	;c8	Load byte from memory address stored in WReg into BL register
001EE3  1                 CodeE @mLDBB,@A	;c9	Load byte from memory address stored in WReg into BL register
001EE3  1                 CodeE @mLDBB,@A	;ca	Load byte from memory address stored in WReg into BL register
001EE3  1                 CodeE @mLDBB,@A	;cb	Load byte from memory address stored in WReg into BL register
001EE3  1                 CodeE @mLDBB,@A	;cc	Load byte from memory address stored in WReg into BL register
001EE3  1                 CodeE @mLDBB,@A	;cd	Load byte from memory address stored in WReg into BL register
001EE3  1                 CodeE @mLDBB,@A	;ce	Load byte from memory address stored in WReg into BL register
001EE3  1                 CodeE @mLDBB,@A	;cf	Load byte from memory address stored in WReg into BL register
001EE3  1                 CodeE @mLDB,@LitW	;d0	Load literal address into BW register
001EE3  1                 CodeE @mLDB,@Direct	;d1	Load direct address into BW register
001EE3  1                 CodeE @mLDB,@Indirect	;d2	Load indirect address into BW register
001EE3  1                 CodeE @mLDB,@Rel	;d3	Load direct Program Counter offset by N address into BW register
001EE3  1                 CodeE @mLDB,@RelInd	;d4	Load indirect Program Counter offset by N address into BW register
001EE3  1                 CodeE @mLDB,@WX	;d5	WReg,Mod,Offset ; Load indexed register into BW register
001EE3  1                 CodeE @mIll,@Inh	;D6	??
001EE3  1                 CodeE @mIll,@Inh	;D7	??
001EE3  1                 CodeE @mLDB,@A	;d8	Load word from memory address stored in WReg into BW register
001EE3  1                 CodeE @mLDB,@A	;d9	Load word from memory address stored in WReg into BW register
001EE3  1                 CodeE @mLDB,@A	;da	Load word from memory address stored in WReg into BW register
001EE3  1                 CodeE @mLDB,@A	;db	Load word from memory address stored in WReg into BW register
001EE3  1                 CodeE @mLDB,@A	;dc	Load word from memory address stored in WReg into BW register
001EE3  1                 CodeE @mLDB,@A	;dd	Load word from memory address stored in WReg into BW register
001EE3  1                 CodeE @mLDB,@A	;de	Load word from memory address stored in WReg into BW register
001EE3  1                 CodeE @mLDB,@A	;df	Load word from memory address stored in WReg into BW register
001EE3  1                 CodeE @mSTBB,@LitB	;e0	Store byte of BL register into literal address (Not possible?)
001EE3  1                 CodeE @mSTBB,@Direct	;e1	Store BL into direct address
001EE3  1                 CodeE @mSTBB,@Indirect ;e2	Store BL into indirect address
001EE3  1                 CodeE @mSTBB,@Rel	;e3	Store BL into direct Program Counter offset by N address
001EE3  1                 CodeE @mSTBB,@RelInd	;e4	Store BL into indirect Program Counter offset by N address
001EE3  1                 CodeE @mSTBB,@BX	;e5	WReg,Mod,Offset ; Store BL into indexed register
001EE3  1                 CodeE @mIll,@Inh	;E6	??
001EE3  1                 CodeE @mIll,@Inh	;E7	??
001EE3  1                 CodeE @mSTBB,@A	;e8	Store byte from BL register to memory address stored in WReg
001EE3  1                 CodeE @mSTBB,@A	;e9	Store byte from BL register to memory address stored in WReg
001EE3  1                 CodeE @mSTBB,@A	;ea	Store byte from BL register to memory address stored in WReg
001EE3  1                 CodeE @mSTBB,@A	;eb	Store byte from BL register to memory address stored in WReg
001EE3  1                 CodeE @mSTBB,@A	;ec	Store byte from BL register to memory address stored in WReg
001EE3  1                 CodeE @mSTBB,@A	;ed	Store byte from BL register to memory address stored in WReg
001EE3  1                 CodeE @mSTBB,@A	;ee	Store byte from BL register to memory address stored in WReg
001EE3  1                 CodeE @mSTBB,@A	;ef	Store byte from BL register to memory address stored in WReg
001EE3  1                 CodeE @mSTB,@LitW	;f0	Store BW into literal address (Not possible?)
001EE3  1                 CodeE @mSTB,@Direct	;f1	Store BW into direct address
001EE3  1                 CodeE @mSTB,@Indirect	;f2	Store BW into indirect address
001EE3  1                 CodeE @mSTB,@Rel	;f3	Store BW into direct Program Counter offset by N address
001EE3  1                 CodeE @mSTB,@RelInd	;f4	Store BW into indirect Program Counter offset by N address
001EE3  1                 CodeE @mSTB,@WX	;f5	WReg,Mod,Offset ; Store BW into indexed register
001EE3  1                 CodeE @mIll,@Inh	;f6	??
001EE3  1                 CodeE @mIll,@Inh	;f7	??
001EE3  1                 CodeE @mSTB,@A	;f8	Store BW to memory address stored in WReg
001EE3  1                 CodeE @mSTB,@A	;f9	Store BW to memory address stored in WReg
001EE3  1                 CodeE @mSTB,@A	;fa	Store BW to memory address stored in WReg
001EE3  1                 CodeE @mSTB,@A	;fb	Store BW to memory address stored in WReg
001EE3  1                 CodeE @mSTB,@A	;fc	Store BW to memory address stored in WReg
001EE3  1                 CodeE @mSTB,@A	;fd	Store BW to memory address stored in WReg
001EE3  1                 CodeE @mSTB,@A	;fe	Store BW to memory address stored in WReg
001EE3  1                 CodeE @mSTB,@A	;ff	Store BW to memory address stored in WReg
001EE3  1               
001EE3  1               
001EE3  1               
001EE3  1               ;---------------------------------------
001EE3  1               
001EE3  1               ;????????????????????????????????????????????????????????????
001EE3  1               
001EE3  1                 .macro AWordR name,rtn,opcode
001EE3  1               	FHdr name,0
001EE3  1               	JSRR rtn
001EE3  1               	.byte opcode
001EE3  1               	.endmacro
001EE3  1                 .macro AWordD name,rtn,opcode
001EE3  1               	FHdr name,0
001EE3  1               	JSRD rtn
001EE3  1               	.byte opcode
001EE3  1               	.endmacro
001EE3  1               
001EE3  1                FHdr 'IfL,',0 ; ( -- )  if Link (Carry) Set
001EE3  1               	LDABL $11
001EE3  1               If3:	JSRD CCommaA
001EE3  1               	CLA
001EE3  1               	JSRD CommaA
001EE3  1               	JMPD Here
001EE3  1               
001EE3  1                FHdr 'IfNL,',0 ; ( -- )  if Link (Carry) clear
001EE3  1               	LDABL $10
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfF,',0 ; ( -- )  if Fault Set
001EE3  1               	LDABL $13
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfNF,',0 ; ( -- )  if Fault not Set
001EE3  1               	LDABL $12
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfZ,',0 ; ( -- )  if V (Z) flag clear
001EE3  1               	LDABL $15
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfNZ,',0 ; ( -- )  if V (Z) flag set
001EE3  1               	LDABL $14
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfM,',0 ; ( -- )  if Minus flag set
001EE3  1               	LDABL $17
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfP,',0 ; ( --- )  if Minus flag clear
001EE3  1               	LDABL $16
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfLE,',0 ; ( -- )  if <=0
001EE3  1               	LDABL $18
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfGT,',0 ; ( -- ) if >0
001EE3  1               	LDABL $19
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfNS1,',0 ; ( -- )  if Sense Switch 1 clear
001EE3  1               	LDABL $1a
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfNS2,',0 ; ( -- )  if Sense Switch 2 clear
001EE3  1               	LDABL $1b
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfNS3,',0 ; ( -- )  if Sense Switch 3 clear
001EE3  1               	LDABL $1c
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'IfNS4,',0 ; ( -- )  if Sense Switch 4 clear
001EE3  1               	LDABL $1d
001EE3  1               	JMPR If3
001EE3  1               
001EE3  1                FHdr 'Then,',0
001EE3  1               ThenC:	LDAX ZW,ModBRPB,0	; pop addr
001EE3  1               	XAY
001EE3  1               	LDBD VDP
001EE3  1               	SUB AW,BW
001EE3  1               	LDBL $80
001EE3  1               	BNL @Err
001EE3  1               	STABX YW,ModNBRB,$ff
001EE3  1               	RSR
001EE3  1               @Err:	JSRD PDotQuote
001EE3  1               	.byte 12,"out of range"
001EE3  1               	JMPD Abort
001EE3  1               
001EE3  1                FHdr 'Else,',0
001EE3  1               	JSRR ThenC
001EE3  1               	LDABL $73	; JMPR n
001EE3  1               	JSRD CCommaA
001EE3  1               	CLA
001EE3  1               	JSRD CommaA
001EE3  1               	JMPD Here
001EE3  1               
001EE3  1               
001EE3  1                FHdr 'Begin,',0
001EE3  1               	JMPD Here
001EE3  1               ;UntilC: ???
001EE3  1               ; AWordR 'UntilL,'  ,UntilC,$11 ; Link (Carry) Set
001EE3  1               ; AWordR 'UntilNL,' ,UntilC,$10 ; Link (Carry) clear
001EE3  1               ; AWordR 'UntilF,'  ,UntilC,$13 ; Fault Set
001EE3  1               : AWordR 'UntilNF,' ,UntilC,$12 ; Fault not Set
001EE3  1               : AWodRR 'UntilZ,'  ,UntilC,$15 ; V (Z) flag clear
001EE3  1               : AWordR 'UntilNZ,' ,UntilC,$14 ; V (Z) flag set
001EE3  1               : AWordR 'UntilM,'  ,UntilC,$15 ; Minus flag set
001EE3  1               : AWordR 'UntilP,'  ,UntilC,$16 ; Minus flag clear
001EE3  1               : AWordR 'UntilLE,' ,UntilC,$18 ; <=0
001EE3  1               : AWordR 'UntilGT,' ,UntilC,$19 ; >0
001EE3  1               : AWordR 'UntilNS1,',UntilC,$1a ; Sense Switch 1 clear
001EE3  1               : AWordR 'UntilNS2,',UntilC,$1b ; if Sense Switch 2 clear
001EE3  1               : AWordR 'UntilNS3,',UntilC,$1c ; if Sense Switch 3 clear
001EE3  1               : AWordR 'UntilNS4,',UntilC,$1d ; if Sense Switch 4 clear
001EE3  1               ; While??,
001EE3  1               
001EE3  1               
001EE3  1               AIsClear:
001EE3  1               	LDABR AMode
001EE3  1               	BP @EMode
001EE3  1               	LDABR AReg1
001EE3  1               	BP @EReg
001EE3  1               	JMPD QStack
001EE3  1               @EMode:	JSRD PDotQuote
001EE3  1               	.byte 10,"extra mode"
001EE3  1               	JMPD Abort
001EE3  1               @EReg:	JSRD PDotQuote
001EE3  1               	.byte 10,"extra regs"
001EE3  1               	JMPD Abort
001EE3  1               
001EE3  1               AClear:
001EE3  1               	LDABL $ff
001EE3  1               	STABR AMode
001EE3  1               	STABR AReg1
001EE3  1               	STABR AReg2
001EE3  1               	RSR
001EE3  1               
001EE3  1               AMode:	.byte $ff	; indexed addressing mode
001EE3  1               
001EE3  1               AModeSet: ; remember indexed addr mode for next instruction
001EE3  1               	LDABR AMode	;empty?
001EE3  1               	BP @20
001EE3  1               	LDABA XW
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	STABR AMode
001EE3  1               	RSR
001EE3  1               
001EE3  1               @20:	JSRD PDotQuote
001EE3  1               	.byte 10,"extra mode"
001EE3  1               	JMPD Abort
001EE3  1               
001EE3  1                AWordR '(r)'   ,AModeSet,$0
001EE3  1                AWordR '(r+)'  ,AModeSet,$1
001EE3  1                AWordR '(-r)'  ,AModeSet,$2
001EE3  1                AWordR '@(r)'  ,AModeSet,$4
001EE3  1                AWordR '@(r+)' ,AModeSet,$5
001EE3  1                AWordR '@(-r)' ,AModeSet,$6
001EE3  1                AWordR 'n(r)'  ,AModeSet,$8
001EE3  1                AWordR 'n(r+)' ,AModeSet,$9
001EE3  1                AWordR 'n(-r)' ,AModeSet,$A
001EE3  1                AWordR '@n(r)' ,AModeSet,$C
001EE3  1                AWordR '@n(r+)',AModeSet,$D
001EE3  1                AWordR '@n(-r)',AModeSet,$E
001EE3  1               
001EE3  1               AReg1:	.byte $ff	; latest reg
001EE3  1               AReg2:	.byte $ff	; 2nd reg
001EE3  1               
001EE3  1               ARegPop:
001EE3  1               	LDABR AReg1
001EE3  1               	BM @Err
001EE3  1               	LDBBR AReg2
001EE3  1               	STBBR AReg1
001EE3  1               	LDBBL $ff
001EE3  1               	STBBR AReg2
001EE3  1               	RSR
001EE3  1               @Err:	JSRD PDotQuote
001EE3  1               	.byte $11,"missing reg"
001EE3  1               	JMPD Abort
001EE3  1               ARegSet:
001EE3  1               	LDBBR AReg2
001EE3  1               	BP @Err
001EE3  1               	LDBBR AReg1
001EE3  1               	STBBR AReg2
001EE3  1               	LDABA XW
001EE3  1               	STABR AReg1
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	RSR
001EE3  1               @Err:	JSRD PDotQuote
001EE3  1               	.byte 13,"too many regs"
001EE3  1               	JMPD Abort
001EE3  1               
001EE3  1               ; Register names
001EE3  1                AWordR 'AW',ARegSet,$30
001EE3  1                AWordR 'AH',ARegSet,$20
001EE3  1                AWordR 'AL',ARegSet,$21
001EE3  1                AWordR 'BW',ARegSet,$32
001EE3  1                AWordR 'BH',ARegSet,$22
001EE3  1                AWordR 'BL',ARegSet,$23
001EE3  1                AWordR 'XW',ARegSet,$34
001EE3  1                AWordR 'XH',ARegSet,$24
001EE3  1                AWordR 'XL',ARegSet,$25
001EE3  1                AWordR 'YW',ARegSet,$36
001EE3  1                AWordR 'YH',ARegSet,$26
001EE3  1                AWordR 'YL',ARegSet,$27
001EE3  1                AWordR 'ZW',ARegSet,$38
001EE3  1                AWordR 'ZH',ARegSet,$28
001EE3  1                AWordR 'ZL',ARegSet,$29
001EE3  1                AWordR 'SW',ARegSet,$3a
001EE3  1                AWordR 'CW',ARegSet,$3c
001EE3  1                AWordR 'PW',ARegSet,$3e
001EE3  1               
001EE3  1               
001EE3  1               A_Inherent: ; do instruction with no operands
001EE3  1               ;	LDAL 0		; disassembly routine
001EE3  1               	LDABA XW	; compile opcode
001EE3  1               	JSRD CCommaA
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	JMPD AIsClear
001EE3  1               
001EE3  1                AWordR 'HLT,',A_Inherent,$00
001EE3  1                AWordR 'NOP,',A_Inherent,$01
001EE3  1                AWordR 'SF,',A_Inherent,$02
001EE3  1                AWordR 'RF,',A_Inherent,$03
001EE3  1                AWordR 'EI,',A_Inherent,$04
001EE3  1                AWordR 'DI,',A_Inherent,$05
001EE3  1                AWordR 'SL,',A_Inherent,$06
001EE3  1                AWordR 'RL,',A_Inherent,$07
001EE3  1                AWordR 'CL,',A_Inherent,$08
001EE3  1                AWordR 'RSR,',A_Inherent,$09
001EE3  1                AWordR 'RI,',A_Inherent,$0A
001EE3  1                AWordR 'RIM,',A_Inherent,$0B
001EE3  1               ; AWordR 'ELO,',A_Inherent,$0C
001EE3  1                AWordR 'PCX,',A_Inherent,$0D
001EE3  1                AWordR 'DLY,',A_Inherent,$0E
001EE3  1                AWordR 'RSYS,',A_Inherent,$0F
001EE3  1               
001EE3  1                AWordR 'INAB,',A_Inherent,$28
001EE3  1                AWordR 'DCAB,',A_Inherent,$29
001EE3  1                AWordR 'CLAB,',A_Inherent,$2a
001EE3  1                AWordR 'IVAB,',A_Inherent,$2b
001EE3  1                AWordR 'SRAB,',A_Inherent,$2c
001EE3  1                AWordR 'SLAB,',A_Inherent,$2d
001EE3  1                AWordR 'INA,',A_Inherent,$38
001EE3  1                AWordR 'DCA,',A_Inherent,$39
001EE3  1                AWordR 'CLA,',A_Inherent,$3a
001EE3  1                AWordR 'IVA,',A_Inherent,$3b
001EE3  1                AWordR 'SRA,',A_Inherent,$3c
001EE3  1                AWordR 'SLA,',A_Inherent,$3d
001EE3  1                AWordR 'INX,',A_Inherent,$3e
001EE3  1                AWordR 'DCX,',A_Inherent,$3f
001EE3  1               
001EE3  1                AWordR 'AABB,',A_Inherent,$48
001EE3  1                AWordR 'SABB,',A_Inherent,$49
001EE3  1                AWordR 'NABB,',A_Inherent,$4a
001EE3  1                AWordR 'XAXB,',A_Inherent,$4b
001EE3  1                AWordR 'XAYB,',A_Inherent,$4c
001EE3  1                AWordR 'XABB,',A_Inherent,$4d
001EE3  1                AWordR 'XAZB,',A_Inherent,$4e
001EE3  1                AWordR 'XASB,',A_Inherent,$4f
001EE3  1               
001EE3  1                AWordR 'AAB,',A_Inherent,$58
001EE3  1                AWordR 'SAB,',A_Inherent,$59
001EE3  1                AWordR 'NAB,',A_Inherent,$5a
001EE3  1                AWordR 'XAX,',A_Inherent,$5b
001EE3  1                AWordR 'XAY,',A_Inherent,$5c
001EE3  1                AWordR 'XAB,',A_Inherent,$5d
001EE3  1                AWordR 'XAZ,',A_Inherent,$5e
001EE3  1                AWordR 'XAS,',A_Inherent,$5f
001EE3  1               
001EE3  1                AWordD 'SYSCALL,',A_Inherent,$76
001EE3  1               
001EE3  1               A_Rel: ; ( adr -- ) \ do instruction with relative addressing
001EE3  1                 ;	LDAL 0		; disassembly routine
001EE3  1               	LDAA XW		;compile opcode
001EE3  1               	JSRD CCommaA
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	LDAX ZW,ModBRPB,0	; pop addr
001EE3  1               	LDBD VDP		; calc displacement
001EE3  1               	INR BW,1
001EE3  1               	SAB
001EE3  1               	XFR AW,BW		; check range
001EE3  1               	SLA BW,8
001EE3  1               	SRA BW,8
001EE3  1               	SAB
001EE3  1               	BNZ @Err
001EE3  1               	JSRD CCommaA		; compile displacement
001EE3  1               	JMPD AIsClear
001EE3  1               
001EE3  1               @Err:	JSRD AClear
001EE3  1               	LDBL ERR_OutOfRange
001EE3  1               	JMPD ErrorY
001EE3  1               
001EE3  1                AWordR 'BL,' ,A_Rel,$10	; Branch if Link (Carry) Set
001EE3  1                AWordR 'BNL,',A_Rel,$11	; Branch if Link (Carry) not Set
001EE3  1                AWordR 'BF,' ,A_Rel,$12	; Branch if Fault Set
001EE3  1                AWordR 'BNF,',A_Rel,$13	; Branch if Fault not Set
001EE3  1                AWordR 'BZ ,',A_Rel,$14	; Branch if V (Z) flag set
001EE3  1                AWordR 'BNZ,',A_Rel,$15	; Branch if V (Z) flag clear
001EE3  1                AWordR 'BM,' ,A_Rel,$16	; Branch if Minus flag set
001EE3  1                AWordR 'BP,' ,A_Rel,$17	; Branch on Positive (Minus flag clear)
001EE3  1                AWordR 'BGZ,',A_Rel,$18	; Branch if > 0 (!V && !Minus)
001EE3  1                AWordR 'BLE,',A_Rel,$19	; Branch if <= to 0 (V | Minus)
001EE3  1                AWordR 'BS1,',A_Rel,$1a	; Branch if Sense Switch 1 Set
001EE3  1                AWordR 'BS2,',A_Rel,$1b	; Branch if Sense Switch 2 Set
001EE3  1                AWordR 'BS3,',A_Rel,$1c	; Branch if Sense Switch 3 Set
001EE3  1                AWordR 'BS4,',A_Rel,$1d	; Branch if Sense Switch 4 Set
001EE3  1               ; : BTM,  ( adr -- ) A_Rel [ $1e c, ] ;  \ Branch on TTY Mark (CPU6?)
001EE3  1                AWordR 'RSYS,',A_Rel,$1f
001EE3  1                AWodR 'LDABR,',A_Rel,$83
001EE3  1                AWodR 'LDAR,',A_Rel,$93
001EE3  1                AWordR 'STABR,',A_Rel,$a3
001EE3  1                AWordR 'STAR,',A_Rel,$b3
001EE3  1                AWordR 'LDBBR,',  A_Rel,$c3
001EE3  1                AWordR 'LDBR,',   A_Rel,$d3
001EE3  1                AWordR 'STBBR,',A_Rel,$e3
001EE3  1                AWordR 'STBR,',A_Rel,$f3
001EE3  1                AWordR 'LDXR,',A_Rel,$63
001EE3  1                AWordR 'STXR,',A_Rel,$6b
001EE3  1                AWordD 'JMPR,',A_Rel,$73
001EE3  1                AWordD 'JSRR,',A_Rel,$7b
001EE3  1               
001EE3  1               
001EE3  1               A_RelInd: ; ( adr -- )
001EE3  1                 ;	LDAL 0		; disassembly routine
001EE3  1               	JMPR A_Rel	; compiles like A_Rel
001EE3  1               
001EE3  1                AWordR 'LDABRI,',A_RelInd,$84
001EE3  1                AWordR 'LDARI,' ,A_RelInd,$94
001EE3  1                AWordR 'STABRI,',A_RelInd,$a4
001EE3  1                AWordR 'STARI,' ,A_RelInd,$b4
001EE3  1                AWordR 'LDBBRI,',A_RelInd,$c4
001EE3  1                AWordR 'LDBRI,', A_RelInd,$d4
001EE3  1                AWordR 'STBBRI,',A_RelInd,$e4
001EE3  1                AWordR 'STBRI,' ,A_RelInd,$f4
001EE3  1                AWordR 'LDXRI,' ,A_RelInd,$64
001EE3  1                AWordR 'STXRI,' ,A_RelInd,$6c
001EE3  1                AWordD 'JMPRI,' ,A_RelInd,$74
001EE3  1                AWordD 'JSRRI,' ,A_RelInd,$7c
001EE3  1               
001EE3  1               
001EE3  1               A_RegB: ; ( -- n ) \ convert BReg to n
001EE3  1               	JSRD ARegPop
001EE3  1               	LDBL $e0
001EE3  1               	ADDB AL,BL
001EE3  1               	LDBL $10
001EE3  1               	SABB
001EE3  1               	BL @Err
001EE3  1               	RSR
001EE3  1               
001EE3  1               @Err:	JSRD PDotQuote
001EE3  1               	.byte 8,"Bad BReg"
001EE3  1               	JMPD Abort
001EE3  1               
001EE3  1               A_RegW: ; ( -- n ) \ convert WReg to n
001EE3  1               	JSRD ARegPop
001EE3  1               	LDBL $d0
001EE3  1               	ADDB AL,BL
001EE3  1               	LDBL $10
001EE3  1               	SABB
001EE3  1               	BL @Err
001EE3  1               	JMPD AIsClear
001EE3  1               
001EE3  1               @Err:	JSRD PDotQuote
001EE3  1               	.byte 8,"Bad WReg"
001EE3  1               	JMPD Abort
001EE3  1               
001EE3  1               A_RegV: ; ( n  -- )
001EE3  1               	SLAB			; shift reg to hi nibble
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	STABX SW,ModBMRB,0	; save reg
001EE3  1               	LDAA XW			; compile opcode
001EE3  1               	JSRD CCommaA
001EE3  1               	LDAA ZW
001EE3  1               	LDBL $fff0		; check range
001EE3  1               	NAB
001EE3  1               	BNZ @Err
001EE3  1               	LDBBX SW,ModBRPB,0
001EE3  1               	ORIB AL,BL
001EE3  1               	JSRD CCommaA
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	JMPD AIsClear
001EE3  1               
001EE3  1               A_RegBV: ;  ( n -- )
001EE3  1                  ;	LDAL 0
001EE3  1               	JSRR A_RegB
001EE3  1               	JMPR A_RegV
001EE3  1               A_RegBVp1: ; ( n -- )
001EE3  1                  ;	LDAL 0
001EE3  1               	LDAA ZW
001EE3  1               	DCA
001EE3  1               	STAA ZW
001EE3  1               	JSRR A_RegB
001EE3  1               	JMPR A_RegV
001EE3  1               A_RegWV: ;   ( n -- )
001EE3  1                 ;	LDAL 0
001EE3  1               	JSRR A_RegW
001EE3  1               	JMPR A_RegV
001EE3  1               A_RegWVp1L ; ( n -- )
001EE3  1                 ;	LDAL 0
001EE3  1               	LDAA ZW
001EE3  1               	DCA
001EE3  1               	STAA ZW
001EE3  1               	JSRR A_RegW
001EE3  1               	JMPR A_RegV
001EE3  1               
001EE3  1                AWordR 'INRB,',A_RegBV,$20
001EE3  1                AWordR 'DCRB,',A_RegBV,$21
001EE3  1                AWordR 'CLRB,',A_RegBV,$22
001EE3  1                AWordR 'IVRB,',A_RegBV,$23
001EE3  1                AWordR 'SRRB,',A_RegBVp1,$24
001EE3  1                AWordR 'SLRB,',A_RegBVp1,$25
001EE3  1                AWordR 'RRRB,',A_RegBVp1,$26
001EE3  1                AWordR 'RLRB,',A_RegBVp1,$27
001EE3  1                AWordR 'INR,',A_RegWV,$30
001EE3  1                AWordR 'DCR,',A_RegWV,$31
001EE3  1                AWordR 'CLR,',A_RegWV,$32
001EE3  1                AWordR 'IVR,',A_RegWV,$33
001EE3  1                AWordR 'SRR,',A_RegWVp1,$34
001EE3  1                AWordR 'SLR,',A_RegWVp1,$35
001EE3  1                AWordR 'RRR,',A_RegWVp1,$36
001EE3  1                AWordR 'RLR,',A_RegWVp1,$37
001EE3  1               
001EE3  1                AWordD 'PUSH,',A_RegBVp1,$7e
001EE3  1                AWordD 'POP,',A_RegBVp1,$7f
001EE3  1               
001EE3  1               
001EE3  1               A_BRegReg: ; ( DestReg SrcReg -- ) \ 2 registers
001EE3  1               	LDAA XW		; compile opcode
001EE3  1               	JSRR CCommaA
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	JSRD A_RegB
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	STABX SW,ModBMRB,0
001EE3  1               	JSRD A_RegB
001EE3  1               	LDBBX SW,ModBRPB,0
001EE3  1               	ORIB AL,BL
001EE3  1               	JSRD CCommaA
001EE3  1               	JMPD AIsClear
001EE3  1               
001EE3  1                AWordR 'ADDB,',A_BRegReg,$40
001EE3  1                AWordR 'SUBB,',A_BRegReg,$41
001EE3  1                AWordR 'ANDB,',A_BRegReg,$42
001EE3  1                AWordR 'ORIB,',A_BRegReg,$43
001EE3  1                AWordR 'OREB,',A_BRegReg,$44
001EE3  1                AWordR 'XFRB,',A_BRegReg,$45
001EE3  1               
001EE3  1               
001EE3  1               A_WRegReg: ;  ( DestReg SrcReg -- ) \ 2 registers
001EE3  1                 ;	LDAL 0
001EE3  1               	LDAA XW		; copmile opcode
001EE3  1               	JSRD CCommaA
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	JSRD A_RegW
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	STABX SW,ModBMRB,0
001EE3  1               	JSRD A_RegW
001EE3  1               	LDBBX SW,ModBRPB,0
001EE3  1               	ORI AL,BL
001EE3  1               	JSRD CCommaA
001EE3  1               	JMPD AIsClear
001EE3  1               
001EE3  1                AWordR 'ADD,',A_WRegReg,$50
001EE3  1                AWordR 'SUB,',A_WRegReg,$51
001EE3  1                AWordR 'AND,',A_WRegReg,$52
001EE3  1                AWordR 'ORI,',A_WRegReg,$53
001EE3  1                AWordR 'ORE,',A_WRegReg,$54
001EE3  1                AWordR 'XFR,',A_WRegReg,$55
001EE3  1               
001EE3  1               
001EE3  1               A_LitB: ; ( n -- ) \ byte literal
001EE3  1                 ;	LDAL 0
001EE3  1               	LDABA XW		; compile opcode
001EE3  1               	JSRD CCommaA
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	LDABA ZW		; check operand
001EE3  1               	BNZ @Err
001EE3  1               	JSRD CComma		; compile operand
001EE3  1               	JMPD AIsClear
001EE3  1               @Err:	JSRD PDotQuote
001EE3  1               	.byte 25,"Byte literal out of range"
001EE3  1               	JMPD Abort
001EE3  1               
001EE3  1                AWordR 'LDABL,',A_LitB,$80
001EE3  1                AWordR 'STABL,',A_LitB,$a0
001EE3  1                AWordR 'LDBBL,',  A_LitB,$c0
001EE3  1                AWordR 'STBBL,',A_LitB,$E0
001EE3  1               
001EE3  1               A_LitW: ; ( n -- )  \ word literal
001EE3  1                 ;	LDAL 0
001EE3  1               	LDABA XW		; compile opcode
001EE3  1               	JSRD CCommaA
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	JSRD Comma		; compile operand
001EE3  1               	JMPD AIsClear
001EE3  1                AWordR 'LDAL,',A_LitW,$90
001EE3  1                AWordR 'STAL,',A_LitW,$b0
001EE3  1                AWordR 'LDBL,',A_LitW,$d0
001EE3  1                AWordR 'STBL,',A_LitW,$F0
001EE3  1                AWordR 'LDXL,',A_LitW,$60
001EE3  1                AWordR 'STXL,',A_LitW,$68
001EE3  1               
001EE3  1               A_Dir: ; ( n -- )  \ direct adr
001EE3  1                 ;	LDAL 0
001EE3  1               	JMPR A_LitW
001EE3  1                AWordR 'LDABD,',A_Dir,$81
001EE3  1                AWordR 'LDAD,',A_Dir,$91
001EE3  1                AWordR 'STABD,',A_Dir,$a1
001EE3  1                AWordR 'STAD,',A_Dir,$b1
001EE3  1                AWordR 'LDBBD,',  A_Dir,$c1
001EE3  1                AWordR 'LDBD,',   A_Dir,$d1
001EE3  1                AWordR 'STBBD,',A_Dir,$e1
001EE3  1                AWordR 'STBD,', A_Dir,$f1
001EE3  1                AWordR 'LDXD,',A_Dir,$61
001EE3  1                AWordR 'STXD,',A_Dir,$69
001EE3  1                AWordD 'JMPD,',A_Dir,$71
001EE3  1                AWordD 'JSRD,',A_Dir,$79
001EE3  1               
001EE3  1               A_DirInd: ; ( n -- ) \ direct indirect
001EE3  1                 ;	LDAL 0
001EE3  1               	JMPR A_Dir
001EE3  1                AWordR 'LDABI,',A_DirInd,$82
001EE3  1                AWordR 'LDAI,',A_DirInd,$92
001EE3  1                AWordR 'STABI,',A_DirInd,$a2
001EE3  1                AWordR 'STAI,',A_DirInd,$b2
001EE3  1                AWordR 'LDBBI,',  A_DirInd,$c2
001EE3  1                AWordR 'LDBI,',   A_DirInd,$d2
001EE3  1                AWordR 'STBBI,',A_DirInd,$e2
001EE3  1                AWordR 'STBI,', A_DirInd,$f2
001EE3  1                AWordR 'LDXI,',A_DirInd,$62
001EE3  1                AWordR 'STXI,',A_DirInd,$6a
001EE3  1                AWordD 'JMPI,',A_DirInd,$72
001EE3  1                AWordD 'JSRI,',A_DirInd,$7a
001EE3  1               
001EE3  1               A_Index: ; ( ?? -- )
001EE3  1                 ;	LDAL 0
001EE3  1               	LDABA XW		; compile opcode
001EE3  1               	JSRD CCommaA
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	JSRD A_RegW		; get reg
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	SLAB
001EE3  1               	LDBBD AMode
001EE3  1               	BM @Err
001EE3  1               	ORI AL,BL
001EE3  1               	LDBBL $ff
001EE3  1               	STBBD AMode
001EE3  1               	STABX SW,ModBMRB,0
001EE3  1               	JSRD CCommaA		; compile reg & mode
001EE3  1               	LDABX SW,ModBRPB,0
001EE3  1               	LDBBL 8			; offset byte?
001EE3  1               	NABB
001EE3  1               	BZ @18
001EE3  1               	JSRD CComma		;   compile offset byte
001EE3  1               @18:	JMPD AIsClear
001EE3  1               
001EE3  1               @Err:	JSRD PDotQuote
001EE3  1               	.byte "no mode"
001EE3  1               	JMPD Abort
001EE3  1               
001EE3  1                AWordR 'LDABX,',A_Index,$85
001EE3  1                AWordR 'LDAX,',A_Index,$95
001EE3  1                AWordR 'STABX,',A_Index,$a5
001EE3  1                AWordR 'STAX,',A_Index,$b5
001EE3  1                AWordR 'LDBBX,',A_Index,$c5
001EE3  1                AWordR 'LDBX,', A_Index,$d5
001EE3  1                AWordR 'STBBX,',A_Index,$e5
001EE3  1                AWordR 'STBX,',A_Index,$f5
001EE3  1                AWordR 'LDXX,',A_Index,$65
001EE3  1                AWordR 'STXX,',A_Index,$6d
001EE3  1                AWordD 'JMPX,',A_Index,$75
001EE3  1                AWordD 'JSRX,',A_Index,$7d
001EE3  1               
001EE3  1               A_RegInd: ; ( WReg -- ) \ register indirect
001EE3  1                 ;	LDAL 0
001EE3  1               	JSRD A_RegW
001EE3  1               	SRAB
001EE3  1               	LDBBA XW
001EE3  1               	LDXX SW,ModBRPB,0
001EE3  1               	ORIB AL,BL
001EE3  1               	JSRD CComma		; compile opcode
001EE3  1               	JMPD AIsClear
001EE3  1               
001EE3  1                AWordR 'LDABA,',A_RegInd,$88
001EE3  1                AWordR 'LDAA,',A_RegInd,$98
001EE3  1                AWordR 'STABA,',A_RegInd,$a8
001EE3  1                AWordR 'STAA,',A_RegInd,$b8
001EE3  1                AWordR 'LDBBA,',A_RegInd,$c8
001EE3  1                AWordR 'LDBA,',A_RegInd,$d8
001EE3  1                AWordR 'STBBA,',A_RegInd,$e8
001EE3  1                AWordR 'STBA,',A_RegInd,$f8
001EE3  1               
001EE3  1               
001EE3  1               ;  $2E ; Memory mapping?
001EE3  1               ;  $2F ; DMA?
001EE3  1               
001EE3  1               ;  .macro 66
001EE3  1               ;  .macro 67
001EE3  1               
001EE3  1               ; .byte $46	; memory block ops
001EE3  1               ; .byte $47 ; string ops
001EE3  1               
001EE3  1               ;  .macro 56
001EE3  1               ;  .macro 57
001EE3  1               
001EE3  1               ;  .macro 77
001EE3  1               ;  .macro $70
001EE3  1               ;  .macro 78?
001EE3  1               
001EE3  1               ;  .macro 86
001EE3  1               ;  .macro 87
001EE3  1               ;  .macro 96
001EE3  1               ;  .macro 97
001EE3  1               ;  .macro A6
001EE3  1               ;  .macro A7
001EE3  1               ; .macro B6
001EE3  1               ; .macro  B7
001EE3  1               ;  .macro C6
001EE3  1               ;  .macro C7
001EE3  1               ;  .macro E6
001EE3  1               ;  .macro E7
001EE3  1               
001EE3  1               ;  .macro F6
001EE3  1               ;  .macro F7
001EE3  1               
001EE3  1               ;  .macro D6
001EE3  1               ;  .macro D7
001EE3  1               ;  .macro 6E
001EE3  1               ;  .macro 6F
001EE3  1               
001EE3  1               
001EE3  1                .endif ; assembler & disassembler
001EE3  1               
001EE3  1               	.if 0
001EE3  1               ;-------------------------------------------------------------------------
001EE3  1               ; 12. The optional Floating-Point word set
001EE3  1               ; https://forth-standard.org/standard/float
001EE3  1               
001EE3  1               
001EE3  1               
001EE3  1               
001EE3  1               	.endif  ; floating point
001EE3  1               
001EE3  1               NTOP	= DictLink
001EE3  1               TOP:
001EE3  1               
001EE3  1               
001EE3  1               ;	.org $fc00 ; bootstrap ROM for simulator ------------------------------------
001EE3  1               ;
001EE3  1               ;	LDAL ReEnter	; set restart vector
001EE3  1               ;	STAD $1a
001EE3  1               ;	JMPD Enter	; just jmp to FORTH
001EE3  1               
001EE3  1               	.end
